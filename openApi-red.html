
            <script type='text/javascript'>
              {
                function render (node, options) {
                  try {
                    if (typeof node !== 'object') {
                      return
                    }
                    let minWidth = '400px'
                    if (options) {
                      if (options.minWidth) minWidth = options.minWidth
                    }
                    if (!node.__clone) {
                      node.__clone = window.$.extend(true, {}, node)
                    }
                    new OpenApi_red({
                      target: document.getElementById('openApi-red-svelte-container'),
                      props: { node: node.__clone }
                    })
                    document.getElementById('openApi-red-svelte-container').style.width = minWidth
                    const nodeIsSidebarTab = node?._def?.onchange
                    if (!nodeIsSidebarTab) {
                      const orgResize = node._def.oneditresize
                      node._def.oneditresize = function (size) {
                        document.getElementById('openApi-red-svelte-container').style.width = 'auto'
                        if (orgResize) orgResize(size)
                        node._def.oneditresize = orgResize
                      }
                    }
                  } catch (e) {
                      console.log(e)
                  }
                }
                function update (node) {
                  if (node.__clone) {
                    const clone = node.__clone
                    delete node.__clone
                    const defaultKeys = Object.keys(node._def.defaults)
                    for (const key of Object.keys(clone)) {
                      if (defaultKeys.indexOf(key) === -1) {
                        delete clone[key]
                      }
                    }
                    Object.assign(node, clone)
                  }
                }
                function revert (node) {
                  delete node.__clone
                }
                function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
}
class HtmlTag {
    constructor() {
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update$1(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update$1($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const getBooleanFrom = (property) => {
  return typeof property === 'boolean' ? property : property.toString().toLowerCase() === 'true'
};

const getId = (prop = null) => {
  let id = prop;
  if (!id) {
    id = Date.now() + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
  }
  return id
};

const getFadeDuration = (fading) => {
  let fadeDuration = 800;
  // do not use isNaN with boolean!
  if (typeof fading === 'number' || (typeof fading === 'string' && fading !== 'true' && fading !== 'false')) {
    fadeDuration = Number(fading);
  } else {
    fading = getBooleanFrom(fading);
    if (!fading) fadeDuration = 0;
  }
  return fadeDuration
};

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* node_modules/svelte-integration-red/components/Row.svelte generated by Svelte v3.43.0 */

function add_css$c(target) {
	append_styles(target, "svelte-1imhuc5", ".sir-Row.svelte-1imhuc5{clear:both;color:#555;margin-bottom:12px;display:flex;align-items:center;justify-content:flex-start}.sir-Row > *:not(:last-child){margin-right:7px}.sir-Row.inline button:not(:last-child){margin-right:3px}.sir-Row label{display:inline-block;min-width:105px;width:105px;margin-right:7px;align-items:center;margin-bottom:0px;overflow-wrap:break-word}i, .sir-Row label{user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}");
}

// (54:0) {:else}
function create_else_block$6(ctx) {
	let div;
	let t;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*indented*/ ctx[2] && create_if_block_2$6(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-1imhuc5"));
			attr(div, "style", /*style*/ ctx[4]);
			toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler_1*/ ctx[14]),
					listen(div, "dblclick", /*dblclick_handler_1*/ ctx[15]),
					listen(div, "mouseenter", /*mouseenter_handler_1*/ ctx[16]),
					listen(div, "mouseleave", /*mouseleave_handler_1*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$6(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*clazz*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-1imhuc5"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*clazz, inline*/ 10) {
				toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (47:0) {#if fadeDuration}
function create_if_block$c(ctx) {
	let div;
	let t;
	let div_class_value;
	let div_intro;
	let current;
	let mounted;
	let dispose;
	let if_block = /*indented*/ ctx[2] && create_if_block_1$a(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-1imhuc5"));
			attr(div, "style", /*style*/ ctx[4]);
			toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler*/ ctx[10]),
					listen(div, "dblclick", /*dblclick_handler*/ ctx[11]),
					listen(div, "mouseenter", /*mouseenter_handler*/ ctx[12]),
					listen(div, "mouseleave", /*mouseleave_handler*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*indented*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$a(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*clazz*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-1imhuc5"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*clazz, inline*/ 10) {
				toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, { duration: /*fadeDuration*/ ctx[5] });
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (56:4) {#if indented}
function create_if_block_2$6(ctx) {
	let label;

	return {
		c() {
			label = element("label");
			attr(label, "for", /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

// (49:4) {#if indented}
function create_if_block_1$a(ctx) {
	let label;

	return {
		c() {
			label = element("label");
			attr(label, "for", /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

function create_fragment$d(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$c, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*fadeDuration*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id, clazz = '', style = "", inline = false, maximize = false, indented = false, fading = true } = $$props;
	id = id || getId();
	if (!id.toString().startsWith("sir-")) id = "sir-row-" + id;
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	indented = getBooleanFrom(indented);
	const fadeDuration = getFadeDuration(fading);

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('clazz' in $$props) $$invalidate(3, clazz = $$props.clazz);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('inline' in $$props) $$invalidate(1, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('indented' in $$props) $$invalidate(2, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(7, fading = $$props.fading);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		id,
		inline,
		indented,
		clazz,
		style,
		fadeDuration,
		maximize,
		fading,
		$$scope,
		slots,
		click_handler,
		dblclick_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler_1,
		dblclick_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1
	];
}

class Row extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$d,
			create_fragment$d,
			safe_not_equal,
			{
				id: 0,
				clazz: 3,
				style: 4,
				inline: 1,
				maximize: 6,
				indented: 2,
				fading: 7
			},
			add_css$c
		);
	}
}

/* global localStorage, */

// Translation:
// current way with Node-RED tools:
// - an i18nOptions object for the node where we can set a prefix if the Node-Red node is not in the main folder.
// - to translate in a SIR component object just set the node property and set the path within the json file, e.g.: label:{ label.name }.
// - instead of giving the node property you can set an i18n property with the path to the local folder, e.g.: 'test-node/second-node:' or if in the main folder: 'second-node:'
//
// a different approach to the code below is to use the offical way like:
// - direct i18n in html <span data-i18n="test-node/second-node:second-node.label.name"></span>
// - setting to placeholder prop <input type="text" data-i18n="[placeholder]myNode.placeholder.foo">
//
// Sidenote: This translation is only working for custom nodes. Translations for the sir components are within their files.
// This must be done that way, as we must ensure translation, whether SIR is installed or not. Also it seems that Node-Red only initialize translation files
// for nodes registered in the package.json.
// Addition: Since Node-Red 2.0.3 we can't import i18next as this will break all other translations.

localStorage.getItem('editor-language') || navigator.language || 'en-US';

const i18nTranslate = (RED, node = {}, i18nDOM = true, translateThis) => {
  let result = translateThis;
  // i18n can be a string for the local folder path (which we can't have without node) or boolean false if we don't want to translate this one
  if (i18nDOM === false || i18nDOM.toString().trim() === 'false') {
    return result
  }

  let path = '';
  if (typeof i18nDOM === 'string') {
    path = i18nDOM;
  } else if (node) {
    path = node.type;
    let folder = node?._def?.i18nOptions?.folder;
    if (folder) {
      if (!folder.endsWith('/')) {
        folder += '/';
      }
      path = folder + path;
    }
  }
  if (path) {
    if (!path.endsWith(':')) path += ':';
    result = RED._(path + translateThis);
    // RED._() will replace colon with dot, so we have to check if result is like that pattern
    const translateColonReplacedWithDot = translateThis.replaceAll(':', '.');
    if (result === path + translateThis || result === path + translateColonReplacedWithDot || result === translateColonReplacedWithDot) {
      // couldn't find translation
      result = translateThis;
    }
  }
  return result
};

/* node_modules/svelte-integration-red/components/Button.svelte generated by Svelte v3.43.0 */

function add_css$b(target) {
	append_styles(target, "svelte-8kqjvg", ".sir-Button.svelte-8kqjvg{width:fit-content}.minWidth.svelte-8kqjvg{min-width:33px}.red-ui-button-small.svelte-8kqjvg{min-width:21px}button.red-ui-button.sir-Button:not(.primary):not(.disabled):not(:disabled):hover{background:#e0e0e0}.maximize.svelte-8kqjvg{width:100%}");
}

// (42:2) {#if indented}
function create_if_block_1$9(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (48:4) {#if icon}
function create_if_block$b(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-8kqjvg");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 512 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-8kqjvg")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (41:0) <Row id="sir-Button-Container-{id}" clazz="{clazz} sir-Button-Container" {inline} {fading}>
function create_default_slot$9(ctx) {
	let t0;
	let button;
	let t1;
	let t2_value = (/*label*/ ctx[0] || '') + "";
	let t2;
	let mounted;
	let dispose;
	let if_block0 = /*indented*/ ctx[3] && create_if_block_1$9();
	let if_block1 = /*icon*/ ctx[9] && create_if_block$b(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			button = element("button");
			if (if_block1) if_block1.c();
			t1 = space();
			t2 = text(t2_value);
			attr(button, "id", /*id*/ ctx[2]);
			attr(button, "style", /*style*/ ctx[12]);
			button.disabled = /*disabled*/ ctx[1];
			attr(button, "type", "button");
			attr(button, "class", "red-ui-button sir-Button svelte-8kqjvg");
			toggle_class(button, "maximize", /*maximize*/ ctx[5]);
			toggle_class(button, "selected", /*selected*/ ctx[11]);
			toggle_class(button, "red-ui-button-small", /*small*/ ctx[6]);
			toggle_class(button, "primary", /*primary*/ ctx[10] && !/*disabled*/ ctx[1]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, button, anchor);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			append(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", /*clickHandler*/ ctx[13]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[3]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1$9();
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$b(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*label*/ 1 && t2_value !== (t2_value = (/*label*/ ctx[0] || '') + "")) set_data(t2, t2_value);

			if (dirty & /*id*/ 4) {
				attr(button, "id", /*id*/ ctx[2]);
			}

			if (dirty & /*style*/ 4096) {
				attr(button, "style", /*style*/ ctx[12]);
			}

			if (dirty & /*disabled*/ 2) {
				button.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*maximize*/ 32) {
				toggle_class(button, "maximize", /*maximize*/ ctx[5]);
			}

			if (dirty & /*selected*/ 2048) {
				toggle_class(button, "selected", /*selected*/ ctx[11]);
			}

			if (dirty & /*small*/ 64) {
				toggle_class(button, "red-ui-button-small", /*small*/ ctx[6]);
			}

			if (dirty & /*primary, disabled*/ 1026) {
				toggle_class(button, "primary", /*primary*/ ctx[10] && !/*disabled*/ ctx[1]);
			}
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(button);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$c(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Button-Container-" + /*id*/ ctx[2],
				clazz: "" + (/*clazz*/ ctx[7] + " sir-Button-Container"),
				inline: /*inline*/ ctx[4],
				fading: /*fading*/ ctx[8],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 4) row_changes.id = "sir-Button-Container-" + /*id*/ ctx[2];
			if (dirty & /*clazz*/ 128) row_changes.clazz = "" + (/*clazz*/ ctx[7] + " sir-Button-Container");
			if (dirty & /*inline*/ 16) row_changes.inline = /*inline*/ ctx[4];
			if (dirty & /*fading*/ 256) row_changes.fading = /*fading*/ ctx[8];

			if (dirty & /*$$scope, id, style, disabled, maximize, selected, small, primary, label, icon, indented*/ 138863) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { clazz = '', disabled = false, fading = true, i18n, icon, id, indented = false, inline = false, label, maximize = false, node, primary = false, selected = false, small = false, style = "" } = $$props;
	small = getBooleanFrom(small);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);
	id = id || getId();
	if (label) label = i18nTranslate(RED, node, i18n, label);
	const dispatch = createEventDispatcher();

	function clickHandler(event) {
		dispatch('click', event.details);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(7, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(8, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(9, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('indented' in $$props) $$invalidate(3, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(4, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(15, node = $$props.node);
		if ('primary' in $$props) $$invalidate(10, primary = $$props.primary);
		if ('selected' in $$props) $$invalidate(11, selected = $$props.selected);
		if ('small' in $$props) $$invalidate(6, small = $$props.small);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*label, node, i18n*/ 49153) {
			{
				if (label) {
					$$invalidate(0, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}
	};

	return [
		label,
		disabled,
		id,
		indented,
		inline,
		maximize,
		small,
		clazz,
		fading,
		icon,
		primary,
		selected,
		style,
		clickHandler,
		i18n,
		node
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$c,
			create_fragment$c,
			safe_not_equal,
			{
				clazz: 7,
				disabled: 1,
				fading: 8,
				i18n: 14,
				icon: 9,
				id: 2,
				indented: 3,
				inline: 4,
				label: 0,
				maximize: 5,
				node: 15,
				primary: 10,
				selected: 11,
				small: 6,
				style: 12
			},
			add_css$b
		);
	}
}

/* node_modules/svelte-integration-red/components/Callout.svelte generated by Svelte v3.43.0 */

function add_css$a(target) {
	append_styles(target, "svelte-18iaieb", ".sir-Row.sir-Callout{display:flex;align-items:center;margin-bottom:12px 0px;border-left-width:5px;border-left-style:solid;border-left-color:#7e7e7e;background-color:#e4e4e4;color:#202020}.sir-Row.sir-Callout.indented{margin-left:112px}.sir-Callout-icon.svelte-18iaieb.svelte-18iaieb{padding-left:30px;margin-right:0px}.sir-Callout-icon.svelte-18iaieb i.svelte-18iaieb{font-size:3em;min-width:50px}.sir-Callout-content.svelte-18iaieb.svelte-18iaieb{padding:15px}.sir-Callout-content :is(p, div, span):last-child{padding-bottom:0px;margin-bottom:0px}.hasButton.svelte-18iaieb.svelte-18iaieb{padding-right:5px}.close-button.svelte-18iaieb.svelte-18iaieb{margin-bottom:auto;margin-left:auto;margin-top:6px;margin-right:6px}.sir-Row.sir-Callout.info{border-left-color:#0288D1;background-color:#d3efff;color:#015380}.sir-Row.sir-Callout.warning{border-left-color:#e27b41;background-color:#faeae0;color:#b6531c}.sir-Row.sir-Callout.error{border-left-color:#E84F4F;background-color:#fce8e8;color:#b91818}.sir-Row.sir-Callout.success{border-left-color:#52A256;background-color:#e7f3e7;color:#376c39}.sir-Callout :is(h1, h2, h3, h4, h5, h6){margin-top:0px;margin-bottom:10px\n  }");
}

const get_header_slot_changes$3 = dirty => ({});
const get_header_slot_context$3 = ctx => ({});

// (112:0) {#if show}
function create_if_block$a(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Callout-" + /*id*/ ctx[3],
				clazz: /*clazz*/ ctx[6] + " sir-Callout " + /*type*/ ctx[0] + (/*indented*/ ctx[4] ? ' indented' : ''),
				style: /*style*/ ctx[8],
				fading: /*fading*/ ctx[7],
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty & /*id*/ 8) row_changes.id = "sir-Callout-" + /*id*/ ctx[3];
			if (dirty & /*clazz, type, indented*/ 81) row_changes.clazz = /*clazz*/ ctx[6] + " sir-Callout " + /*type*/ ctx[0] + (/*indented*/ ctx[4] ? ' indented' : '');
			if (dirty & /*style*/ 256) row_changes.style = /*style*/ ctx[8];
			if (dirty & /*fading*/ 128) row_changes.fading = /*fading*/ ctx[7];

			if (dirty & /*$$scope, show, closeable, $$slots, icon*/ 8742) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

// (116:6) {#if $$slots.header}
function create_if_block_2$5(ctx) {
	let h2;
	let current;
	const header_slot_template = /*#slots*/ ctx[11].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[13], get_header_slot_context$3);

	return {
		c() {
			h2 = element("h2");
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			insert(target, h2, anchor);

			if (header_slot) {
				header_slot.m(h2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[13], dirty, get_header_slot_changes$3),
						get_header_slot_context$3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (121:4) {#if closeable}
function create_if_block_1$8(ctx) {
	let div;
	let button;
	let current;
	button = new Button({ props: { icon: "close" } });
	button.$on("click", /*click_handler*/ ctx[12]);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "close-button svelte-18iaieb");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (113:2) <Row id="sir-Callout-{id}" clazz={clazz + " sir-Callout " + type + (indented ? ' indented' : '')} {style} {fading}>
function create_default_slot$8(ctx) {
	let div0;
	let i;
	let i_class_value;
	let t0;
	let div1;
	let t1;
	let t2;
	let if_block1_anchor;
	let current;
	let if_block0 = /*$$slots*/ ctx[9].header && create_if_block_2$5(ctx);
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);
	let if_block1 = /*closeable*/ ctx[1] && create_if_block_1$8(ctx);

	return {
		c() {
			div0 = element("div");
			i = element("i");
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(i, "class", i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-18iaieb"));
			attr(div0, "class", "sir-Callout-icon svelte-18iaieb");
			attr(div1, "class", "sir-Callout-content svelte-18iaieb");
			toggle_class(div1, "hasButton", /*closeable*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, i);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-18iaieb"))) {
				attr(i, "class", i_class_value);
			}

			if (/*$$slots*/ ctx[9].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$$slots*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			if (dirty & /*closeable*/ 2) {
				toggle_class(div1, "hasButton", /*closeable*/ ctx[1]);
			}

			if (/*closeable*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*closeable*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$8(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$b(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*show*/ ctx[5] && create_if_block$a(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*show*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*show*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { clazz = "", closeable = false, fading = true, icon, id, indented = false, show = true, type = '', style = "" } = $$props;
	id = id || getId();
	indented = getBooleanFrom(indented);
	closeable = getBooleanFrom(closeable);
	show = getBooleanFrom(show);
	if (type === 'danger') type = 'error';
	let customIcon = false;

	if (icon) {
		customIcon = true;
		icon = icon.trim();

		if (!icon.startsWith('fa fa-')) {
			if (icon.startsWith('fa-')) icon = 'fa ' + icon; else icon = 'fa fa-' + icon;
		}
	}

	const click_handler = () => $$invalidate(5, show = false);

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(6, clazz = $$props.clazz);
		if ('closeable' in $$props) $$invalidate(1, closeable = $$props.closeable);
		if ('fading' in $$props) $$invalidate(7, fading = $$props.fading);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('indented' in $$props) $$invalidate(4, indented = $$props.indented);
		if ('show' in $$props) $$invalidate(5, show = $$props.show);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('style' in $$props) $$invalidate(8, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*customIcon, type*/ 1025) {
			{
				if (!customIcon) {
					switch (type) {
						case 'info':
							$$invalidate(2, icon = 'fa fa-info-circle');
							break;
						case 'warning':
							$$invalidate(2, icon = 'fa fa-exclamation-triangle');
							break;
						case 'error':
							$$invalidate(2, icon = 'fa fa-window-close');
							break;
						case 'success':
							$$invalidate(2, icon = 'fa fa-check-circle');
							break;
						default:
							$$invalidate(2, icon = 'fa fa-info-circle');
					}
				}
			}
		}
	};

	return [
		type,
		closeable,
		icon,
		id,
		indented,
		show,
		clazz,
		fading,
		style,
		$$slots,
		customIcon,
		slots,
		click_handler,
		$$scope
	];
}

class Callout extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$b,
			create_fragment$b,
			safe_not_equal,
			{
				clazz: 6,
				closeable: 1,
				fading: 7,
				icon: 2,
				id: 3,
				indented: 4,
				show: 5,
				type: 0,
				style: 8
			},
			add_css$a
		);
	}
}

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        if (duration === 0) {
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            store.set(value = target_value);
            return Promise.resolve();
        }
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

/* node_modules/svelte-integration-red/components/Collapsible.svelte generated by Svelte v3.43.0 */

function add_css$9(target) {
	append_styles(target, "svelte-y5kca2", ".border.svelte-y5kca2{padding:12px}.content.svelte-y5kca2{width:100%;overflow:hidden}.header.svelte-y5kca2{display:inline-flex;align-items:center;justify-content:space-between;width:100%}[id^='sir-Collapsible-'].sir-Collapsible label{width:auto;min-width:105px;margin-bottom:0px}.collabsible-icon.svelte-y5kca2{margin-right:5px}[id^='sir-Collapsible-'].sir-Row.sir-Collapsible, [id^='sir-Collapsible-'].sir-Collapsible{display:inline-flex;flex-direction:column;align-items:flex-start;width:100%;cursor:pointer}[id^='sir-Collapsible-'].sir-Collapsible .slotDiv{display:inline-flex;flex-direction:column;width:100%;margin-top:12px}[id^='sir-Collapsible-'].sir-Collapsible.indented{padding-left:12px;width:calc(100% - 12px)}");
}

const get_default_slot_changes$1 = dirty => ({ collapsed: dirty & /*collapsed*/ 1 });
const get_default_slot_context$1 = ctx => ({ collapsed: /*collapsed*/ ctx[0] });
const get_header_slot_changes$2 = dirty => ({ collapsed: dirty & /*collapsed*/ 1 });
const get_header_slot_context$2 = ctx => ({ collapsed: /*collapsed*/ ctx[0] });

// (111:8) {#if icon}
function create_if_block$9(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[8] + " svelte-y5kca2");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 256 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[8] + " svelte-y5kca2")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (106:0) <Row id="sir-Collapsible-{id}" clazz="{clazz} sir-Collapsible {indented ? " indented" : ""}" {inline} {fading} {style} >
function create_default_slot$7(ctx) {
	let div1;
	let div0;
	let i;
	let t0;
	let label_1;
	let t1;
	let t2;
	let label_1_for_value;
	let t3;
	let t4;
	let div3;
	let div2;
	let div3_id_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[8] && create_if_block$9(ctx);
	const header_slot_template = /*#slots*/ ctx[21].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[25], get_header_slot_context$2);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], get_default_slot_context$1);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			i = element("i");
			t0 = space();
			label_1 = element("label");
			if (if_block) if_block.c();
			t1 = space();
			t2 = text(/*label*/ ctx[5]);
			t3 = space();
			if (header_slot) header_slot.c();
			t4 = space();
			div3 = element("div");
			div2 = element("div");
			if (default_slot) default_slot.c();
			attr(i, "class", "fa fa-angle-right collabsible-icon svelte-y5kca2");
			attr(i, "style", /*iconStyle*/ ctx[12]);
			attr(label_1, "for", label_1_for_value = "collapsible-" + /*id*/ ctx[2] + "-content");
			attr(label_1, "class", "label");
			attr(div0, "class", "label");
			attr(div1, "class", "header svelte-y5kca2");
			attr(div2, "class", "slotDiv");
			attr(div3, "id", div3_id_value = "collapsible-" + /*id*/ ctx[2] + "-content");
			attr(div3, "class", "content svelte-y5kca2");
			attr(div3, "style", /*slotHeightStyle*/ ctx[11]);
			toggle_class(div3, "red-ui-editableList-border", /*border*/ ctx[1]);
			toggle_class(div3, "border", /*border*/ ctx[1]);
			toggle_class(div3, "collapsed", /*collapsed*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, i);
			append(div0, t0);
			append(div0, label_1);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t1);
			append(label_1, t2);
			append(div1, t3);

			if (header_slot) {
				header_slot.m(div1, null);
			}

			insert(target, t4, anchor);
			insert(target, div3, anchor);
			append(div3, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[24](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(i, "click", /*handleClick*/ ctx[15]),
					listen(i, "click", /*click_handler*/ ctx[23]),
					listen(label_1, "click", /*handleClick*/ ctx[15]),
					listen(label_1, "click", /*click_handler_1*/ ctx[22])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty & /*iconStyle*/ 4096) {
				attr(i, "style", /*iconStyle*/ ctx[12]);
			}

			if (/*icon*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					if_block.m(label_1, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*label*/ 32) set_data(t2, /*label*/ ctx[5]);

			if (!current || dirty & /*id*/ 4 && label_1_for_value !== (label_1_for_value = "collapsible-" + /*id*/ ctx[2] + "-content")) {
				attr(label_1, "for", label_1_for_value);
			}

			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope, collapsed*/ 33554433)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[25],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[25], dirty, get_header_slot_changes$2),
						get_header_slot_context$2
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, collapsed*/ 33554433)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[25],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[25], dirty, get_default_slot_changes$1),
						get_default_slot_context$1
					);
				}
			}

			if (!current || dirty & /*id*/ 4 && div3_id_value !== (div3_id_value = "collapsible-" + /*id*/ ctx[2] + "-content")) {
				attr(div3, "id", div3_id_value);
			}

			if (!current || dirty & /*slotHeightStyle*/ 2048) {
				attr(div3, "style", /*slotHeightStyle*/ ctx[11]);
			}

			if (dirty & /*border*/ 2) {
				toggle_class(div3, "red-ui-editableList-border", /*border*/ ctx[1]);
			}

			if (dirty & /*border*/ 2) {
				toggle_class(div3, "border", /*border*/ ctx[1]);
			}

			if (dirty & /*collapsed*/ 1) {
				toggle_class(div3, "collapsed", /*collapsed*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			if (header_slot) header_slot.d(detaching);
			if (detaching) detach(t4);
			if (detaching) detach(div3);
			if (default_slot) default_slot.d(detaching);
			/*div2_binding*/ ctx[24](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$a(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Collapsible-" + /*id*/ ctx[2],
				clazz: "" + (/*clazz*/ ctx[6] + " sir-Collapsible " + (/*indented*/ ctx[3] ? " indented" : "")),
				inline: /*inline*/ ctx[4],
				fading: /*fading*/ ctx[7],
				style: /*style*/ ctx[9],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 4) row_changes.id = "sir-Collapsible-" + /*id*/ ctx[2];
			if (dirty & /*clazz, indented*/ 72) row_changes.clazz = "" + (/*clazz*/ ctx[6] + " sir-Collapsible " + (/*indented*/ ctx[3] ? " indented" : ""));
			if (dirty & /*inline*/ 16) row_changes.inline = /*inline*/ ctx[4];
			if (dirty & /*fading*/ 128) row_changes.fading = /*fading*/ ctx[7];
			if (dirty & /*style*/ 512) row_changes.style = /*style*/ ctx[9];

			if (dirty & /*$$scope, id, slotHeightStyle, border, collapsed, slotDiv, label, icon, iconStyle*/ 33561895) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let iconStyle;
	let slotHeightStyle;
	let $slotHeight;
	let $rotation;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { border = false, clazz = '', collapsed = false, fading = true, i18n, icon, id, indented = false, inline = false, label, node, style = "" } = $$props;
	id = id || getId();
	indented = getBooleanFrom(indented);
	border = getBooleanFrom(border);
	inline = getBooleanFrom(inline);
	collapsed = getBooleanFrom(collapsed);

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	const rotation = tweened(collapsed ? 0 : 90, { duration: 400, easing: cubicOut });
	component_subscribe($$self, rotation, value => $$invalidate(20, $rotation = value));
	let slotDiv;
	let maxSlotHeight = 0;
	const slotHeight = tweened(0, { duration: 400, easing: cubicOut });
	component_subscribe($$self, slotHeight, value => $$invalidate(19, $slotHeight = value));

	onMount(() => {
		handleResize(true);
	});

	function handleResize(initial = false) {
		let computedSlotHeight = parseInt(getComputedStyle(slotDiv).height);
		if (!isNaN(computedSlotHeight)) computedSlotHeight += 12; // add margin to label

		if (collapsed && maxSlotHeight !== computedSlotHeight) {
			// Prevent flickering when the content was resized and we didn't notice before
			slotHeight.set(computedSlotHeight, { duration: 0 });
		}

		if (computedSlotHeight && computedSlotHeight !== 'auto') {
			$$invalidate(18, maxSlotHeight = computedSlotHeight);
		}

		if (initial) {
			// We do not want animation on first render
			slotHeight.set(collapsed ? 0 : maxSlotHeight, { duration: 0 });
		} else {
			slotHeight.set(collapsed ? 0 : maxSlotHeight);
		}
	}

	function handleClick() {
		if (collapsed) {
			rotation.set(90);
		} else {
			rotation.set(0);
		}

		$$invalidate(0, collapsed = !collapsed);

		// debugger
		handleResize();
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			slotDiv = $$value;
			$$invalidate(10, slotDiv);
		});
	}

	$$self.$$set = $$props => {
		if ('border' in $$props) $$invalidate(1, border = $$props.border);
		if ('clazz' in $$props) $$invalidate(6, clazz = $$props.clazz);
		if ('collapsed' in $$props) $$invalidate(0, collapsed = $$props.collapsed);
		if ('fading' in $$props) $$invalidate(7, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(16, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(8, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('indented' in $$props) $$invalidate(3, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(4, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('node' in $$props) $$invalidate(17, node = $$props.node);
		if ('style' in $$props) $$invalidate(9, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(25, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$rotation*/ 1048576) {
			$$invalidate(12, iconStyle = 'transform:rotate(' + $rotation + 'deg);');
		}

		if ($$self.$$.dirty & /*collapsed, $slotHeight, maxSlotHeight*/ 786433) {
			$$invalidate(11, slotHeightStyle = 'height: ' + (!collapsed && $slotHeight === maxSlotHeight
			? '100%;'
			: $slotHeight + 'px;'));
		}
	};

	return [
		collapsed,
		border,
		id,
		indented,
		inline,
		label,
		clazz,
		fading,
		icon,
		style,
		slotDiv,
		slotHeightStyle,
		iconStyle,
		rotation,
		slotHeight,
		handleClick,
		i18n,
		node,
		maxSlotHeight,
		$slotHeight,
		$rotation,
		slots,
		click_handler_1,
		click_handler,
		div2_binding,
		$$scope
	];
}

class Collapsible extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$a,
			create_fragment$a,
			safe_not_equal,
			{
				border: 1,
				clazz: 6,
				collapsed: 0,
				fading: 7,
				i18n: 16,
				icon: 8,
				id: 2,
				indented: 3,
				inline: 4,
				label: 5,
				node: 17,
				style: 9
			},
			add_css$9
		);
	}
}

function flip(node, { from, to }, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
        easing,
        css: (t, u) => {
            const x = u * dx;
            const y = u * dy;
            const sx = t + u * from.width / to.width;
            const sy = t + u * from.height / to.height;
            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
        }
    };
}

/* node_modules/svelte-integration-red/components/EditableList.svelte generated by Svelte v3.43.0 */

function add_css$8(target) {
	append_styles(target, "svelte-ivm6tt", "li.svelte-ivm6tt.svelte-ivm6tt{display:inline-flex;width:100%;align-items:center}li.svelte-ivm6tt .red-ui-editableList-item-content.svelte-ivm6tt{width:100%;margin:0px 8px}li.svelte-ivm6tt .red-ui-editableList-item-remove.svelte-ivm6tt{position:initial;margin:0px 3px 0px 0px}li.svelte-ivm6tt .red-ui-editableList-item-handle.svelte-ivm6tt{position:initial;margin:0px 0px 0px 3px}.disabled.svelte-ivm6tt.svelte-ivm6tt{pointer-events:none}[id^='sir-EditableList-'].sir-Row.sir-EditableList{align-items:flex-start;flex-direction:column}[id^='sir-EditableList-'].sir-Row.sir-EditableList div:last-child{margin-bottom:0px}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList-container{min-height:100px;overflow-y:auto !important;overflow-x:hidden}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList{width:100%}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList-item-remove button{min-width:auto}.halfTransparent.svelte-ivm6tt.svelte-ivm6tt{opacity:.5}.dropzoneUnder.svelte-ivm6tt.svelte-ivm6tt{border-top:3px solid #ccc}.dropzoneAbove.svelte-ivm6tt.svelte-ivm6tt{border-bottom:3px solid #ccc}.header.svelte-ivm6tt label.svelte-ivm6tt{width:auto;cursor:initial}.header.svelte-ivm6tt.svelte-ivm6tt{display:inline-flex;align-items:center;justify-content:space-between;width:100%;margin-bottom:5px}");
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[43] = i;
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	element: dirty[0] & /*elements*/ 4,
	index: dirty[0] & /*elements*/ 4
});

const get_default_slot_context = ctx => ({
	element: /*element*/ ctx[41],
	index: /*index*/ ctx[43]
});

const get_header_slot_changes$1 = dirty => ({
	element: dirty[0] & /*elements*/ 4,
	index: dirty[0] & /*elements*/ 4
});

const get_header_slot_context$1 = ctx => ({
	element: /*element*/ ctx[41],
	index: /*index*/ ctx[43]
});

// (117:4) {#if label}
function create_if_block_3$4(ctx) {
	let label_1;
	let t0;
	let t1;
	let if_block = /*icon*/ ctx[15] && create_if_block_4$4(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[7]);
			attr(label_1, "for", /*nodeInputId*/ ctx[19]);
			attr(label_1, "class", "svelte-ivm6tt");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[15]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$4(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 128) set_data(t1, /*label*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (118:34) {#if icon}
function create_if_block_4$4(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[15] + " svelte-ivm6tt");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 32768 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[15] + " svelte-ivm6tt")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (137:12) {#if sortable}
function create_if_block_2$4(ctx) {
	let i;
	let mounted;
	let dispose;

	return {
		c() {
			i = element("i");
			attr(i, "class", "red-ui-editableList-item-handle fa fa-bars svelte-ivm6tt");
			toggle_class(i, "disabled", /*disabled*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, i, anchor);

			if (!mounted) {
				dispose = [
					listen(i, "mouseover", /*mouseover_handler*/ ctx[31]),
					listen(i, "focus", /*focus_handler*/ ctx[32]),
					listen(i, "mouseout", /*mouseout_handler*/ ctx[33]),
					listen(i, "blur", /*blur_handler*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 2) {
				toggle_class(i, "disabled", /*disabled*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (146:12) {#if removable}
function create_if_block_1$7(ctx) {
	let div;
	let button;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[35](/*index*/ ctx[43]);
	}

	button = new Button({
			props: {
				small: true,
				icon: "remove",
				disabled: /*disabled*/ ctx[1]
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "red-ui-editableList-item-remove svelte-ivm6tt");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty[0] & /*disabled*/ 2) button_changes.disabled = /*disabled*/ ctx[1];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (125:8) {#each elements as element, index (typeof element === 'object' ? element.id || element : index)}
function create_each_block$3(key_1, ctx) {
	let li;
	let t0;
	let div;
	let t1;
	let t2;
	let li_id_value;
	let rect;
	let stop_animation = noop;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*sortable*/ ctx[12] && create_if_block_2$4(ctx);
	const default_slot_template = /*#slots*/ ctx[29].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[39], get_default_slot_context);
	let if_block1 = /*removable*/ ctx[11] && create_if_block_1$7(ctx);

	function dragstart_handler(...args) {
		return /*dragstart_handler*/ ctx[36](/*index*/ ctx[43], ...args);
	}

	function drop_handler(...args) {
		return /*drop_handler*/ ctx[37](/*index*/ ctx[43], ...args);
	}

	function dragenter_handler() {
		return /*dragenter_handler*/ ctx[38](/*index*/ ctx[43]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			attr(div, "class", "red-ui-editableList-item-content svelte-ivm6tt");
			attr(li, "id", li_id_value = /*index*/ ctx[43]);
			attr(li, "draggable", /*isDraggable*/ ctx[18]);
			attr(li, "class", "svelte-ivm6tt");
			toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[12]);
			toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[11]);
			toggle_class(li, "dropzoneUnder", /*hovering*/ ctx[16] === /*index*/ ctx[43] && /*hovering*/ ctx[16] < /*draggingIndex*/ ctx[17]);
			toggle_class(li, "dropzoneAbove", /*hovering*/ ctx[16] === /*index*/ ctx[43] && /*hovering*/ ctx[16] > /*draggingIndex*/ ctx[17]);
			toggle_class(li, "halfTransparent", /*hovering*/ ctx[16] !== /*index*/ ctx[43] && /*index*/ ctx[43] === /*draggingIndex*/ ctx[17]);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append(li, t0);
			append(li, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(li, t1);
			if (if_block1) if_block1.m(li, null);
			append(li, t2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "dragstart", dragstart_handler),
					listen(li, "drop", prevent_default(drop_handler)),
					listen(li, "dragover", prevent_default(/*dragover_handler*/ ctx[30])),
					listen(li, "dragenter", dragenter_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*sortable*/ ctx[12]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$4(ctx);
					if_block0.c();
					if_block0.m(li, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*elements*/ 4 | dirty[1] & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[39],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[39])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[39], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}

			if (/*removable*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*removable*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*elements*/ 4 && li_id_value !== (li_id_value = /*index*/ ctx[43])) {
				attr(li, "id", li_id_value);
			}

			if (!current || dirty[0] & /*isDraggable*/ 262144) {
				attr(li, "draggable", /*isDraggable*/ ctx[18]);
			}

			if (dirty[0] & /*sortable*/ 4096) {
				toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[12]);
			}

			if (dirty[0] & /*removable*/ 2048) {
				toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[11]);
			}

			if (dirty[0] & /*hovering, elements, draggingIndex*/ 196612) {
				toggle_class(li, "dropzoneUnder", /*hovering*/ ctx[16] === /*index*/ ctx[43] && /*hovering*/ ctx[16] < /*draggingIndex*/ ctx[17]);
			}

			if (dirty[0] & /*hovering, elements, draggingIndex*/ 196612) {
				toggle_class(li, "dropzoneAbove", /*hovering*/ ctx[16] === /*index*/ ctx[43] && /*hovering*/ ctx[16] > /*draggingIndex*/ ctx[17]);
			}

			if (dirty[0] & /*hovering, elements, draggingIndex*/ 196612) {
				toggle_class(li, "halfTransparent", /*hovering*/ ctx[16] !== /*index*/ ctx[43] && /*index*/ ctx[43] === /*draggingIndex*/ ctx[17]);
			}
		},
		r() {
			rect = li.getBoundingClientRect();
		},
		f() {
			fix_position(li);
			stop_animation();
		},
		a() {
			stop_animation();
			stop_animation = create_animation(li, rect, flip, { duration: 200 });
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (155:4) {#if addButton}
function create_if_block$8(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				style: "margin-top: 6px;",
				icon: "plus",
				disabled: /*disabled*/ ctx[1],
				label: " " + RED._("editableList.add"),
				small: true
			}
		});

	button.$on("click", /*addHandler*/ ctx[24]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*disabled*/ 2) button_changes.disabled = /*disabled*/ ctx[1];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (115:0) <Row id="sir-EditableList-{id}" clazz="{clazz} sir-EditableList" {inline} {indented} {maximize} fading={fadeDuration} {style}>
function create_default_slot$6(ctx) {
	let div0;
	let t0;
	let t1;
	let div2;
	let div1;
	let ol;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div1_style_value;
	let t2;
	let current;
	let if_block0 = /*label*/ ctx[7] && create_if_block_3$4(ctx);
	const header_slot_template = /*#slots*/ ctx[29].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[39], get_header_slot_context$1);
	let each_value = /*elements*/ ctx[2];

	const get_key = ctx => typeof /*element*/ ctx[41] === 'object'
	? /*element*/ ctx[41].id || /*element*/ ctx[41]
	: /*index*/ ctx[43];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	let if_block1 = /*addButton*/ ctx[0] && create_if_block$8(ctx);

	return {
		c() {
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (header_slot) header_slot.c();
			t1 = space();
			div2 = element("div");
			div1 = element("div");
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block1) if_block1.c();
			attr(div0, "class", "header svelte-ivm6tt");
			attr(ol, "id", /*nodeInputId*/ ctx[19]);
			attr(ol, "class", "red-ui-editableList-list sir-EditableList-list");
			attr(ol, "style", /*style*/ ctx[13]);
			toggle_class(ol, "ui-sortable", /*sortable*/ ctx[12]);
			attr(div1, "class", "red-ui-editableList-border red-ui-editableList-container");
			attr(div1, "style", div1_style_value = `${/*style*/ ctx[13]} min-height: ${/*minHeight*/ ctx[10]}; height: ${/*height*/ ctx[3]}; max-height: ${/*maxHeight*/ ctx[8]}`);
			attr(div2, "class", "red-ui-editableList");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);

			if (header_slot) {
				header_slot.m(div0, null);
			}

			insert(target, t1, anchor);
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, ol);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			append(div2, t2);
			if (if_block1) if_block1.m(div2, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$4(ctx);
					if_block0.c();
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*elements*/ 4 | dirty[1] & /*$$scope*/ 256)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[39],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[39])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[39], dirty, get_header_slot_changes$1),
						get_header_slot_context$1
					);
				}
			}

			if (dirty[0] & /*elements, isDraggable, sortable, removable, hovering, draggingIndex, dragstart, drop, dragenter, disabled, removeHandler*/ 48699398 | dirty[1] & /*$$scope*/ 256) {
				each_value = /*elements*/ ctx[2];
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ol, fix_and_outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}

			if (!current || dirty[0] & /*style*/ 8192) {
				attr(ol, "style", /*style*/ ctx[13]);
			}

			if (dirty[0] & /*sortable*/ 4096) {
				toggle_class(ol, "ui-sortable", /*sortable*/ ctx[12]);
			}

			if (!current || dirty[0] & /*style, minHeight, height, maxHeight*/ 9480 && div1_style_value !== (div1_style_value = `${/*style*/ ctx[13]} min-height: ${/*minHeight*/ ctx[10]}; height: ${/*height*/ ctx[3]}; max-height: ${/*maxHeight*/ ctx[8]}`)) {
				attr(div1, "style", div1_style_value);
			}

			if (/*addButton*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*addButton*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$8(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (if_block0) if_block0.d();
			if (header_slot) header_slot.d(detaching);
			if (detaching) detach(t1);
			if (detaching) detach(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block1) if_block1.d();
		}
	};
}

function create_fragment$9(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-EditableList-" + /*id*/ ctx[4],
				clazz: "" + (/*clazz*/ ctx[14] + " sir-EditableList"),
				inline: /*inline*/ ctx[6],
				indented: /*indented*/ ctx[5],
				maximize: /*maximize*/ ctx[9],
				fading: /*fadeDuration*/ ctx[20],
				style: /*style*/ ctx[13],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 16) row_changes.id = "sir-EditableList-" + /*id*/ ctx[4];
			if (dirty[0] & /*clazz*/ 16384) row_changes.clazz = "" + (/*clazz*/ ctx[14] + " sir-EditableList");
			if (dirty[0] & /*inline*/ 64) row_changes.inline = /*inline*/ ctx[6];
			if (dirty[0] & /*indented*/ 32) row_changes.indented = /*indented*/ ctx[5];
			if (dirty[0] & /*maximize*/ 512) row_changes.maximize = /*maximize*/ ctx[9];
			if (dirty[0] & /*style*/ 8192) row_changes.style = /*style*/ ctx[13];

			if (dirty[0] & /*disabled, addButton, style, minHeight, height, maxHeight, sortable, elements, isDraggable, removable, hovering, draggingIndex, label, icon*/ 507279 | dirty[1] & /*$$scope*/ 256) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { addButton = false, clazz = "", disabled = false, elements, fading = true, height = 'auto', i18n, icon, id, indented = false, inline = false, label = '', maxHeight = 300, maximize = false, minHeight = 100, node, removable = false, sortable = false, style = '' } = $$props;
	id = id || getId();
	addButton = getBooleanFrom(addButton);
	sortable = getBooleanFrom(sortable);
	removable = getBooleanFrom(removable);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);
	if (style && !style.endsWith(";")) style = style + ";";
	if (label) label = i18nTranslate(RED, node, i18n, label);
	const nodeInputId = "node-input-" + id + "-container";
	const fadeDuration = getFadeDuration(fading);

	// note: if height is set, min and max height have no effect
	if (!isNaN(height)) height += "px";

	if (!isNaN(minHeight)) minHeight += "px";
	if (!isNaN(maxHeight)) maxHeight += "px";
	const dispatch = createEventDispatcher();

	// sorting mechanism
	let hovering = false;

	let draggingIndex = null;
	let isDraggable = false;

	const drop = (e, target) => {
		e.dataTransfer.dropEffect = 'move';
		const start = parseInt(e.dataTransfer.getData("text/plain"));
		const newTracklist = [...elements];

		if (start < target) {
			newTracklist.splice(target + 1, 0, newTracklist[start]);
			newTracklist.splice(start, 1);
		} else {
			newTracklist.splice(target, 0, newTracklist[start]);
			newTracklist.splice(start + 1, 1);
		}

		$$invalidate(2, elements = newTracklist);
		$$invalidate(16, hovering = null);
		$$invalidate(17, draggingIndex = null);
	};

	const dragstart = (e, i) => {
		$$invalidate(17, draggingIndex = i);
		e.dataTransfer.effectAllowed = 'move';
		e.dataTransfer.dropEffect = 'move';
		const start = i;
		e.dataTransfer.setData('text/plain', start);
	};

	const dragenter = i => $$invalidate(16, hovering = i);

	// add / remove content
	const addHandler = () => dispatch('add', { index: elements.length });

	const removeHandler = index => {
		const removed = elements[index];
		$$invalidate(2, elements = [...elements.slice(0, index), ...elements.slice(index + 1)]);
		dispatch('remove', { removed });
	};

	function dragover_handler(event) {
		bubble.call(this, $$self, event);
	}

	const mouseover_handler = () => $$invalidate(18, isDraggable = true);
	const focus_handler = () => $$invalidate(18, isDraggable = true);
	const mouseout_handler = () => $$invalidate(18, isDraggable = false);
	const blur_handler = () => $$invalidate(18, isDraggable = false);
	const click_handler = index => removeHandler(index);
	const dragstart_handler = (index, e) => dragstart(e, index);
	const drop_handler = (index, e) => drop(e, index);
	const dragenter_handler = index => dragenter(index);

	$$self.$$set = $$props => {
		if ('addButton' in $$props) $$invalidate(0, addButton = $$props.addButton);
		if ('clazz' in $$props) $$invalidate(14, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('elements' in $$props) $$invalidate(2, elements = $$props.elements);
		if ('fading' in $$props) $$invalidate(26, fading = $$props.fading);
		if ('height' in $$props) $$invalidate(3, height = $$props.height);
		if ('i18n' in $$props) $$invalidate(27, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(15, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(6, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('maxHeight' in $$props) $$invalidate(8, maxHeight = $$props.maxHeight);
		if ('maximize' in $$props) $$invalidate(9, maximize = $$props.maximize);
		if ('minHeight' in $$props) $$invalidate(10, minHeight = $$props.minHeight);
		if ('node' in $$props) $$invalidate(28, node = $$props.node);
		if ('removable' in $$props) $$invalidate(11, removable = $$props.removable);
		if ('sortable' in $$props) $$invalidate(12, sortable = $$props.sortable);
		if ('style' in $$props) $$invalidate(13, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(39, $$scope = $$props.$$scope);
	};

	return [
		addButton,
		disabled,
		elements,
		height,
		id,
		indented,
		inline,
		label,
		maxHeight,
		maximize,
		minHeight,
		removable,
		sortable,
		style,
		clazz,
		icon,
		hovering,
		draggingIndex,
		isDraggable,
		nodeInputId,
		fadeDuration,
		drop,
		dragstart,
		dragenter,
		addHandler,
		removeHandler,
		fading,
		i18n,
		node,
		slots,
		dragover_handler,
		mouseover_handler,
		focus_handler,
		mouseout_handler,
		blur_handler,
		click_handler,
		dragstart_handler,
		drop_handler,
		dragenter_handler,
		$$scope
	];
}

class EditableList extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				addButton: 0,
				clazz: 14,
				disabled: 1,
				elements: 2,
				fading: 26,
				height: 3,
				i18n: 27,
				icon: 15,
				id: 4,
				indented: 5,
				inline: 6,
				label: 7,
				maxHeight: 8,
				maximize: 9,
				minHeight: 10,
				node: 28,
				removable: 11,
				sortable: 12,
				style: 13
			},
			add_css$8,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Group.svelte generated by Svelte v3.43.0 */

function add_css$7(target) {
	append_styles(target, "svelte-1x578qw", ".sir-Group-container.svelte-1x578qw{padding:12px}[id^='sir-Group-'].sir-Row.sir-Group, [id^='sir-Group-'].sir-Group{flex-direction:column;align-items:stretch}.header.svelte-1x578qw{margin-bottom:5px;display:inline-flex;align-items:center;justify-content:space-between;width:100%}label.svelte-1x578qw{cursor:initial }[id^='sir-Group-'].sir-Group-container div:last-child{margin-bottom:0px}.maximize.svelte-1x578qw{width:100%}");
}

const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (41:4) {#if label}
function create_if_block$7(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let if_block = /*icon*/ ctx[5] && create_if_block_1$6(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", label_1_for_value = "sir-Group-" + /*id*/ ctx[7] + "-container");
			set_style(label_1, "width", "auto");
			attr(label_1, "class", "svelte-1x578qw");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);

			if (dirty & /*id*/ 128 && label_1_for_value !== (label_1_for_value = "sir-Group-" + /*id*/ ctx[7] + "-container")) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (43:8) {#if icon}
function create_if_block_1$6(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[5] + " svelte-1x578qw");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 32 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[5] + " svelte-1x578qw")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (39:0) <Row id="sir-Group-{id}" clazz="{clazz} sir-Group" {inline} {fading}>
function create_default_slot$5(ctx) {
	let div0;
	let t0;
	let t1;
	let div1;
	let div1_id_value;
	let current;
	let if_block = /*label*/ ctx[1] && create_if_block$7(ctx);
	const header_slot_template = /*#slots*/ ctx[10].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[11], get_header_slot_context);
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			div0 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			if (header_slot) header_slot.c();
			t1 = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "header svelte-1x578qw");
			attr(div1, "id", div1_id_value = "sir-Group-" + /*id*/ ctx[7] + "-container");
			attr(div1, "class", "red-ui-editableList-border sir-Group-container svelte-1x578qw");
			attr(div1, "style", /*style*/ ctx[6]);
			toggle_class(div1, "maximize", /*maximize*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			if (if_block) if_block.m(div0, null);
			append(div0, t0);

			if (header_slot) {
				header_slot.m(div0, null);
			}

			insert(target, t1, anchor);
			insert(target, div1, anchor);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(div0, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[11], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 128 && div1_id_value !== (div1_id_value = "sir-Group-" + /*id*/ ctx[7] + "-container")) {
				attr(div1, "id", div1_id_value);
			}

			if (!current || dirty & /*style*/ 64) {
				attr(div1, "style", /*style*/ ctx[6]);
			}

			if (dirty & /*maximize*/ 4) {
				toggle_class(div1, "maximize", /*maximize*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (if_block) if_block.d();
			if (header_slot) header_slot.d(detaching);
			if (detaching) detach(t1);
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$8(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Group-" + /*id*/ ctx[7],
				clazz: "" + (/*clazz*/ ctx[3] + " sir-Group"),
				inline: /*inline*/ ctx[0],
				fading: /*fading*/ ctx[4],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 128) row_changes.id = "sir-Group-" + /*id*/ ctx[7];
			if (dirty & /*clazz*/ 8) row_changes.clazz = "" + (/*clazz*/ ctx[3] + " sir-Group");
			if (dirty & /*inline*/ 1) row_changes.inline = /*inline*/ ctx[0];
			if (dirty & /*fading*/ 16) row_changes.fading = /*fading*/ ctx[4];

			if (dirty & /*$$scope, id, style, maximize, label, icon*/ 2278) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', fading = true, i18n, icon, inline = false, label, maximize = false, node, style = '' } = $$props;
	let { id = getId() } = $$props;
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(3, clazz = $$props.clazz);
		if ('fading' in $$props) $$invalidate(4, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(8, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(5, icon = $$props.icon);
		if ('inline' in $$props) $$invalidate(0, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(2, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(9, node = $$props.node);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('id' in $$props) $$invalidate(7, id = $$props.id);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	return [
		inline,
		label,
		maximize,
		clazz,
		fading,
		icon,
		style,
		id,
		i18n,
		node,
		slots,
		$$scope
	];
}

class Group extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				clazz: 3,
				fading: 4,
				i18n: 8,
				icon: 5,
				inline: 0,
				label: 1,
				maximize: 2,
				node: 9,
				style: 6,
				id: 7
			},
			add_css$7
		);
	}
}

/* node_modules/svelte-integration-red/components/PlainInput.svelte generated by Svelte v3.43.0 */

function add_css$6(target) {
	append_styles(target, "svelte-1idal5v", ".maximize.svelte-1idal5v{width:100%}.label.svelte-1idal5v{min-width:100px;margin-bottom:5px}");
}

// (110:0) {:else}
function create_else_block_1$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (78:0) {#if !updateNode || prop}
function create_if_block$6(ctx) {
	let t;
	let if_block1_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[7] !== 'checkbox' && /*label*/ ctx[0] || /*type*/ ctx[7] === 'checkbox' && /*label*/ ctx[0] && /*labelBeforeCheckbox*/ ctx[6]) return create_if_block_10$1;
		if (/*indented*/ ctx[5]) return create_if_block_12$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[7] === 'text') return create_if_block_1$5;
		if (/*type*/ ctx[7] === 'number') return create_if_block_2$3;
		if (/*type*/ ctx[7] === 'password') return create_if_block_3$3;
		if (/*type*/ ctx[7] === 'email') return create_if_block_4$3;
		if (/*type*/ ctx[7] === 'url') return create_if_block_5$3;
		if (/*type*/ ctx[7] === 'color') return create_if_block_6$1;
		if (/*type*/ ctx[7] === 'checkbox') return create_if_block_7$1;
		return create_else_block$5;
	}

	let current_block_type_1 = select_block_type_2(ctx);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},
		d(detaching) {
			if (if_block0) {
				if_block0.d(detaching);
			}

			if (detaching) detach(t);
			if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (83:21) 
function create_if_block_12$1(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (79:2) {#if (type !== 'checkbox' && label) || (type === 'checkbox' && label && labelBeforeCheckbox)}
function create_if_block_10$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_11$1(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[0]);
			attr(label_1, "for", /*inputId*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[35]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[36])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11$1(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (81:6) {#if icon}
function create_if_block_11$1(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (107:2) {:else}
function create_else_block$5(ctx) {
	let span;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text("Error: Unsupported property type '");
			t1 = text(/*type*/ ctx[7]);
			t2 = text("'.");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*type*/ 128) set_data(t1, /*type*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (100:32) 
function create_if_block_7$1(ctx) {
	let div;
	let input;
	let t;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[0] && !/*labelBeforeCheckbox*/ ctx[6] && create_if_block_8$1(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "checkbox");
			attr(input, "id", /*inputId*/ ctx[12]);
			input.disabled = /*disabled*/ ctx[3];
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			attr(div, "class", "checkbox");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			input.checked = /*value*/ ctx[2];
			append(div, t);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_7*/ ctx[33]),
					listen(input, "mouseleave", /*mouseleave_handler_7*/ ctx[34]),
					listen(input, "change", /*input_change_handler*/ ctx[44])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4) {
				input.checked = /*value*/ ctx[2];
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}

			if (/*label*/ ctx[0] && !/*labelBeforeCheckbox*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_8$1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:29) 
function create_if_block_6$1(ctx) {
	let input0;
	let t;
	let input1;
	let mounted;
	let dispose;

	return {
		c() {
			input0 = element("input");
			t = space();
			input1 = element("input");
			input0.disabled = /*disabled*/ ctx[3];
			set_style(input0, "max-width", "30px");
			attr(input0, "type", "color");
			toggle_class(input0, "input-error", !/*isValid*/ ctx[10]);
			attr(input1, "id", /*inputId*/ ctx[12]);
			attr(input1, "placeholder", /*placeholder*/ ctx[1]);
			input1.disabled = /*disabled*/ ctx[3];
			attr(input1, "type", "text");
			attr(input1, "class", "svelte-1idal5v");
			toggle_class(input1, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input1, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input0, anchor);
			set_input_value(input0, /*value*/ ctx[2]);
			insert(target, t, anchor);
			insert(target, input1, anchor);
			set_input_value(input1, /*value*/ ctx[2]);

			if (!mounted) {
				dispose = [
					listen(input0, "input", /*input0_input_handler*/ ctx[42]),
					listen(input1, "mouseenter", /*mouseenter_handler_6*/ ctx[29]),
					listen(input1, "mouseleave", /*mouseleave_handler_6*/ ctx[30]),
					listen(input1, "input", /*input1_input_handler*/ ctx[43])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 8) {
				input0.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4) {
				set_input_value(input0, /*value*/ ctx[2]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input0, "input-error", !/*isValid*/ ctx[10]);
			}

			if (dirty[0] & /*placeholder*/ 2) {
				attr(input1, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input1.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4 && input1.value !== /*value*/ ctx[2]) {
				set_input_value(input1, /*value*/ ctx[2]);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input1, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input1, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input0);
			if (detaching) detach(t);
			if (detaching) detach(input1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (95:27) 
function create_if_block_5$3(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "url");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[2]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_5*/ ctx[27]),
					listen(input, "mouseleave", /*mouseleave_handler_5*/ ctx[28]),
					listen(input, "input", /*input_input_handler_4*/ ctx[41])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4) {
				set_input_value(input, /*value*/ ctx[2]);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (93:29) 
function create_if_block_4$3(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "email");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[2]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_4*/ ctx[25]),
					listen(input, "mouseleave", /*mouseleave_handler_4*/ ctx[26]),
					listen(input, "input", /*input_input_handler_3*/ ctx[40])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4 && input.value !== /*value*/ ctx[2]) {
				set_input_value(input, /*value*/ ctx[2]);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (91:32) 
function create_if_block_3$3(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "password");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[2]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_3*/ ctx[23]),
					listen(input, "mouseleave", /*mouseleave_handler_3*/ ctx[24]),
					listen(input, "input", /*input_input_handler_2*/ ctx[39])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4 && input.value !== /*value*/ ctx[2]) {
				set_input_value(input, /*value*/ ctx[2]);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (89:30) 
function create_if_block_2$3(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "number");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[2]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_2*/ ctx[21]),
					listen(input, "mouseleave", /*mouseleave_handler_2*/ ctx[22]),
					listen(input, "input", /*input_input_handler_1*/ ctx[38])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4 && to_number(input.value) !== /*value*/ ctx[2]) {
				set_input_value(input, /*value*/ ctx[2]);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (87:2) {#if type === 'text'}
function create_if_block_1$5(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[3];
			attr(input, "type", "text");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[2]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_1*/ ctx[19]),
					listen(input, "mouseleave", /*mouseleave_handler_1*/ ctx[20]),
					listen(input, "input", /*input_input_handler*/ ctx[37])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (dirty[0] & /*value*/ 4 && input.value !== /*value*/ ctx[2]) {
				set_input_value(input, /*value*/ ctx[2]);
			}

			if (dirty[0] & /*maximize*/ 256) {
				toggle_class(input, "maximize", /*maximize*/ ctx[8]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (103:8) {#if label && !labelBeforeCheckbox}
function create_if_block_8$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_9$1(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[0]);
			attr(label_1, "for", /*inputId*/ ctx[12]);
			set_style(label_1, "width", "100%");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler_8*/ ctx[31]),
					listen(label_1, "mouseleave", /*mouseleave_handler_8*/ ctx[32])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_9$1(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (104:79) {#if icon}
function create_if_block_9$1(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$7(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*updateNode*/ ctx[11] || /*prop*/ ctx[9]) return create_if_block$6;
		return create_else_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { credentials = false, disabled = false, i18n, icon, id, indented = false, label, labelBeforeCheckbox = false, maximize, node, placeholder, prop, type, value } = $$props;
	id = id || getId(prop);
	credentials = getBooleanFrom(credentials);
	indented = getBooleanFrom(indented);
	disabled = getBooleanFrom(disabled);
	labelBeforeCheckbox = getBooleanFrom(labelBeforeCheckbox);
	let defaults;

	if (!node) {
		defaults = {};
	} else {
		defaults = credentials ? node._def.credentials : node._def.defaults;
	}

	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	value = updateNode && node[prop] || value;
	let isValid = true;
	let init = true;
	icon = icon || defaults?.[prop]?.icon || '';

	if (label !== false) {
		label = label || defaults?.[prop]?.label || prop || '';
	}

	placeholder = placeholder || defaults?.[prop]?.placeholder || '';

	if (!type) {
		let testValue = defaults[prop] ? defaults[prop].value : value;

		if (typeof testValue === 'number') {
			type = 'number';
		} else if (typeof testValue === 'boolean') {
			type = 'checkbox';
		} else {
			type = 'text';
		}
	}

	let inputId = 'node-input-' + id;

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_8(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_8(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(2, value);
	}

	function input_input_handler_1() {
		value = to_number(this.value);
		$$invalidate(2, value);
	}

	function input_input_handler_2() {
		value = this.value;
		$$invalidate(2, value);
	}

	function input_input_handler_3() {
		value = this.value;
		$$invalidate(2, value);
	}

	function input_input_handler_4() {
		value = this.value;
		$$invalidate(2, value);
	}

	function input0_input_handler() {
		value = this.value;
		$$invalidate(2, value);
	}

	function input1_input_handler() {
		value = this.value;
		$$invalidate(2, value);
	}

	function input_change_handler() {
		value = this.checked;
		$$invalidate(2, value);
	}

	$$self.$$set = $$props => {
		if ('credentials' in $$props) $$invalidate(15, credentials = $$props.credentials);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('i18n' in $$props) $$invalidate(16, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(13, id = $$props.id);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('labelBeforeCheckbox' in $$props) $$invalidate(6, labelBeforeCheckbox = $$props.labelBeforeCheckbox);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(14, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(9, prop = $$props.prop);
		if ('type' in $$props) $$invalidate(7, type = $$props.type);
		if ('value' in $$props) $$invalidate(2, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*defaults, prop, value, init, id*/ 401924) {
			{
				if (defaults?.[prop]?.validate) {
					$$invalidate(10, isValid = defaults?.[prop]?.validate(value));
				}

				if (updateNode) {
					$$invalidate(14, node[prop] = value, node);
				}

				if (!init) {
					dispatch('change', { id, value });
				}

				$$invalidate(18, init = false);
			}
		}

		if ($$self.$$.dirty[0] & /*label, node, i18n*/ 81921) {
			{
				if (label) {
					$$invalidate(0, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*placeholder, node, i18n*/ 81922) {
			{
				if (placeholder) {
					$$invalidate(1, placeholder = i18nTranslate(RED, node, i18n, placeholder));
				}
			}
		}
	};

	return [
		label,
		placeholder,
		value,
		disabled,
		icon,
		indented,
		labelBeforeCheckbox,
		type,
		maximize,
		prop,
		isValid,
		updateNode,
		inputId,
		id,
		node,
		credentials,
		i18n,
		defaults,
		init,
		mouseenter_handler_1,
		mouseleave_handler_1,
		mouseenter_handler_2,
		mouseleave_handler_2,
		mouseenter_handler_3,
		mouseleave_handler_3,
		mouseenter_handler_4,
		mouseleave_handler_4,
		mouseenter_handler_5,
		mouseleave_handler_5,
		mouseenter_handler_6,
		mouseleave_handler_6,
		mouseenter_handler_8,
		mouseleave_handler_8,
		mouseenter_handler_7,
		mouseleave_handler_7,
		mouseenter_handler,
		mouseleave_handler,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input0_input_handler,
		input1_input_handler,
		input_change_handler
	];
}

class PlainInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				credentials: 15,
				disabled: 3,
				i18n: 16,
				icon: 4,
				id: 13,
				indented: 5,
				label: 0,
				labelBeforeCheckbox: 6,
				maximize: 8,
				node: 14,
				placeholder: 1,
				prop: 9,
				type: 7,
				value: 2
			},
			add_css$6,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/ConfigNodeInput.svelte generated by Svelte v3.43.0 */

function add_css$5(target) {
	append_styles(target, "svelte-1grox8e", ".disabled.svelte-1grox8e{pointer-events:none}.maximize.svelte-1grox8e{width:100%}");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].id;
	child_ctx[3] = list[i].label;
	return child_ctx;
}

// (103:0) {:else}
function create_else_block$4(ctx) {
	let span;
	let t0;
	let t1;

	return {
		c() {
			span = element("span");
			t0 = text("Error: ");
			t1 = text(/*error*/ ctx[8]);
			attr(span, "class", "maximize svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*error*/ 256) set_data(t1, /*error*/ ctx[8]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (93:0) {#if node && prop}
function create_if_block$5(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let t2;
	let select;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let select_id_value;
	let select_placeholder_value;
	let t3;
	let button;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[6] && create_if_block_1$4(ctx);
	let each_value = /*configNodes*/ ctx[9];
	const get_key = ctx => /*id*/ ctx[4];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	button = new Button({
			props: {
				id: "node-input-lookup-" + /*prop*/ ctx[5],
				inline: true,
				disabled: /*disabled*/ ctx[1],
				icon: "pencil"
			}
		});

	button.$on("click", /*editConfigNode*/ ctx[11]);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			create_component(button.$$.fragment);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*prop*/ ctx[5]);
			attr(select, "id", select_id_value = "node-input-" + /*prop*/ ctx[5]);
			attr(select, "placeholder", select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[5]].label);
			select.disabled = /*disabled*/ ctx[1];
			attr(select, "class", "svelte-1grox8e");
			if (/*selectedNode*/ ctx[7] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[16].call(select));
			toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			toggle_class(select, "maximize", /*maximize*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
			insert(target, t2, anchor);
			insert(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*selectedNode*/ ctx[7]);
			insert(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[16]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

			if (!current || dirty & /*prop*/ 32 && label_1_for_value !== (label_1_for_value = "node-input-" + /*prop*/ ctx[5])) {
				attr(label_1, "for", label_1_for_value);
			}

			if (dirty & /*configNodes*/ 512) {
				each_value = /*configNodes*/ ctx[9];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$2, null, get_each_context$2);
			}

			if (!current || dirty & /*prop*/ 32 && select_id_value !== (select_id_value = "node-input-" + /*prop*/ ctx[5])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*prop*/ 32 && select_placeholder_value !== (select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[5]].label)) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (!current || dirty & /*disabled*/ 2) {
				select.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*selectedNode, configNodes*/ 640) {
				select_option(select, /*selectedNode*/ ctx[7]);
			}

			if (dirty & /*selectedNode*/ 128) {
				toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			}

			if (dirty & /*maximize*/ 4) {
				toggle_class(select, "maximize", /*maximize*/ ctx[2]);
			}

			const button_changes = {};
			if (dirty & /*prop*/ 32) button_changes.id = "node-input-lookup-" + /*prop*/ ctx[5];
			if (dirty & /*disabled*/ 2) button_changes.disabled = /*disabled*/ ctx[1];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			if (detaching) detach(t2);
			if (detaching) detach(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t3);
			destroy_component(button, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (94:33) {#if icon}
function create_if_block_1$4(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[6] + " svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 64 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[6] + " svelte-1grox8e")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (98:6) {#each configNodes as { id, label }
function create_each_block$2(key_1, ctx) {
	let option;
	let t_value = /*label*/ ctx[3] + "";
	let t;
	let option_value_value;

	return {
		key: key_1,
		first: null,
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*id*/ ctx[4];
			option.value = option.__value;
			this.first = option;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*configNodes*/ 512 && t_value !== (t_value = /*label*/ ctx[3] + "")) set_data(t, t_value);

			if (dirty & /*configNodes*/ 512 && option_value_value !== (option_value_value = /*id*/ ctx[4])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0] && /*prop*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { node, prop, icon, label, id, disabled = false, maximize = true, i18n } = $$props;
	id = id || getId(prop);
	let error = '';
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);

	if (!node) {
		node = {};
		error = "No node property given.";
	} else if (!prop) {
		error = "No property name given.";
	}

	const dispatch = createEventDispatcher();
	let defaults = node._def.defaults;
	label = label || defaults[prop] && defaults[prop].label || prop;
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let configNodes = [];
	let previouslySelectedNode = node[prop] || '_ADD_';
	let selectedNode = node[prop] || '_ADD_';

	function updateConfigNodes() {
		$$invalidate(9, configNodes = []);
		const type = defaults[prop].type;
		const node_def = RED.nodes.getType(type);

		RED.nodes.eachConfig(function (config) {
			if (config.type === type) {
				let label = '';

				if (typeof node_def.label === 'function') {
					label = node_def.label.call(config);
				} else {
					label = node_def.label;
				}

				configNodes.push({ id: config.id, label });
			}
		});

		$$invalidate(9, configNodes = [...configNodes, { id: '_ADD_', label: `Add new ${type}...` }]);
	}

	onMount(() => {
		updateConfigNodes();

		RED.events.on('nodes:add', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
				$$invalidate(7, selectedNode = e.id);
			}
		});

		RED.events.on('nodes:change', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
			}
		});

		RED.events.on('nodes:remove', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();

				// Always select '_ADD_' after deleting (standard behaviour)
				// otherwise it breaks the node if only one other option was available
				$$invalidate(7, selectedNode = '_ADD_');
			}
		});
	});

	function editConfigNode() {
		// The prefix is omitted so the select gets updated by us and not by Node-RED
		RED.editor.editConfig(prop, defaults[prop].type, selectedNode); /*, 'node-input' */
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		selectedNode = select_value(this);
		$$invalidate(7, selectedNode);
		$$invalidate(9, configNodes);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('prop' in $$props) $$invalidate(5, prop = $$props.prop);
		if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(2, maximize = $$props.maximize);
		if ('i18n' in $$props) $$invalidate(12, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selectedNode, previouslySelectedNode, prop*/ 8352) {
			{
				if (selectedNode !== previouslySelectedNode) {
					$$invalidate(0, node[prop] = selectedNode, node);

					dispatch('change', {
						before: previouslySelectedNode,
						after: selectedNode
					});

					$$invalidate(13, previouslySelectedNode = selectedNode);
				}
			}
		}
	};

	return [
		node,
		disabled,
		maximize,
		label,
		id,
		prop,
		icon,
		selectedNode,
		error,
		configNodes,
		defaults,
		editConfigNode,
		i18n,
		previouslySelectedNode,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler
	];
}

class ConfigNodeInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				node: 0,
				prop: 5,
				icon: 6,
				label: 3,
				id: 4,
				disabled: 1,
				maximize: 2,
				i18n: 12
			},
			add_css$5
		);
	}
}

/* node_modules/svelte-integration-red/components/Input.svelte generated by Svelte v3.43.0 */

function add_css$4(target) {
	append_styles(target, "svelte-p54s0v", ".sir-Input-Container{display:inline-flex;align-items:center;width:100%}");
}

// (43:2) {:else}
function create_else_block$3(ctx) {
	let plaininput;
	let updating_node;
	let updating_prop;
	let updating_icon;
	let updating_label;
	let updating_disabled;
	let updating_value;
	let updating_type;
	let updating_placeholder;
	let updating_maximize;
	let current;

	function plaininput_node_binding(value) {
		/*plaininput_node_binding*/ ctx[25](value);
	}

	function plaininput_prop_binding(value) {
		/*plaininput_prop_binding*/ ctx[26](value);
	}

	function plaininput_icon_binding(value) {
		/*plaininput_icon_binding*/ ctx[27](value);
	}

	function plaininput_label_binding(value) {
		/*plaininput_label_binding*/ ctx[28](value);
	}

	function plaininput_disabled_binding(value) {
		/*plaininput_disabled_binding*/ ctx[29](value);
	}

	function plaininput_value_binding(value) {
		/*plaininput_value_binding*/ ctx[30](value);
	}

	function plaininput_type_binding(value) {
		/*plaininput_type_binding*/ ctx[31](value);
	}

	function plaininput_placeholder_binding(value) {
		/*plaininput_placeholder_binding*/ ctx[32](value);
	}

	function plaininput_maximize_binding(value) {
		/*plaininput_maximize_binding*/ ctx[33](value);
	}

	let plaininput_props = {
		i18n: /*i18n*/ ctx[15],
		indented: /*indented*/ ctx[5],
		credentials: /*credentials*/ ctx[13],
		id: /*id*/ ctx[4]
	};

	if (/*node*/ ctx[9] !== void 0) {
		plaininput_props.node = /*node*/ ctx[9];
	}

	if (/*prop*/ ctx[11] !== void 0) {
		plaininput_props.prop = /*prop*/ ctx[11];
	}

	if (/*icon*/ ctx[3] !== void 0) {
		plaininput_props.icon = /*icon*/ ctx[3];
	}

	if (/*label*/ ctx[7] !== void 0) {
		plaininput_props.label = /*label*/ ctx[7];
	}

	if (/*disabled*/ ctx[2] !== void 0) {
		plaininput_props.disabled = /*disabled*/ ctx[2];
	}

	if (/*value*/ ctx[1] !== void 0) {
		plaininput_props.value = /*value*/ ctx[1];
	}

	if (/*type*/ ctx[0] !== void 0) {
		plaininput_props.type = /*type*/ ctx[0];
	}

	if (/*placeholder*/ ctx[10] !== void 0) {
		plaininput_props.placeholder = /*placeholder*/ ctx[10];
	}

	if (/*maximize*/ ctx[8] !== void 0) {
		plaininput_props.maximize = /*maximize*/ ctx[8];
	}

	plaininput = new PlainInput({ props: plaininput_props });
	binding_callbacks.push(() => bind(plaininput, 'node', plaininput_node_binding));
	binding_callbacks.push(() => bind(plaininput, 'prop', plaininput_prop_binding));
	binding_callbacks.push(() => bind(plaininput, 'icon', plaininput_icon_binding));
	binding_callbacks.push(() => bind(plaininput, 'label', plaininput_label_binding));
	binding_callbacks.push(() => bind(plaininput, 'disabled', plaininput_disabled_binding));
	binding_callbacks.push(() => bind(plaininput, 'value', plaininput_value_binding));
	binding_callbacks.push(() => bind(plaininput, 'type', plaininput_type_binding));
	binding_callbacks.push(() => bind(plaininput, 'placeholder', plaininput_placeholder_binding));
	binding_callbacks.push(() => bind(plaininput, 'maximize', plaininput_maximize_binding));
	plaininput.$on("change", /*change_handler_1*/ ctx[34]);
	plaininput.$on("mouseenter", /*mouseenter_handler_1*/ ctx[35]);
	plaininput.$on("mouseleave", /*mouseleave_handler_1*/ ctx[36]);

	return {
		c() {
			create_component(plaininput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaininput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaininput_changes = {};
			if (dirty[0] & /*i18n*/ 32768) plaininput_changes.i18n = /*i18n*/ ctx[15];
			if (dirty[0] & /*indented*/ 32) plaininput_changes.indented = /*indented*/ ctx[5];
			if (dirty[0] & /*credentials*/ 8192) plaininput_changes.credentials = /*credentials*/ ctx[13];
			if (dirty[0] & /*id*/ 16) plaininput_changes.id = /*id*/ ctx[4];

			if (!updating_node && dirty[0] & /*node*/ 512) {
				updating_node = true;
				plaininput_changes.node = /*node*/ ctx[9];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 2048) {
				updating_prop = true;
				plaininput_changes.prop = /*prop*/ ctx[11];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_icon && dirty[0] & /*icon*/ 8) {
				updating_icon = true;
				plaininput_changes.icon = /*icon*/ ctx[3];
				add_flush_callback(() => updating_icon = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 128) {
				updating_label = true;
				plaininput_changes.label = /*label*/ ctx[7];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 4) {
				updating_disabled = true;
				plaininput_changes.disabled = /*disabled*/ ctx[2];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 2) {
				updating_value = true;
				plaininput_changes.value = /*value*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty[0] & /*type*/ 1) {
				updating_type = true;
				plaininput_changes.type = /*type*/ ctx[0];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_placeholder && dirty[0] & /*placeholder*/ 1024) {
				updating_placeholder = true;
				plaininput_changes.placeholder = /*placeholder*/ ctx[10];
				add_flush_callback(() => updating_placeholder = false);
			}

			if (!updating_maximize && dirty[0] & /*maximize*/ 256) {
				updating_maximize = true;
				plaininput_changes.maximize = /*maximize*/ ctx[8];
				add_flush_callback(() => updating_maximize = false);
			}

			plaininput.$set(plaininput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaininput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaininput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaininput, detaching);
		}
	};
}

// (41:2) {#if type === 'config'}
function create_if_block$4(ctx) {
	let confignodeinput;
	let updating_node;
	let updating_prop;
	let updating_label;
	let updating_disabled;
	let current;

	function confignodeinput_node_binding(value) {
		/*confignodeinput_node_binding*/ ctx[18](value);
	}

	function confignodeinput_prop_binding(value) {
		/*confignodeinput_prop_binding*/ ctx[19](value);
	}

	function confignodeinput_label_binding(value) {
		/*confignodeinput_label_binding*/ ctx[20](value);
	}

	function confignodeinput_disabled_binding(value) {
		/*confignodeinput_disabled_binding*/ ctx[21](value);
	}

	let confignodeinput_props = {
		icon: /*icon*/ ctx[3],
		i18n: /*i18n*/ ctx[15],
		indented: /*indented*/ ctx[5]
	};

	if (/*node*/ ctx[9] !== void 0) {
		confignodeinput_props.node = /*node*/ ctx[9];
	}

	if (/*prop*/ ctx[11] !== void 0) {
		confignodeinput_props.prop = /*prop*/ ctx[11];
	}

	if (/*label*/ ctx[7] !== void 0) {
		confignodeinput_props.label = /*label*/ ctx[7];
	}

	if (/*disabled*/ ctx[2] !== void 0) {
		confignodeinput_props.disabled = /*disabled*/ ctx[2];
	}

	confignodeinput = new ConfigNodeInput({ props: confignodeinput_props });
	binding_callbacks.push(() => bind(confignodeinput, 'node', confignodeinput_node_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'prop', confignodeinput_prop_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'label', confignodeinput_label_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'disabled', confignodeinput_disabled_binding));
	confignodeinput.$on("change", /*change_handler*/ ctx[22]);
	confignodeinput.$on("mouseenter", /*mouseenter_handler*/ ctx[23]);
	confignodeinput.$on("mouseleave", /*mouseleave_handler*/ ctx[24]);

	return {
		c() {
			create_component(confignodeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(confignodeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const confignodeinput_changes = {};
			if (dirty[0] & /*icon*/ 8) confignodeinput_changes.icon = /*icon*/ ctx[3];
			if (dirty[0] & /*i18n*/ 32768) confignodeinput_changes.i18n = /*i18n*/ ctx[15];
			if (dirty[0] & /*indented*/ 32) confignodeinput_changes.indented = /*indented*/ ctx[5];

			if (!updating_node && dirty[0] & /*node*/ 512) {
				updating_node = true;
				confignodeinput_changes.node = /*node*/ ctx[9];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 2048) {
				updating_prop = true;
				confignodeinput_changes.prop = /*prop*/ ctx[11];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 128) {
				updating_label = true;
				confignodeinput_changes.label = /*label*/ ctx[7];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 4) {
				updating_disabled = true;
				confignodeinput_changes.disabled = /*disabled*/ ctx[2];
				add_flush_callback(() => updating_disabled = false);
			}

			confignodeinput.$set(confignodeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(confignodeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(confignodeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(confignodeinput, detaching);
		}
	};
}

// (40:0) <Row id="sir-Input-Container-{id}" clazz="{clazz} sir-Input-Container" {inline} {maximize} {fading} {style}>
function create_default_slot$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[0] === 'config') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$5(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Input-Container-" + /*id*/ ctx[4],
				clazz: "" + (/*clazz*/ ctx[12] + " sir-Input-Container"),
				inline: /*inline*/ ctx[6],
				maximize: /*maximize*/ ctx[8],
				fading: /*fading*/ ctx[14],
				style: /*style*/ ctx[16],
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 16) row_changes.id = "sir-Input-Container-" + /*id*/ ctx[4];
			if (dirty[0] & /*clazz*/ 4096) row_changes.clazz = "" + (/*clazz*/ ctx[12] + " sir-Input-Container");
			if (dirty[0] & /*inline*/ 64) row_changes.inline = /*inline*/ ctx[6];
			if (dirty[0] & /*maximize*/ 256) row_changes.maximize = /*maximize*/ ctx[8];
			if (dirty[0] & /*fading*/ 16384) row_changes.fading = /*fading*/ ctx[14];
			if (dirty[0] & /*style*/ 65536) row_changes.style = /*style*/ ctx[16];

			if (dirty[0] & /*icon, i18n, indented, node, prop, label, disabled, type, credentials, id, value, placeholder, maximize*/ 44991 | dirty[1] & /*$$scope*/ 64) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { checked, clazz = '', credentials, disabled = false, fading = true, i18n, icon, id, indented = false, inline = false, label, maximize = true, node, placeholder, prop, style = '', type, value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);

	// loading node: if only node is bound for any input field in the svelte code, value would be undefined if the input field is empty or false
	if (type !== 'checkbox' && typeof value === 'undefined' && typeof node?.[prop] !== 'undefined') {
		value = node[prop];
	} else if (type === 'checkbox' && typeof value === 'undefined') {
		// special case for checkbox: bind:checked (offical property) could also be used and has prio before getting it possibly from node[prop]
		if (typeof checked !== 'undefined') {
			value = getBooleanFrom(checked);
		} else if (typeof node?.[prop] !== 'undefined') {
			value = getBooleanFrom(node[prop]);
		}
	}

	function confignodeinput_node_binding(value) {
		node = value;
		$$invalidate(9, node);
	}

	function confignodeinput_prop_binding(value) {
		prop = value;
		$$invalidate(11, prop);
	}

	function confignodeinput_label_binding(value) {
		label = value;
		$$invalidate(7, label);
	}

	function confignodeinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(2, disabled);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function plaininput_node_binding(value) {
		node = value;
		$$invalidate(9, node);
	}

	function plaininput_prop_binding(value) {
		prop = value;
		$$invalidate(11, prop);
	}

	function plaininput_icon_binding(value) {
		icon = value;
		$$invalidate(3, icon);
	}

	function plaininput_label_binding(value) {
		label = value;
		$$invalidate(7, label);
	}

	function plaininput_disabled_binding(value) {
		disabled = value;
		$$invalidate(2, disabled);
	}

	function plaininput_value_binding(value$1) {
		value = value$1;
		$$invalidate(1, value);
	}

	function plaininput_type_binding(value) {
		type = value;
		$$invalidate(0, type);
	}

	function plaininput_placeholder_binding(value) {
		placeholder = value;
		$$invalidate(10, placeholder);
	}

	function plaininput_maximize_binding(value) {
		maximize = value;
		$$invalidate(8, maximize);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('checked' in $$props) $$invalidate(17, checked = $$props.checked);
		if ('clazz' in $$props) $$invalidate(12, clazz = $$props.clazz);
		if ('credentials' in $$props) $$invalidate(13, credentials = $$props.credentials);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(14, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(15, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(6, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(9, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(10, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(11, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(16, style = $$props.style);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*type, checked, value*/ 131075) {
			// if checkbox has checked bound it must be updated with the value property (needed)
			if (type === 'checkbox' && typeof checked !== 'undefined' && typeof value !== 'undefined') {
				$$invalidate(17, checked = getBooleanFrom(value));
			}
		}
	};

	return [
		type,
		value,
		disabled,
		icon,
		id,
		indented,
		inline,
		label,
		maximize,
		node,
		placeholder,
		prop,
		clazz,
		credentials,
		fading,
		i18n,
		style,
		checked,
		confignodeinput_node_binding,
		confignodeinput_prop_binding,
		confignodeinput_label_binding,
		confignodeinput_disabled_binding,
		change_handler,
		mouseenter_handler,
		mouseleave_handler,
		plaininput_node_binding,
		plaininput_prop_binding,
		plaininput_icon_binding,
		plaininput_label_binding,
		plaininput_disabled_binding,
		plaininput_value_binding,
		plaininput_type_binding,
		plaininput_placeholder_binding,
		plaininput_maximize_binding,
		change_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				checked: 17,
				clazz: 12,
				credentials: 13,
				disabled: 2,
				fading: 14,
				i18n: 15,
				icon: 3,
				id: 4,
				indented: 5,
				inline: 6,
				label: 7,
				maximize: 8,
				node: 9,
				placeholder: 10,
				prop: 11,
				style: 16,
				type: 0,
				value: 1
			},
			add_css$4,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Select.svelte generated by Svelte v3.43.0 */

function add_css$3(target) {
	append_styles(target, "svelte-1m0uqs8", ".disabled.svelte-1m0uqs8{pointer-events:none}.maximize.svelte-1m0uqs8{width:100%}.sir-Input-Container select, .sir-Select select{padding-left:3px}.sir-Select{display:inline-flex;width:100%;align-items:center}");
}

// (48:2) {#if label}
function create_if_block$3(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let if_block = /*icon*/ ctx[9] && create_if_block_1$3(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[4]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[9]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 16) set_data(t1, /*label*/ ctx[4]);

			if (dirty & /*id*/ 4 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[2])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (49:33) {#if icon}
function create_if_block_1$3(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-1m0uqs8");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 512 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-1m0uqs8")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (47:0) <Row id="sir-Select-{id}-Container" clazz="{clazz} sir-Select" {inline} {style} {fading}>
function create_default_slot$3(ctx) {
	let t;
	let select;
	let select_id_value;
	let select_placeholder_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[4] && create_if_block$3(ctx);
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			select = element("select");
			if (default_slot) default_slot.c();
			attr(select, "id", select_id_value = "node-input-" + /*id*/ ctx[2]);
			select.disabled = /*disabled*/ ctx[1];
			attr(select, "placeholder", select_placeholder_value = /*node*/ ctx[6] && /*defaults*/ ctx[12][/*prop*/ ctx[10]].label || '');
			attr(select, "class", "svelte-1m0uqs8");
			if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[18].call(select));
			toggle_class(select, "maximize", /*maximize*/ ctx[5]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*value*/ ctx[0]);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[18]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[16]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 4 && select_id_value !== (select_id_value = "node-input-" + /*id*/ ctx[2])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*disabled*/ 2) {
				select.disabled = /*disabled*/ ctx[1];
			}

			if (!current || dirty & /*node, prop*/ 1088 && select_placeholder_value !== (select_placeholder_value = /*node*/ ctx[6] && /*defaults*/ ctx[12][/*prop*/ ctx[10]].label || '')) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (dirty & /*value*/ 1) {
				select_option(select, /*value*/ ctx[0]);
			}

			if (dirty & /*maximize*/ 32) {
				toggle_class(select, "maximize", /*maximize*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$4(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Select-" + /*id*/ ctx[2] + "-Container",
				clazz: "" + (/*clazz*/ ctx[7] + " sir-Select"),
				inline: /*inline*/ ctx[3],
				style: /*style*/ ctx[11],
				fading: /*fading*/ ctx[8],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 4) row_changes.id = "sir-Select-" + /*id*/ ctx[2] + "-Container";
			if (dirty & /*clazz*/ 128) row_changes.clazz = "" + (/*clazz*/ ctx[7] + " sir-Select");
			if (dirty & /*inline*/ 8) row_changes.inline = /*inline*/ ctx[3];
			if (dirty & /*style*/ 2048) row_changes.style = /*style*/ ctx[11];
			if (dirty & /*fading*/ 256) row_changes.fading = /*fading*/ ctx[8];

			if (dirty & /*$$scope, id, disabled, node, prop, value, maximize, label, icon*/ 525943) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', disabled = false, fading = true, i18n, icon, id, inline = false, label, maximize = true, node, prop, style = "", value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	value = updateNode && node[prop] || value;
	let init = true;
	let defaults = node ? node._def.defaults : {};
	if (label !== false) label = label || node && (defaults[prop] && defaults[prop].label || prop);

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		value = select_value(this);
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(7, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(8, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(13, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(9, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('inline' in $$props) $$invalidate(3, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(6, node = $$props.node);
		if ('prop' in $$props) $$invalidate(10, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(11, style = $$props.style);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(19, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*prop, value, init*/ 17409) {
			{
				if (updateNode) {
					$$invalidate(6, node[prop] = value, node);
				}

				if (!init) {
					dispatch('change', { value });
				}

				$$invalidate(14, init = false);
			}
		}
	};

	return [
		value,
		disabled,
		id,
		inline,
		label,
		maximize,
		node,
		clazz,
		fading,
		icon,
		prop,
		style,
		defaults,
		i18n,
		init,
		slots,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler,
		$$scope
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$4,
			create_fragment$4,
			safe_not_equal,
			{
				clazz: 7,
				disabled: 1,
				fading: 8,
				i18n: 13,
				icon: 9,
				id: 2,
				inline: 3,
				label: 4,
				maximize: 5,
				node: 6,
				prop: 10,
				style: 11,
				value: 0
			},
			add_css$3
		);
	}
}

/* node_modules/svelte-integration-red/components/PlainTypedInput.svelte generated by Svelte v3.43.0 */

function add_css$2(target) {
	append_styles(target, "svelte-8s4igv", ".maximize.svelte-8s4igv{width:100%}.sir-Row :is(.red-ui-typedInput-container, .red-ui-typedInput-input-wrap){display:inline-flex;align-items:center}.sir-Row button:is(.red-ui-typedInput-type-select, .red-ui-typedInput-option-expand, .red-ui-typedInput-option-trigger){display:inline-flex;align-items:center;line-height:32px}.sir-Input-Container .red-ui-typedInput-type-select:not(.red-ui-typedInput-full-width){padding-right:3px}.sir-Input-Container .red-ui-typedInput-option-label{border-left-color:#ccc;border-left-width:1px;border-left-style:double}.sir-Input-Container .red-ui-typedInput-focus .red-ui-typedInput-option-label{border-left-color:#77abeb}.sir-Input-Container .input-error .red-ui-typedInput-option-label{border-left-color:#d6615f}.sir-Input-Container .red-ui-typedInput-option-label:hover{background-color:#e6e6e6}.sir-Input-Container button.red-ui-typedInput-option-trigger:focus .red-ui-typedInput-option-caret{box-shadow:none }");
}

// (108:0) {:else}
function create_else_block$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: Neither property nor type property name given.";
			attr(span, "class", "maximize svelte-8s4igv");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (106:19) 
function create_if_block_5$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-8s4igv");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (104:15) 
function create_if_block_4$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No type property name given.";
			attr(span, "class", "maximize svelte-8s4igv");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (94:0) {#if !updateNode || (prop && typeProp)}
function create_if_block$2(ctx) {
	let t0;
	let input0;
	let input0_id_value;
	let t1;
	let input1;
	let input1_id_value;
	let mounted;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (/*label*/ ctx[4]) return create_if_block_1$2;
		if (/*indented*/ ctx[5]) return create_if_block_3$2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			input0 = element("input");
			t1 = space();
			input1 = element("input");
			attr(input0, "type", "text");
			attr(input0, "id", input0_id_value = "node-input-" + /*id*/ ctx[3]);
			attr(input0, "style", /*style*/ ctx[8]);
			attr(input1, "type", "hidden");
			attr(input1, "id", input1_id_value = "node-input-" + /*id*/ ctx[3] + "-type");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, input0, anchor);
			set_input_value(input0, /*value*/ ctx[1]);
			insert(target, t1, anchor);
			insert(target, input1, anchor);
			set_input_value(input1, /*type*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input0, "mouseenter", /*mouseenter_handler_1*/ ctx[19]),
					listen(input0, "mouseleave", /*mouseleave_handler_1*/ ctx[20]),
					listen(input0, "input", /*input0_input_handler*/ ctx[24]),
					listen(input1, "mouseenter", /*mouseenter_handler_2*/ ctx[17]),
					listen(input1, "mouseleave", /*mouseleave_handler_2*/ ctx[18]),
					listen(input1, "input", /*input1_input_handler*/ ctx[25])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			}

			if (dirty & /*id*/ 8 && input0_id_value !== (input0_id_value = "node-input-" + /*id*/ ctx[3])) {
				attr(input0, "id", input0_id_value);
			}

			if (dirty & /*style*/ 256) {
				attr(input0, "style", /*style*/ ctx[8]);
			}

			if (dirty & /*value*/ 2 && input0.value !== /*value*/ ctx[1]) {
				set_input_value(input0, /*value*/ ctx[1]);
			}

			if (dirty & /*id*/ 8 && input1_id_value !== (input1_id_value = "node-input-" + /*id*/ ctx[3] + "-type")) {
				attr(input1, "id", input1_id_value);
			}

			if (dirty & /*type*/ 1) {
				set_input_value(input1, /*type*/ ctx[0]);
			}
		},
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(t0);
			if (detaching) detach(input0);
			if (detaching) detach(t1);
			if (detaching) detach(input1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:21) 
function create_if_block_3$2(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (95:2) {#if label}
function create_if_block_1$2(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[2] && create_if_block_2$2(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[4]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[21]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[22]),
					listen(label_1, "click", /*click_handler*/ ctx[23])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$2(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 16) set_data(t1, /*label*/ ctx[4]);

			if (dirty & /*id*/ 8 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[3])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (96:91) {#if icon}
function create_if_block_2$2(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-8s4igv");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-8s4igv")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*updateNode*/ ctx[9] || /*prop*/ ctx[6] && /*typeProp*/ ctx[7]) return create_if_block$2;
		if (/*prop*/ ctx[6]) return create_if_block_4$2;
		if (/*typeProp*/ ctx[7]) return create_if_block_5$2;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { disabled = false, i18n, icon, id, indented = false, label, maximize, node, placeholder, prop, type, typeProp, types, value } = $$props;
	id = id || getId(prop);
	let defaults = node?._def?.defaults || {};
	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';

	if (label !== false) {
		label = label || defaults[prop] && defaults[prop].label || prop;
	}

	if (!types && node[typeProp]) {
		types = defaults[typeProp].types;
	}

	icon = icon || defaults?.[prop]?.icon || '';
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let initialized = false;

	onMount(() => {
		// placeholder must be stated before changing to a TypedInput field
		if (placeholder) window.$('#node-input-' + id).attr("placeholder", placeholder);

		window.$('#node-input-' + id).typedInput({
			types,
			typeField: `#node-input-${id}-type`
		});

		window.$('#node-input-' + id).typedInput('disable', disabled); // no effect if stated in the object above

		window.$('#node-input-' + id).on('change', (type, value) => {
			value = window.$('#node-input-' + id).typedInput('value');
			type = window.$('#node-input-' + id).typedInput('type');

			if (updateNode) {
				$$invalidate(11, node[prop] = value, node);
				$$invalidate(11, node[typeProp] = type, node);
			}

			dispatch('change', { id, value, type });
		});

		initialized = true;
	});

	// we set style for typed input direct as classes won't work
	let style = 'margin-right: 0px; ';

	if (maximize) style += 'width: 100%;';

	const setFocus = e => {
		// TypedInput has a dummy input field which has no id. Therefor we must reroute the label onclick -> focus.
		window.$(e.target.parentNode.children).find('.red-ui-typedInput-input').focus();
	};

	const update = (key, value) => {
		if (initialized) {
			window.$('#node-input-' + id).typedInput(key, value);
		}
	};

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = e => setFocus(e);

	function input0_input_handler() {
		value = this.value;
		(($$invalidate(1, value), $$invalidate(11, node)), $$invalidate(6, prop));
	}

	function input1_input_handler() {
		type = this.value;
		(($$invalidate(0, type), $$invalidate(11, node)), $$invalidate(7, typeProp));
	}

	$$self.$$set = $$props => {
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(15, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(11, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(16, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(6, prop = $$props.prop);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('typeProp' in $$props) $$invalidate(7, typeProp = $$props.typeProp);
		if ('types' in $$props) $$invalidate(12, types = $$props.types);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*node, prop, value*/ 2114) {
			$$invalidate(1, value = updateNode && node[prop] || value);
		}

		if ($$self.$$.dirty & /*node, typeProp, type*/ 2177) {
			$$invalidate(0, type = updateNode && node[typeProp] || type);
		}

		if ($$self.$$.dirty & /*types*/ 4096) {
			update('types', types);
		}

		if ($$self.$$.dirty & /*value*/ 2) {
			if (updateNode) update('value', value);
		}

		if ($$self.$$.dirty & /*type*/ 1) {
			if (updateNode) update('type', type);
		}

		if ($$self.$$.dirty & /*disabled*/ 8192) {
			update('disable', disabled);
		}
	};

	return [
		type,
		value,
		icon,
		id,
		label,
		indented,
		prop,
		typeProp,
		style,
		updateNode,
		setFocus,
		node,
		types,
		disabled,
		i18n,
		maximize,
		placeholder,
		mouseenter_handler_2,
		mouseleave_handler_2,
		mouseenter_handler_1,
		mouseleave_handler_1,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		input0_input_handler,
		input1_input_handler
	];
}

class PlainTypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				disabled: 13,
				i18n: 14,
				icon: 2,
				id: 3,
				indented: 5,
				label: 4,
				maximize: 15,
				node: 11,
				placeholder: 16,
				prop: 6,
				type: 0,
				typeProp: 7,
				types: 12,
				value: 1
			},
			add_css$2
		);
	}
}

/* node_modules/svelte-integration-red/components/TypedInput.svelte generated by Svelte v3.43.0 */

function create_default_slot$2(ctx) {
	let plaintypedinput;
	let updating_node;
	let updating_prop;
	let updating_typeProp;
	let updating_value;
	let updating_type;
	let updating_types;
	let updating_label;
	let updating_disabled;
	let current;

	function plaintypedinput_node_binding(value) {
		/*plaintypedinput_node_binding*/ ctx[18](value);
	}

	function plaintypedinput_prop_binding(value) {
		/*plaintypedinput_prop_binding*/ ctx[19](value);
	}

	function plaintypedinput_typeProp_binding(value) {
		/*plaintypedinput_typeProp_binding*/ ctx[20](value);
	}

	function plaintypedinput_value_binding(value) {
		/*plaintypedinput_value_binding*/ ctx[21](value);
	}

	function plaintypedinput_type_binding(value) {
		/*plaintypedinput_type_binding*/ ctx[22](value);
	}

	function plaintypedinput_types_binding(value) {
		/*plaintypedinput_types_binding*/ ctx[23](value);
	}

	function plaintypedinput_label_binding(value) {
		/*plaintypedinput_label_binding*/ ctx[24](value);
	}

	function plaintypedinput_disabled_binding(value) {
		/*plaintypedinput_disabled_binding*/ ctx[25](value);
	}

	let plaintypedinput_props = {
		placeholder: /*placeholder*/ ctx[16],
		icon: /*icon*/ ctx[14],
		maximize: /*maximize*/ ctx[4],
		id: /*id*/ ctx[15],
		i18n: /*i18n*/ ctx[13],
		indented: /*indented*/ ctx[1]
	};

	if (/*node*/ ctx[5] !== void 0) {
		plaintypedinput_props.node = /*node*/ ctx[5];
	}

	if (/*prop*/ ctx[6] !== void 0) {
		plaintypedinput_props.prop = /*prop*/ ctx[6];
	}

	if (/*typeProp*/ ctx[8] !== void 0) {
		plaintypedinput_props.typeProp = /*typeProp*/ ctx[8];
	}

	if (/*value*/ ctx[10] !== void 0) {
		plaintypedinput_props.value = /*value*/ ctx[10];
	}

	if (/*type*/ ctx[7] !== void 0) {
		plaintypedinput_props.type = /*type*/ ctx[7];
	}

	if (/*types*/ ctx[9] !== void 0) {
		plaintypedinput_props.types = /*types*/ ctx[9];
	}

	if (/*label*/ ctx[3] !== void 0) {
		plaintypedinput_props.label = /*label*/ ctx[3];
	}

	if (/*disabled*/ ctx[0] !== void 0) {
		plaintypedinput_props.disabled = /*disabled*/ ctx[0];
	}

	plaintypedinput = new PlainTypedInput({ props: plaintypedinput_props });
	binding_callbacks.push(() => bind(plaintypedinput, 'node', plaintypedinput_node_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'prop', plaintypedinput_prop_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'typeProp', plaintypedinput_typeProp_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'value', plaintypedinput_value_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'type', plaintypedinput_type_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'types', plaintypedinput_types_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'label', plaintypedinput_label_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'disabled', plaintypedinput_disabled_binding));
	plaintypedinput.$on("change", /*change_handler*/ ctx[26]);
	plaintypedinput.$on("mouseenter", /*mouseenter_handler*/ ctx[27]);
	plaintypedinput.$on("mouseleave", /*mouseleave_handler*/ ctx[28]);

	return {
		c() {
			create_component(plaintypedinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaintypedinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaintypedinput_changes = {};
			if (dirty & /*placeholder*/ 65536) plaintypedinput_changes.placeholder = /*placeholder*/ ctx[16];
			if (dirty & /*icon*/ 16384) plaintypedinput_changes.icon = /*icon*/ ctx[14];
			if (dirty & /*maximize*/ 16) plaintypedinput_changes.maximize = /*maximize*/ ctx[4];
			if (dirty & /*id*/ 32768) plaintypedinput_changes.id = /*id*/ ctx[15];
			if (dirty & /*i18n*/ 8192) plaintypedinput_changes.i18n = /*i18n*/ ctx[13];
			if (dirty & /*indented*/ 2) plaintypedinput_changes.indented = /*indented*/ ctx[1];

			if (!updating_node && dirty & /*node*/ 32) {
				updating_node = true;
				plaintypedinput_changes.node = /*node*/ ctx[5];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty & /*prop*/ 64) {
				updating_prop = true;
				plaintypedinput_changes.prop = /*prop*/ ctx[6];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_typeProp && dirty & /*typeProp*/ 256) {
				updating_typeProp = true;
				plaintypedinput_changes.typeProp = /*typeProp*/ ctx[8];
				add_flush_callback(() => updating_typeProp = false);
			}

			if (!updating_value && dirty & /*value*/ 1024) {
				updating_value = true;
				plaintypedinput_changes.value = /*value*/ ctx[10];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty & /*type*/ 128) {
				updating_type = true;
				plaintypedinput_changes.type = /*type*/ ctx[7];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_types && dirty & /*types*/ 512) {
				updating_types = true;
				plaintypedinput_changes.types = /*types*/ ctx[9];
				add_flush_callback(() => updating_types = false);
			}

			if (!updating_label && dirty & /*label*/ 8) {
				updating_label = true;
				plaintypedinput_changes.label = /*label*/ ctx[3];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty & /*disabled*/ 1) {
				updating_disabled = true;
				plaintypedinput_changes.disabled = /*disabled*/ ctx[0];
				add_flush_callback(() => updating_disabled = false);
			}

			plaintypedinput.$set(plaintypedinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaintypedinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaintypedinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaintypedinput, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-TypedInput-Container-" + /*id*/ ctx[15],
				clazz: "" + (/*clazz*/ ctx[11] + " sir-Input-Container"),
				inline: /*inline*/ ctx[2],
				fading: /*fading*/ ctx[12],
				style: /*style*/ ctx[17],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 32768) row_changes.id = "sir-TypedInput-Container-" + /*id*/ ctx[15];
			if (dirty & /*clazz*/ 2048) row_changes.clazz = "" + (/*clazz*/ ctx[11] + " sir-Input-Container");
			if (dirty & /*inline*/ 4) row_changes.inline = /*inline*/ ctx[2];
			if (dirty & /*fading*/ 4096) row_changes.fading = /*fading*/ ctx[12];
			if (dirty & /*style*/ 131072) row_changes.style = /*style*/ ctx[17];

			if (dirty & /*$$scope, placeholder, icon, maximize, id, i18n, indented, node, prop, typeProp, value, type, types, label, disabled*/ 536995835) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { clazz = '', disabled = false, fading = true, i18n, icon, id, indented = false, inline = false, label, maximize = true, node, placeholder, prop, style = '', type, typeProp, types, value } = $$props;
	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);
	maximize = getBooleanFrom(maximize);

	function plaintypedinput_node_binding(value) {
		node = value;
		$$invalidate(5, node);
	}

	function plaintypedinput_prop_binding(value) {
		prop = value;
		$$invalidate(6, prop);
	}

	function plaintypedinput_typeProp_binding(value) {
		typeProp = value;
		$$invalidate(8, typeProp);
	}

	function plaintypedinput_value_binding(value$1) {
		value = value$1;
		$$invalidate(10, value);
	}

	function plaintypedinput_type_binding(value) {
		type = value;
		$$invalidate(7, type);
	}

	function plaintypedinput_types_binding(value) {
		types = value;
		$$invalidate(9, types);
	}

	function plaintypedinput_label_binding(value) {
		label = value;
		$$invalidate(3, label);
	}

	function plaintypedinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(0, disabled);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(11, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(12, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(13, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(14, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(15, id = $$props.id);
		if ('indented' in $$props) $$invalidate(1, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(2, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(4, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(5, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(16, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(6, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(17, style = $$props.style);
		if ('type' in $$props) $$invalidate(7, type = $$props.type);
		if ('typeProp' in $$props) $$invalidate(8, typeProp = $$props.typeProp);
		if ('types' in $$props) $$invalidate(9, types = $$props.types);
		if ('value' in $$props) $$invalidate(10, value = $$props.value);
	};

	return [
		disabled,
		indented,
		inline,
		label,
		maximize,
		node,
		prop,
		type,
		typeProp,
		types,
		value,
		clazz,
		fading,
		i18n,
		icon,
		id,
		placeholder,
		style,
		plaintypedinput_node_binding,
		plaintypedinput_prop_binding,
		plaintypedinput_typeProp_binding,
		plaintypedinput_value_binding,
		plaintypedinput_type_binding,
		plaintypedinput_types_binding,
		plaintypedinput_label_binding,
		plaintypedinput_disabled_binding,
		change_handler,
		mouseenter_handler,
		mouseleave_handler
	];
}

class TypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			clazz: 11,
			disabled: 0,
			fading: 12,
			i18n: 13,
			icon: 14,
			id: 15,
			indented: 1,
			inline: 2,
			label: 3,
			maximize: 4,
			node: 5,
			placeholder: 16,
			prop: 6,
			style: 17,
			type: 7,
			typeProp: 8,
			types: 9,
			value: 10
		});
	}
}

async function getOpenApiSpec (openApiUrl) {
  const url = encodeURI(openApiUrl);
  // server call
  return window.$.get('getOpenApiSpec?openApiUrl=' + url, function (response) {
    return response
  })
    .fail(function (message) {
      return message
    })
}

const getCorrectType = (param) => {
  const type = param?.schema?.type || param.type;
  if (type === 'boolean') return 'bool'
  if (type === 'integer') return 'num'
  if (param.name === 'Json Request Body' || param.name === 'body' || type === 'body' || type === 'object') return 'json'
  if (param?.items?.enum?.length > 0 || param?.schema?.enum?.length) return 'array'
  return 'str'
};

const getAllowedTypes = (input) => {
  let type;
  if (typeof input === 'string') type = input;
  else type = getCorrectType(input);
  if (type === 'bool') return ['bool', 'msg', 'flow', 'global']
  if (type === 'num') return ['num', 'jsonata', 'msg', 'flow', 'global']
  if (type === 'json') return ['json', 'jsonata', 'msg', 'flow', 'global']
  if (type === 'array') {
    const options = input?.items?.enum || input?.schema?.enum;
    return [{ value: 'select', label: 'Select', options: options }, 'str', 'msg', 'flow', 'global']
  }
  return ['str', 'json', 'jsonata', 'msg', 'flow', 'global']
};

// is an object
const sortKeys = (schema) => {
  let keys = null;
  if (schema?.properties) {
    // ordering keys helps later with svelte #each (first required then normal and sorted alphabetical)
    keys = Object.keys(schema.properties).sort();
    if (schema.required) {
      const notRequiredKeys = keys.filter(prop => !schema.required.includes(prop));
      keys = schema.required.sort().concat(notRequiredKeys.sort());
    }
  }
  return keys
};
// is an array
const orderRequired = (a, b) => {
  let comparison = 0;
  if (b.required) {
    comparison = 1;
  } else if (a.required) {
    comparison = -1;
  }
  return comparison
};

const createParameters = (node, operationData, oldParameters) => {
  // new in openApi: body request
  // check if requestBody is in parameters or separate
  if (!operationData.parameters?.requestBody && operationData?.requestBody?.content) {
    const requestBody = operationData.requestBody;
    const content = requestBody.content;
    const keys = sortKeys(content[node.contentType].schema);
    if (content[node.contentType]) {
      node.parameters.push({
        id: 'requestBody',
        name: 'Request body',
        in: '',
        schema: content[node.contentType].schema || null,
        value: oldParameters?.[' Request body']?.value || '{}',
        required: !!requestBody?.required || false,
        isActive: !!requestBody?.required || oldParameters?.[' Request body']?.isActive || false,
        description: requestBody?.description || '-',
        type: oldParameters?.[' Request body']?.inputType || 'json',
        allowedTypes: getAllowedTypes('json'),
        keys
      });
    }
  }
  // add standard parameters
  const parameters = operationData?.parameters?.sort(orderRequired) || [];
  parameters.forEach(param => {
    const keys = sortKeys(param.schema);
    node.parameters.push(
      {
        id: param.name + param.in,
        name: param.name,
        in: param.in,
        required: param.required,
        value: oldParameters?.[param.name + ' ' + param.in]?.value || '',
        isActive: !!param.required || oldParameters?.[param.name + ' ' + param.in]?.isActive || false,
        type: oldParameters?.[param.name + ' ' + param.in]?.inputType || getCorrectType(param), // selected type
        allowedTypes: getAllowedTypes(param),
        description: param.description || '-',
        schema: param.schema || null,
        keys
      }
    );
  });
};

/* utils/JsonParamHelper.svelte generated by Svelte v3.43.0 */

function add_css$1(target) {
	append_styles(target, "svelte-qzpchp", ".jsonObjectKeyList.svelte-qzpchp{margin-bottom:0px}.jsonKeys.svelte-qzpchp{display:none}");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i][0];
	child_ctx[12] = list[i][1];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i][0];
	child_ctx[12] = list[i][1];
	return child_ctx;
}

// (55:0) <Row>
function create_default_slot$1(ctx) {
	let button0;
	let t0;
	let button1;
	let t1;
	let button2;
	let current;

	button0 = new Button({
			props: {
				inline: true,
				icon: "show",
				label: /*label*/ ctx[2]
			}
		});

	button0.$on("click", /*click_handler*/ ctx[4]);

	button1 = new Button({
			props: {
				inline: true,
				icon: "edit",
				label: "Set default"
			}
		});

	button1.$on("click", /*click_handler_1*/ ctx[5]);

	button2 = new Button({
			props: {
				inline: true,
				icon: "edit",
				label: "Set required"
			}
		});

	button2.$on("click", /*click_handler_2*/ ctx[6]);

	return {
		c() {
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			create_component(button2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t0, anchor);
			mount_component(button1, target, anchor);
			insert(target, t1, anchor);
			mount_component(button2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};
			if (dirty & /*label*/ 4) button0_changes.label = /*label*/ ctx[2];
			button0.$set(button0_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t0);
			destroy_component(button1, detaching);
			if (detaching) detach(t1);
			destroy_component(button2, detaching);
		}
	};
}

// (99:2) {:else}
function create_else_block$1(ctx) {
	let t;

	return {
		c() {
			t = text("No properties defined.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (61:2) {#if param.schema && param.keys}
function create_if_block$1(ctx) {
	let each_1_anchor;
	let each_value = /*param*/ ctx[0].keys;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value = /*param*/ ctx[0].keys;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (68:10) {#if param.schema.properties[propKey].description}
function create_if_block_5$1(ctx) {
	let div;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description + "";
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text("Description: ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (71:10) {#if param.schema.properties[propKey].example}
function create_if_block_4$1(ctx) {
	let div;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example + "";
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text("Example: ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (82:119) 
function create_if_block_2$1(ctx) {
	let div1;
	let div0;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type + "";
	let t1;
	let t2;
	let if_block = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.properties && create_if_block_3$1(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t0 = text("Containing: ");
			t1 = text(t1_value);
			t2 = space();
			if (if_block) if_block.c();
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, t0);
			append(div0, t1);
			append(div1, t2);
			if (if_block) if_block.m(div1, null);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type + "")) set_data(t1, t1_value);

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.properties) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
		}
	};
}

// (74:10) {#if param.schema.properties[propKey].type === "object"}
function create_if_block_1$1(ctx) {
	let t0_value = "{" + "";
	let t0;
	let t1;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let t3_value = "}" + "";
	let t3;
	let each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].properties);
	const get_key = ctx => /*pKey*/ ctx[11];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
	}

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].properties);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, destroy_block, create_each_block_1$1, null, get_each_context_1$1);
			}
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (85:14) {#if param.schema.properties[propKey].items.type === "object" && param.schema.properties[propKey]?.items?.properties}
function create_if_block_3$1(ctx) {
	let t0_value = "{" + "";
	let t0;
	let t1;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let t3_value = "}" + "";
	let t3;
	let each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.properties);
	const get_key = ctx => /*pKey*/ ctx[11];

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2$1(key, child_ctx));
	}

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.properties);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, ul, destroy_block, create_each_block_2$1, null, get_each_context_2$1);
			}
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (88:18) {#each Object.entries(param.schema.properties[propKey].items.properties) as [pKey, p] (pKey)}
function create_each_block_2$1(key_1, ctx) {
	let p;
	let t0_value = /*pKey*/ ctx[11] + "";
	let t0;
	let t1;
	let t2_value = /*p*/ ctx[12].type + "";
	let t2;

	return {
		key: key_1,
		first: null,
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
			this.first = p;
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[11] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[12].type + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (77:14) {#each Object.entries(param.schema.properties[propKey].properties) as [pKey, p] (pKey)}
function create_each_block_1$1(key_1, ctx) {
	let p;
	let t0_value = /*pKey*/ ctx[11] + "";
	let t0;
	let t1;
	let t2_value = /*p*/ ctx[12].type + "";
	let t2;

	return {
		key: key_1,
		first: null,
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
			this.first = p;
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[11] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[12].type + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (62:4) {#each param.keys as propKey}
function create_each_block$1(ctx) {
	let ul;
	let li;
	let div;
	let t0_value = /*propKey*/ ctx[8] + "";
	let t0;
	let t1;
	let t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type + "";
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;

	function func(...args) {
		return /*func*/ ctx[7](/*propKey*/ ctx[8], ...args);
	}

	let if_block0 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description && create_if_block_5$1(ctx);
	let if_block1 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example && create_if_block_4$1(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type === "object") return create_if_block_1$1;
		if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type === "array" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.type) return create_if_block_2$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block2 = current_block_type && current_block_type(ctx);

	return {
		c() {
			ul = element("ul");
			li = element("li");
			div = element("div");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			if (if_block2) if_block2.c();
			t6 = space();
			toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
		},
		m(target, anchor) {
			insert(target, ul, anchor);
			append(ul, li);
			append(li, div);
			append(div, t0);
			append(div, t1);
			append(div, t2);
			append(li, t3);
			if (if_block0) if_block0.m(li, null);
			append(li, t4);
			if (if_block1) if_block1.m(li, null);
			append(li, t5);
			if (if_block2) if_block2.m(li, null);
			append(ul, t6);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*propKey*/ ctx[8] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type + "")) set_data(t2, t2_value);

			if (dirty & /*param*/ 1) {
				toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
			}

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_5$1(ctx);
					if_block0.c();
					if_block0.m(li, t4);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$1(ctx);
					if_block1.c();
					if_block1.m(li, t5);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if (if_block2) if_block2.d(1);
				if_block2 = current_block_type && current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(li, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();

			if (if_block2) {
				if_block2.d();
			}
		}
	};
}

function create_fragment$1(ctx) {
	let row;
	let t;
	let div;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	function select_block_type(ctx, dirty) {
		if (/*param*/ ctx[0].schema && /*param*/ ctx[0].keys) return create_if_block$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			create_component(row.$$.fragment);
			t = space();
			div = element("div");
			if_block.c();
			attr(div, "class", "svelte-qzpchp");
			toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);
			if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};

			if (dirty & /*$$scope, param, label, hideJsonKeys*/ 131079) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*hideJsonKeys*/ 2) {
				toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { param } = $$props;

	const setJsonKeys = (param, option) => {
		const required = [];
		const notRequired = [];
		const exists = [];
		const propKeys = Object.keys(param.schema.properties);
		let fieldValue = window.$('#node-input-' + param.id).typedInput('value');

		try {
			fieldValue = JSON.parse(fieldValue);
		} catch {
			fieldValue = {};
		}

		propKeys.forEach(prop => {
			if (fieldValue[prop]) {
				const value = fieldValue[prop];

				// chk if value is empty array or object -> would return "" otherwise
				if (typeof value === 'object') {
					if (Array.isArray(value) && value.length === 0) exists.push(`"${prop}": []`); else if (Object.keys(value).length === 0) exists.push(`"${prop}": {}`); else exists.push(`"${prop}": "${value}"`);
				} else {
					exists.push(`"${prop}": "${value}"`);
				}
			} else {
				let isRequired = false;
				if (param.schema.required) isRequired = param.schema.required.find(reqParam => reqParam === prop);

				if (isRequired) {
					required.push(`"${prop}": "${param.schema.properties[prop].type} - required"`);
				} else {
					notRequired.push(`"${prop}": "${param.schema.properties[prop].type}"`);
				}
			}
		});

		let result = required.concat(exists);
		if (option === 'default') result = result.concat(notRequired);
		result = '{' + result.join(', ') + '}';

		// jQuery because setting node.parameters[index].value does not work
		window.$('#node-input-' + param.id).typedInput('value', result);
	};

	let hideJsonKeys = true;
	let label = "Show Keys";
	const click_handler = () => $$invalidate(1, hideJsonKeys = !hideJsonKeys);
	const click_handler_1 = () => setJsonKeys(param, "default");
	const click_handler_2 = () => setJsonKeys(param, "required");
	const func = (propKey, reqParam) => reqParam === propKey;

	$$self.$$set = $$props => {
		if ('param' in $$props) $$invalidate(0, param = $$props.param);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*hideJsonKeys*/ 2) {
			if (hideJsonKeys) {
				$$invalidate(2, label = "Show Keys");
			} else {
				$$invalidate(2, label = "Hide Keys");
			}
		}
	};

	return [
		param,
		hideJsonKeys,
		label,
		setJsonKeys,
		click_handler,
		click_handler_1,
		click_handler_2,
		func
	];
}

class JsonParamHelper extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { param: 0 }, add_css$1);
	}
}

/* openApi-red.svelte generated by Svelte v3.43.0 */

function add_css(target) {
	append_styles(target, "svelte-xrigyb", "#openApi-red-svelte-container :is(.required, .required label){font-weight:bold!important}#openApi-red-svelte-container .sir-collapsible.sir-form-row{align-items:normal}#openApi-red-svelte-container .noLongLabel label{width:105px !important}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[36] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[39] = list[i][0];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[42] = list[i];
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[45] = list[i];
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	return child_ctx;
}

// (199:0) {#if error}
function create_if_block_12(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "error",
				$$slots: {
					header: [create_header_slot_2],
					default: [create_default_slot_16]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};

			if (dirty[0] & /*error*/ 32 | dirty[1] & /*$$scope*/ 1048576) {
				callout_changes.$$scope = { dirty, ctx };
			}

			callout.$set(callout_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (200:2) <Callout type="error">
function create_default_slot_16(ctx) {
	let t;

	return {
		c() {
			t = text(/*error*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*error*/ 32) set_data(t, /*error*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (201:4) 
function create_header_slot_2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (209:4) <Row>
function create_default_slot_15(ctx) {
	let input;
	let updating_node;
	let t;
	let button;
	let current;

	function input_node_binding_1(value) {
		/*input_node_binding_1*/ ctx[15](value);
	}

	let input_props = {
		prop: "openApiUrl",
		label: "URL",
		inline: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_1));

	button = new Button({
			props: {
				icon: "edit",
				label: "read",
				inline: true
			}
		});

	button.$on("click", /*createApi*/ ctx[10]);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (213:4) {#if servers?.length > 1}
function create_if_block_9(ctx) {
	let div;
	let t;
	let row;
	let current;
	let if_block = /*node*/ ctx[0].alternServer && create_if_block_11(ctx);

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			create_component(row.$$.fragment);
			set_style(div, "margin-left", "113px");
			set_style(div, "margin-bottom", "12px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			insert(target, t, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*node*/ ctx[0].alternServer) {
				if (if_block) {
					if (dirty[0] & /*node*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_11(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const row_changes = {};

			if (dirty[0] & /*node, servers*/ 17 | dirty[1] & /*$$scope*/ 1048576) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (detaching) detach(t);
			destroy_component(row, detaching);
		}
	};
}

// (215:8) {#if node.alternServer}
function create_if_block_11(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "warning",
				closeable: true,
				$$slots: {
					header: [create_header_slot_1],
					default: [create_default_slot_14]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (216:8) <Callout type="warning" closeable>
function create_default_slot_14(ctx) {
	let t;

	return {
		c() {
			t = text("Setting an alternative server was not tested in a practical environment, but should work. If not, please set a bug report!");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (217:10) 
function create_header_slot_1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Alternative Server is an experimental Feature!";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (225:12) {#if s.description}
function create_if_block_10(ctx) {
	let option;
	let t_value = /*s*/ ctx[48].description + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.disabled = true;
			option.__value = option_value_value = /*s*/ ctx[48].description;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*servers*/ 16 && t_value !== (t_value = /*s*/ ctx[48].description + "")) set_data(t, t_value);

			if (dirty[0] & /*servers*/ 16 && option_value_value !== (option_value_value = /*s*/ ctx[48].description)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (224:10) {#each servers as s}
function create_each_block_5(ctx) {
	let t0;
	let option0;
	let t1_value = /*s*/ ctx[48].url + "";
	let t1;
	let option0_value_value;
	let t2;
	let option1;
	let if_block = /*s*/ ctx[48].description && create_if_block_10(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			option0 = element("option");
			t1 = text(t1_value);
			t2 = space();
			option1 = element("option");
			option1.textContent = "-------------------------";
			option0.__value = option0_value_value = /*s*/ ctx[48].url;
			option0.value = option0.__value;
			option1.disabled = true;
			option1.__value = "-------------------------";
			option1.value = option1.__value;
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, option0, anchor);
			append(option0, t1);
			insert(target, t2, anchor);
			insert(target, option1, anchor);
		},
		p(ctx, dirty) {
			if (/*s*/ ctx[48].description) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*servers*/ 16 && t1_value !== (t1_value = /*s*/ ctx[48].url + "")) set_data(t1, t1_value);

			if (dirty[0] & /*servers*/ 16 && option0_value_value !== (option0_value_value = /*s*/ ctx[48].url)) {
				option0.__value = option0_value_value;
				option0.value = option0.__value;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(option0);
			if (detaching) detach(t2);
			if (detaching) detach(option1);
		}
	};
}

// (223:8) <Select inline bind:node prop="server"  disabled={!node.alternServer}>
function create_default_slot_13(ctx) {
	let each_1_anchor;
	let each_value_5 = /*servers*/ ctx[4];
	let each_blocks = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*servers*/ 16) {
				each_value_5 = /*servers*/ ctx[4];
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5(ctx, each_value_5, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_5.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (222:6) <Row>
function create_default_slot_12(ctx) {
	let select;
	let updating_node;
	let t;
	let input;
	let updating_node_1;
	let current;

	function select_node_binding(value) {
		/*select_node_binding*/ ctx[16](value);
	}

	let select_props = {
		inline: true,
		prop: "server",
		disabled: !/*node*/ ctx[0].alternServer,
		$$slots: { default: [create_default_slot_13] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding));

	function input_node_binding_2(value) {
		/*input_node_binding_2*/ ctx[17](value);
	}

	let input_props = { prop: "alternServer", inline: true };

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_2));

	return {
		c() {
			create_component(select.$$.fragment);
			t = space();
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			insert(target, t, anchor);
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty[0] & /*node*/ 1) select_changes.disabled = !/*node*/ ctx[0].alternServer;

			if (dirty[0] & /*servers*/ 16 | dirty[1] & /*$$scope*/ 1048576) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			select.$set(select_changes);
			const input_changes = {};

			if (!updating_node_1 && dirty[0] & /*node*/ 1) {
				updating_node_1 = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
			if (detaching) detach(t);
			destroy_component(input, detaching);
		}
	};
}

// (237:6) {#each errorHandlingOptions as eOption}
function create_each_block_4(ctx) {
	let option;
	let t_value = /*eOption*/ ctx[45] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*eOption*/ ctx[45];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (236:4) <Select bind:node prop="errorHandling" >
function create_default_slot_11(ctx) {
	let each_1_anchor;
	let each_value_4 = /*errorHandlingOptions*/ ctx[11];
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*errorHandlingOptions*/ 2048) {
				each_value_4 = /*errorHandlingOptions*/ ctx[11];
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_4.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (207:2) <Group>
function create_default_slot_10(ctx) {
	let input;
	let updating_node;
	let t0;
	let row;
	let t1;
	let t2;
	let select;
	let updating_node_1;
	let current;

	function input_node_binding(value) {
		/*input_node_binding*/ ctx[14](value);
	}

	let input_props = { prop: "name", placeholder: "openApi-red" };

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding));

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			}
		});

	let if_block = /*servers*/ ctx[4]?.length > 1 && create_if_block_9(ctx);

	function select_node_binding_1(value) {
		/*select_node_binding_1*/ ctx[18](value);
	}

	let select_props = {
		prop: "errorHandling",
		$$slots: { default: [create_default_slot_11] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding_1));

	return {
		c() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(row.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t0, anchor);
			mount_component(row, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t2, anchor);
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const row_changes = {};

			if (dirty[0] & /*node*/ 1 | dirty[1] & /*$$scope*/ 1048576) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (/*servers*/ ctx[4]?.length > 1) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*servers*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t2.parentNode, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const select_changes = {};

			if (dirty[1] & /*$$scope*/ 1048576) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_1 && dirty[0] & /*node*/ 1) {
				updating_node_1 = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(if_block);
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(if_block);
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t0);
			destroy_component(row, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t2);
			destroy_component(select, detaching);
		}
	};
}

// (206:0) <Collapsible label="General">
function create_default_slot_9(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};

			if (dirty[0] & /*node, servers*/ 17 | dirty[1] & /*$$scope*/ 1048576) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

// (250:10) {:else}
function create_else_block_4(ctx) {
	let option;
	let t_value = /*api*/ ctx[42] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*api*/ ctx[42];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*apis*/ 64 && t_value !== (t_value = /*api*/ ctx[42] + "")) set_data(t, t_value);

			if (dirty[0] & /*apis*/ 64 && option_value_value !== (option_value_value = /*api*/ ctx[42])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (248:10) {#if node.api === api}
function create_if_block_8(ctx) {
	let option;
	let t_value = /*api*/ ctx[42] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*api*/ ctx[42];
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*apis*/ 64 && t_value !== (t_value = /*api*/ ctx[42] + "")) set_data(t, t_value);

			if (dirty[0] & /*apis*/ 64 && option_value_value !== (option_value_value = /*api*/ ctx[42])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (247:8) { #each apis as api}
function create_each_block_3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0].api === /*api*/ ctx[42]) return create_if_block_8;
		return create_else_block_4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (245:4) <Select bind:node prop="api" >
function create_default_slot_8(ctx) {
	let option;
	let t;
	let each_1_anchor;
	let each_value_3 = /*apis*/ ctx[6];
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	return {
		c() {
			option = element("option");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = "";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*apis, node*/ 65) {
				each_value_3 = /*apis*/ ctx[6];
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (260:8) {:else}
function create_else_block_3(ctx) {
	let option;
	let t_value = /*operations*/ ctx[7][/*key*/ ctx[39]].summary + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*operations*/ ctx[7][/*key*/ ctx[39]].operationId;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operations*/ 128 && t_value !== (t_value = /*operations*/ ctx[7][/*key*/ ctx[39]].summary + "")) set_data(t, t_value);

			if (dirty[0] & /*operations*/ 128 && option_value_value !== (option_value_value = /*operations*/ ctx[7][/*key*/ ctx[39]].operationId)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (258:8) {#if node.operation === operations[key].operationId}
function create_if_block_7(ctx) {
	let option;
	let t_value = /*operations*/ ctx[7][/*key*/ ctx[39]].summary + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*operations*/ ctx[7][/*key*/ ctx[39]].operationId;
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operations*/ 128 && t_value !== (t_value = /*operations*/ ctx[7][/*key*/ ctx[39]].summary + "")) set_data(t, t_value);

			if (dirty[0] & /*operations*/ 128 && option_value_value !== (option_value_value = /*operations*/ ctx[7][/*key*/ ctx[39]].operationId)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (257:6) {#each Object.entries(operations) as [key]}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*node*/ ctx[0].operation === /*operations*/ ctx[7][/*key*/ ctx[39]].operationId) return create_if_block_7;
		return create_else_block_3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (255:4) <Select bind:node prop="operation" >
function create_default_slot_7(ctx) {
	let option;
	let t;
	let each_1_anchor;
	let each_value_2 = Object.entries(/*operations*/ ctx[7]);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			option = element("option");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = "";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operations, node*/ 129) {
				each_value_2 = Object.entries(/*operations*/ ctx[7]);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (266:4) {#if operationDescription && operationDescription !== "-"}
function create_if_block_5(ctx) {
	let div;
	let callout;
	let updating_show;
	let t;
	let current;

	function callout_show_binding(value) {
		/*callout_show_binding*/ ctx[21](value);
	}

	let callout_props = {
		type: "info",
		closeable: true,
		fading: !/*init*/ ctx[9],
		$$slots: {
			header: [create_header_slot],
			default: [create_default_slot_6]
		},
		$$scope: { ctx }
	};

	if (/*showDescription*/ ctx[8] !== void 0) {
		callout_props.show = /*showDescription*/ ctx[8];
	}

	callout = new Callout({ props: callout_props });
	binding_callbacks.push(() => bind(callout, 'show', callout_show_binding));
	let if_block = !/*showDescription*/ ctx[8] && create_if_block_6(ctx);

	return {
		c() {
			div = element("div");
			create_component(callout.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			set_style(div, "margin-left", "113px");
			set_style(div, "margin-bottom", "12px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(callout, div, null);
			append(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};
			if (dirty[0] & /*init*/ 512) callout_changes.fading = !/*init*/ ctx[9];

			if (dirty[0] & /*operationDescription*/ 2 | dirty[1] & /*$$scope*/ 1048576) {
				callout_changes.$$scope = { dirty, ctx };
			}

			if (!updating_show && dirty[0] & /*showDescription*/ 256) {
				updating_show = true;
				callout_changes.show = /*showDescription*/ ctx[8];
				add_flush_callback(() => updating_show = false);
			}

			callout.$set(callout_changes);

			if (!/*showDescription*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*showDescription*/ 256) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(callout);
			if (if_block) if_block.d();
		}
	};
}

// (268:6) <Callout type="info" closeable bind:show={showDescription} fading={!init}>
function create_default_slot_6(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag();
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*operationDescription*/ ctx[1], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operationDescription*/ 2) html_tag.p(/*operationDescription*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (269:8) 
function create_header_slot(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Description";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (272:6) {#if !showDescription}
function create_if_block_6(ctx) {
	let button;
	let current;

	button = new Button({
			props: { label: "show description", icon: "eye" }
		});

	button.$on("click", /*click_handler*/ ctx[22]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (282:8) {:else}
function create_else_block_2(ctx) {
	let option;
	let t_value = /*reqCT*/ ctx[36] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*reqCT*/ ctx[36];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*requestContentTypes*/ 4 && t_value !== (t_value = /*reqCT*/ ctx[36] + "")) set_data(t, t_value);

			if (dirty[0] & /*requestContentTypes*/ 4 && option_value_value !== (option_value_value = /*reqCT*/ ctx[36])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (280:8) {#if node.requestContentType === reqCT}
function create_if_block_4(ctx) {
	let option;
	let t_value = /*reqCT*/ ctx[36] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*reqCT*/ ctx[36];
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*requestContentTypes*/ 4 && t_value !== (t_value = /*reqCT*/ ctx[36] + "")) set_data(t, t_value);

			if (dirty[0] & /*requestContentTypes*/ 4 && option_value_value !== (option_value_value = /*reqCT*/ ctx[36])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (279:6) {#each requestContentTypes as reqCT}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_2(ctx, dirty) {
		if (/*node*/ ctx[0].requestContentType === /*reqCT*/ ctx[36]) return create_if_block_4;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (278:4) <Select clazz="noLongLabel" bind:node prop="requestContentType">
function create_default_slot_5(ctx) {
	let each_1_anchor;
	let each_value_1 = /*requestContentTypes*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*requestContentTypes, node*/ 5) {
				each_value_1 = /*requestContentTypes*/ ctx[2];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (287:4) {#if responseContentTypes.length }
function create_if_block_2(ctx) {
	let select;
	let updating_node;
	let current;

	function select_node_binding_2(value) {
		/*select_node_binding_2*/ ctx[24](value);
	}

	let select_props = {
		clazz: "noLongLabel",
		prop: "responseContentType",
		fading: !/*init*/ ctx[9],
		$$slots: { default: [create_default_slot_4] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding_2));

	return {
		c() {
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty[0] & /*init*/ 512) select_changes.fading = !/*init*/ ctx[9];

			if (dirty[0] & /*responseContentTypes, node*/ 9 | dirty[1] & /*$$scope*/ 1048576) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

// (292:10) {:else}
function create_else_block_1(ctx) {
	let option;
	let t_value = /*resCT*/ ctx[33] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*resCT*/ ctx[33];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*responseContentTypes*/ 8 && t_value !== (t_value = /*resCT*/ ctx[33] + "")) set_data(t, t_value);

			if (dirty[0] & /*responseContentTypes*/ 8 && option_value_value !== (option_value_value = /*resCT*/ ctx[33])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (290:10) {#if node.responseContentType === resCT}
function create_if_block_3(ctx) {
	let option;
	let t_value = /*resCT*/ ctx[33] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*resCT*/ ctx[33];
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*responseContentTypes*/ 8 && t_value !== (t_value = /*resCT*/ ctx[33] + "")) set_data(t, t_value);

			if (dirty[0] & /*responseContentTypes*/ 8 && option_value_value !== (option_value_value = /*resCT*/ ctx[33])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (289:8) {#each responseContentTypes as resCT}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type_3(ctx, dirty) {
		if (/*node*/ ctx[0].responseContentType === /*resCT*/ ctx[33]) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_3(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (288:6) <Select clazz="noLongLabel" bind:node prop="responseContentType" fading={!init} >
function create_default_slot_4(ctx) {
	let each_1_anchor;
	let each_value = /*responseContentTypes*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*responseContentTypes, node*/ 9) {
				each_value = /*responseContentTypes*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (244:2) <Group>
function create_default_slot_3(ctx) {
	let select0;
	let updating_node;
	let t0;
	let select1;
	let updating_node_1;
	let t1;
	let t2;
	let select2;
	let updating_node_2;
	let t3;
	let if_block1_anchor;
	let current;

	function select0_node_binding(value) {
		/*select0_node_binding*/ ctx[19](value);
	}

	let select0_props = {
		prop: "api",
		$$slots: { default: [create_default_slot_8] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select0_props.node = /*node*/ ctx[0];
	}

	select0 = new Select({ props: select0_props });
	binding_callbacks.push(() => bind(select0, 'node', select0_node_binding));

	function select1_node_binding(value) {
		/*select1_node_binding*/ ctx[20](value);
	}

	let select1_props = {
		prop: "operation",
		$$slots: { default: [create_default_slot_7] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select1_props.node = /*node*/ ctx[0];
	}

	select1 = new Select({ props: select1_props });
	binding_callbacks.push(() => bind(select1, 'node', select1_node_binding));
	let if_block0 = /*operationDescription*/ ctx[1] && /*operationDescription*/ ctx[1] !== "-" && create_if_block_5(ctx);

	function select2_node_binding(value) {
		/*select2_node_binding*/ ctx[23](value);
	}

	let select2_props = {
		clazz: "noLongLabel",
		prop: "requestContentType",
		$$slots: { default: [create_default_slot_5] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select2_props.node = /*node*/ ctx[0];
	}

	select2 = new Select({ props: select2_props });
	binding_callbacks.push(() => bind(select2, 'node', select2_node_binding));
	let if_block1 = /*responseContentTypes*/ ctx[3].length && create_if_block_2(ctx);

	return {
		c() {
			create_component(select0.$$.fragment);
			t0 = space();
			create_component(select1.$$.fragment);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			create_component(select2.$$.fragment);
			t3 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			mount_component(select0, target, anchor);
			insert(target, t0, anchor);
			mount_component(select1, target, anchor);
			insert(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t2, anchor);
			mount_component(select2, target, anchor);
			insert(target, t3, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select0_changes = {};

			if (dirty[0] & /*apis, node*/ 65 | dirty[1] & /*$$scope*/ 1048576) {
				select0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				select0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			select0.$set(select0_changes);
			const select1_changes = {};

			if (dirty[0] & /*operations, node*/ 129 | dirty[1] & /*$$scope*/ 1048576) {
				select1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_1 && dirty[0] & /*node*/ 1) {
				updating_node_1 = true;
				select1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			select1.$set(select1_changes);

			if (/*operationDescription*/ ctx[1] && /*operationDescription*/ ctx[1] !== "-") {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*operationDescription*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const select2_changes = {};

			if (dirty[0] & /*requestContentTypes, node*/ 5 | dirty[1] & /*$$scope*/ 1048576) {
				select2_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_2 && dirty[0] & /*node*/ 1) {
				updating_node_2 = true;
				select2_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_2 = false);
			}

			select2.$set(select2_changes);

			if (/*responseContentTypes*/ ctx[3].length) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*responseContentTypes*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(select0.$$.fragment, local);
			transition_in(select1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(select2.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(select0.$$.fragment, local);
			transition_out(select1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(select2.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			destroy_component(select0, detaching);
			if (detaching) detach(t0);
			destroy_component(select1, detaching);
			if (detaching) detach(t1);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t2);
			destroy_component(select2, detaching);
			if (detaching) detach(t3);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (243:0) <Collapsible label="Api options">
function create_default_slot_2(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};

			if (dirty[0] & /*init, node, responseContentTypes, requestContentTypes, showDescription, operationDescription, operations, apis*/ 975 | dirty[1] & /*$$scope*/ 1048576) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

// (329:0) {:else}
function create_else_block(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};

			if (dirty[1] & /*$$scope*/ 1048576) {
				callout_changes.$$scope = { dirty, ctx };
			}

			callout.$set(callout_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (305:0) {#if node.parameters.length > 0}
function create_if_block(ctx) {
	let editablelist;
	let updating_elements;
	let current;

	function editablelist_elements_binding(value) {
		/*editablelist_elements_binding*/ ctx[27](value);
	}

	let editablelist_props = {
		maxHeight: "800",
		$$slots: {
			default: [
				create_default_slot,
				({ element: param, index }) => ({ 31: param, 32: index }),
				({ element: param, index }) => [0, (param ? 1 : 0) | (index ? 2 : 0)]
			]
		},
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0].parameters !== void 0) {
		editablelist_props.elements = /*node*/ ctx[0].parameters;
	}

	editablelist = new EditableList({ props: editablelist_props });
	binding_callbacks.push(() => bind(editablelist, 'elements', editablelist_elements_binding));

	return {
		c() {
			create_component(editablelist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(editablelist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const editablelist_changes = {};

			if (dirty[0] & /*node*/ 1 | dirty[1] & /*$$scope, param*/ 1048577) {
				editablelist_changes.$$scope = { dirty, ctx };
			}

			if (!updating_elements && dirty[0] & /*node*/ 1) {
				updating_elements = true;
				editablelist_changes.elements = /*node*/ ctx[0].parameters;
				add_flush_callback(() => updating_elements = false);
			}

			editablelist.$set(editablelist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(editablelist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(editablelist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(editablelist, detaching);
		}
	};
}

// (330:2) <Callout type="info">
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = text("No parameters found!");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (325:4) {#if param?.schema?.type === "object"}
function create_if_block_1(ctx) {
	let jsonparamhelper;
	let current;
	jsonparamhelper = new JsonParamHelper({ props: { param: /*param*/ ctx[31] } });

	return {
		c() {
			create_component(jsonparamhelper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(jsonparamhelper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const jsonparamhelper_changes = {};
			if (dirty[1] & /*param*/ 1) jsonparamhelper_changes.param = /*param*/ ctx[31];
			jsonparamhelper.$set(jsonparamhelper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(jsonparamhelper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(jsonparamhelper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(jsonparamhelper, detaching);
		}
	};
}

// (306:2) <EditableList bind:elements={node.parameters} let:element={param} let:index maxHeight="800" >
function create_default_slot(ctx) {
	let div;
	let input;
	let t0;
	let typedinput;
	let t1;
	let if_block_anchor;
	let current;

	function change_handler(...args) {
		return /*change_handler*/ ctx[25](/*index*/ ctx[32], ...args);
	}

	input = new Input({
			props: {
				type: "checkbox",
				label: /*param*/ ctx[31].name + ": " + /*param*/ ctx[31].description,
				value: /*param*/ ctx[31].isActive,
				disabled: /*param*/ ctx[31].required
			}
		});

	input.$on("change", change_handler);

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[26](/*index*/ ctx[32], /*param*/ ctx[31], ...args);
	}

	typedinput = new TypedInput({
			props: {
				types: /*param*/ ctx[31].allowedTypes,
				type: /*param*/ ctx[31].type,
				value: /*param*/ ctx[31].value,
				id: /*param*/ ctx[31].id,
				disabled: !/*param*/ ctx[31].isActive
			}
		});

	typedinput.$on("change", change_handler_1);
	let if_block = /*param*/ ctx[31]?.schema?.type === "object" && create_if_block_1(ctx);

	return {
		c() {
			div = element("div");
			create_component(input.$$.fragment);
			t0 = space();
			create_component(typedinput.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			toggle_class(div, "required", /*param*/ ctx[31].required);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(input, div, null);
			insert(target, t0, anchor);
			mount_component(typedinput, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};
			if (dirty[1] & /*param*/ 1) input_changes.label = /*param*/ ctx[31].name + ": " + /*param*/ ctx[31].description;
			if (dirty[1] & /*param*/ 1) input_changes.value = /*param*/ ctx[31].isActive;
			if (dirty[1] & /*param*/ 1) input_changes.disabled = /*param*/ ctx[31].required;
			input.$set(input_changes);

			if (dirty[1] & /*param*/ 1) {
				toggle_class(div, "required", /*param*/ ctx[31].required);
			}

			const typedinput_changes = {};
			if (dirty[1] & /*param*/ 1) typedinput_changes.types = /*param*/ ctx[31].allowedTypes;
			if (dirty[1] & /*param*/ 1) typedinput_changes.type = /*param*/ ctx[31].type;
			if (dirty[1] & /*param*/ 1) typedinput_changes.value = /*param*/ ctx[31].value;
			if (dirty[1] & /*param*/ 1) typedinput_changes.id = /*param*/ ctx[31].id;
			if (dirty[1] & /*param*/ 1) typedinput_changes.disabled = !/*param*/ ctx[31].isActive;
			typedinput.$set(typedinput_changes);

			if (/*param*/ ctx[31]?.schema?.type === "object") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[1] & /*param*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(typedinput.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(typedinput.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(input);
			if (detaching) detach(t0);
			destroy_component(typedinput, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let t0;
	let collapsible0;
	let t1;
	let collapsible1;
	let t2;
	let div;
	let t6;
	let current_block_type_index;
	let if_block1;
	let if_block1_anchor;
	let current;
	let if_block0 = /*error*/ ctx[5] && create_if_block_12(ctx);

	collapsible0 = new Collapsible({
			props: {
				label: "General",
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			}
		});

	collapsible1 = new Collapsible({
			props: {
				label: "Api options",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*node*/ ctx[0].parameters.length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_4(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			create_component(collapsible0.$$.fragment);
			t1 = space();
			create_component(collapsible1.$$.fragment);
			t2 = space();
			div = element("div");

			div.innerHTML = `<span class="label">Parameters</span> 
  <span class="required" style="font-size: 10px;">(bold = required parameters)</span>`;

			t6 = space();
			if_block1.c();
			if_block1_anchor = empty();
			set_style(div, "display", "flex");
			set_style(div, "justify-content", "space-between");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			mount_component(collapsible0, target, anchor);
			insert(target, t1, anchor);
			mount_component(collapsible1, target, anchor);
			insert(target, t2, anchor);
			insert(target, div, anchor);
			insert(target, t6, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*error*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*error*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const collapsible0_changes = {};

			if (dirty[0] & /*node, servers*/ 17 | dirty[1] & /*$$scope*/ 1048576) {
				collapsible0_changes.$$scope = { dirty, ctx };
			}

			collapsible0.$set(collapsible0_changes);
			const collapsible1_changes = {};

			if (dirty[0] & /*init, node, responseContentTypes, requestContentTypes, showDescription, operationDescription, operations, apis*/ 975 | dirty[1] & /*$$scope*/ 1048576) {
				collapsible1_changes.$$scope = { dirty, ctx };
			}

			collapsible1.$set(collapsible1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(collapsible0.$$.fragment, local);
			transition_in(collapsible1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(collapsible0.$$.fragment, local);
			transition_out(collapsible1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			destroy_component(collapsible0, detaching);
			if (detaching) detach(t1);
			destroy_component(collapsible1, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(div);
			if (detaching) detach(t6);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

RED.nodes.registerType("openApi-red", {
	category: "network",
	color: "#b197ff",
	defaults: {
		name: { value: "", label: "Name" },
		openApiUrl: { value: "", label: "URL" },
		api: { value: "", label: "API tag" },
		server: { value: "" },
		alternServer: { value: false, label: "Use server option" },
		operation: { value: "", label: "Operation" },
		operationData: { value: {} },
		errorHandling: { value: "", label: "Error handling" },
		parameters: {
			value: [],
			label: "Parameters",
			validate(parameters) {
				if (!parameters || !Array.isArray(parameters) || parameters.length === 0) {
					return true;
				} else {
					let isValid = true;

					parameters.forEach(p => {
						if (isValid && p.isActive) {
							if (p.required && p.value.trim() === "") isValid = false;

							// validation of typedinput only if element exists!
							if (isValid && window.$("#node-input-" + p.id).length) isValid = window.$("#node-input-" + p.id).typedInput("validate");
						}
					});

					return isValid;
				}
			}
		},
		requestContentType: { value: "", label: "Request Content Type" },
		responseContentType: {
			value: "",
			label: "Response Content Type"
		},
		outputs: { value: 1 }
	},
	inputs: 1,
	outputs: 1,
	icon: "white-globe.png",
	label() {
		if (this.name) return this.name; else if (this.operation) return this.operation; else return "openApi client";
	},
	oneditprepare() {
		render(this);
	},
	oneditsave() {
		let clone = this.__clone;

		// Workaround if JSON-Editor (ACE) was used -> more info in bottom code (on:change event for typedInput Parameters)
		if (clone.saveTypedInputAgain) {
			clone.saveTypedInputAgain.forEach(({ index, id }) => {
				clone.parameters[index].value = window.$("#node-input-" + id).typedInput("value");
			});
		}

		update(this);
	},
	oneditcancel() {
		revert(this);
	}
});

function instance($$self, $$props, $$invalidate) {
	let { node } = $$props;
	let openApiSpec = {};
	let apiList = {};
	let servers = [];
	let error = "";
	let apis = [];
	let operations = {};
	let operationDescription = "-";
	let prevOperation;
	if (node.operation) prevOperation = node.operation.toString();
	node.saveTypedInputAgain = [];
	let requestContentTypes = [];
	let responseContentTypes = []; // not a Set as svelte #each may have a problem?
	let oldParameters = {};
	let showDescription = true;

	// backward compatibility
	if (typeof node.requestContentType === 'undefined') node.requestContentType = node.contentType;

	if (typeof node.responseContentType === 'undefined') node.responseContentType = '';
	if (typeof node.alternServer === 'undefined') node.alternServer = false;

	const setError = message => {
		$$invalidate(6, apis = []);
		$$invalidate(7, operations = {});
		$$invalidate(2, requestContentTypes = []);
		$$invalidate(3, responseContentTypes = []);
		if (typeof message !== "string") message = JSON.stringify(message);
		$$invalidate(5, error = message);
		return;
	};

	const init = true;

	const createApi = async () => {
		try {
			$$invalidate(5, error = "");
			openApiSpec = await getOpenApiSpec(node.openApiUrl);

			// if a string was returned it is a node error
			if (typeof openApiSpec === "string") {
				setError(openApiSpec);
			} else {
				$$invalidate(12, apiList = openApiSpec.apiList);
				$$invalidate(4, servers = openApiSpec.servers || []);
				if (servers.length <= 1) $$invalidate(0, node.server = "", node);

				// save old parameter objects (openApi-red version <0.2) - changed from object to array objects
				if (!Array.isArray(node.parameters) && node.api && node.operation) {
					Object.assign(oldParameters, node.parameters);
					$$invalidate(0, node.parameters = [], node);
					$$invalidate(13, prevOperation = "");
					$$invalidate(0, node.operationData = apiList?.[node.api]?.[node.operation], node);
				}

				$$invalidate(6, apis = Object.keys(apiList));
			}
		} catch(e) {
			setError(e);
		}

		$$invalidate(9, init = false);
	};

	if (node.openApiUrl.toString().trim()) createApi();
	const errorHandlingOptions = ["Standard", "other output", "throw exception"];

	function input_node_binding(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function input_node_binding_1(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function select_node_binding(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function input_node_binding_2(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function select_node_binding_1(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function select0_node_binding(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function select1_node_binding(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function callout_show_binding(value) {
		showDescription = value;
		$$invalidate(8, showDescription);
	}

	const click_handler = () => $$invalidate(8, showDescription = !showDescription);

	function select2_node_binding(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	function select_node_binding_2(value) {
		node = value;
		(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
	}

	const change_handler = (index, e) => $$invalidate(0, node.parameters[index].isActive = e.detail.value, node);

	const change_handler_1 = (index, param, e) => {
		// if JSON-Editor (ACE) is used, it will return "[object Object]" as value, but set the correct JSON in the input field.
		// This seems to be a bug which occurs to non default fields and SIR. As non default fields will not be saved automaticlly (and this is a correct behavior)
		// we must use a workaround and don"t save the value with the on:change event but save it when the node will be closed.
		if (typeof e.detail.value !== "object" && e.detail.value.toString() !== "[object Object]") {
			$$invalidate(0, node.parameters[index].value = e.detail.value, node);
			$$invalidate(0, node.parameters[index].type = e.detail.type, node);
		} else {
			// within the change event window.$("#node-input-" + id).typedInput("value") would also return the wrong value
			node.saveTypedInputAgain.push({ index, "id": param.id });
		}
	};

	function editablelist_elements_binding(value) {
		if ($$self.$$.not_equal(node.parameters, value)) {
			node.parameters = value;
			(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
		}
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*node, apiList*/ 4097) {
			// set valid operations if api is set
			if (node.api && apiList?.[node.api]) {
				$$invalidate(7, operations = apiList[node.api]);
				(((((($$invalidate(0, node), $$invalidate(12, apiList)), $$invalidate(1, operationDescription)), $$invalidate(3, responseContentTypes)), $$invalidate(2, requestContentTypes)), $$invalidate(13, prevOperation)), $$invalidate(29, oldParameters));
			} else {
				$$invalidate(7, operations = {});
			}
		}

		if ($$self.$$.dirty[0] & /*apiList, node, operationDescription, responseContentTypes, requestContentTypes, prevOperation*/ 12303) {
			// create content type selection and parameter list
			if (Object.keys(apiList).length && node.operation) {
				$$invalidate(1, operationDescription = "-");

				if (apiList?.[node.api]?.[node.operation]?.description) {
					$$invalidate(1, operationDescription = apiList[node.api][node.operation].description);

					// sanitize html
					const denyList = ["script", "object", "embed", "link"];

					denyList.forEach(d => {
						const searchParam = new RegExp('<\/?' + d + '>', 'gm');
						$$invalidate(1, operationDescription = operationDescription.replace(searchParam, '"<"' + d + '">"'));
					});
				}

				// set valid content Types if operation is set
				const operationSchema = apiList?.[node.api]?.[node.operation];

				if (operationSchema?.requestBody?.content) {
					$$invalidate(2, requestContentTypes = Object.keys(operationSchema.requestBody.content));
				} else {
					// needed input since an update from swagger.js
					$$invalidate(2, requestContentTypes = [
						"application/json",
						"application/x-www-form-urlencoded",
						"multipart/form-data"
					]);
				}

				if (operationSchema?.responses) {
					const responseKeys = Object.keys(operationSchema.responses);

					responseKeys.forEach(r => {
						if (operationSchema.responses[r]?.content) {
							const contentTypes = Object.keys(operationSchema.responses[r].content);
							contentTypes?.forEach(cT => responseContentTypes.push(cT));
						}
					});
				}

				if (!responseContentTypes.length) {
					$$invalidate(0, node.responseContentType = "", node);
				} else {
					// distinct array
					$$invalidate(3, responseContentTypes = Array.from(new Set(responseContentTypes)));
				}

				if (!node.contentType || !requestContentTypes.includes(node.contentType)) {
					$$invalidate(0, node.contentType = requestContentTypes[0], node);
				}

				// clear parameters if operation has changed
				if (prevOperation !== node.operation) {
					node.parameters.splice(0, node.parameters.length);
					$$invalidate(13, prevOperation = node.operation);
					let operationData = apiList?.[node.api]?.[node.operation];
					if (!operationData) operationData = {};
					$$invalidate(0, node.operationData = operationData, node);
					createParameters(node, operationData, oldParameters);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*node*/ 1) {
			if (node.errorHandling) {
				if ("other output" === node.errorHandling) $$invalidate(0, node.outputs = 2, node); else $$invalidate(0, node.outputs = 1, node);
			}
		}
	};

	return [
		node,
		operationDescription,
		requestContentTypes,
		responseContentTypes,
		servers,
		error,
		apis,
		operations,
		showDescription,
		init,
		createApi,
		errorHandlingOptions,
		apiList,
		prevOperation,
		input_node_binding,
		input_node_binding_1,
		select_node_binding,
		input_node_binding_2,
		select_node_binding_1,
		select0_node_binding,
		select1_node_binding,
		callout_show_binding,
		click_handler,
		select2_node_binding,
		select_node_binding_2,
		change_handler,
		change_handler_1,
		editablelist_elements_binding
	];
}

class OpenApi_red extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { node: 0 }, add_css, [-1, -1]);
	}
}



              }
            </script>
            <script type="text/x-red" data-template-name="openApi-red">
              <div id='openApi-red-svelte-container'></div>
            </script>
            <script type="text/x-red" data-help-name="openApi-red">
                <p>Use OpenAPI / Swagger with Node-Red.</p>
<h3>Inputs</h3>
    <dl class="message-properties">
        <dt>Name
            <span class="property-type">string</span>
        </dt>
        <dd> set a manuell name for the node. If no name is set, the node sets the selected operation name.</dd>
        <dt>URL
            <span class="property-type">string</span>
        </dt>
        <dd> set the full url domain name (incl. http:// / https://) for the OpenAPI document. By clicking on 'read' it will build the API and operation Selectors.</dd>
        <dt>API tag
            <span class="property-type">enum</span>
        </dt>
        <dd> Preselector for the operation. Grouped by the 'tags' in each operation. </dd>
        <dt>Operation
            <span class="property-type">enum</span>
        </dt>
        <dd> Selector for the OpenAPI operation. The selection name is set by the 'summary'. Behind the selector field is the (unique) operation id. By mouse-over it will show the full operation Description.</dd>
        <dt class="optional">Parameters <span class="property-type">depending</span></dt>
        <dd> If the selected operation has parameters, they will be listed here. The description can be found by mouse-over the parameter name. If the parameter is required, it will be marked with a red star behind the name.
            For Json Objects with defined keys there will be 3 Buttons: 'set required' and 'set default' will build a json-object with the correct key names and the necessary type info as the value. 'show keys' show all possible key parameters with additional info by mouse-over the key name.
        </dd>
        <dt>Request / Response content type
          <span class="property-type">selection</span>
      </dt>
      <dd> If available select the content type in which you will send / receive the data. For the most cases 'application/json' will be a good choice.</dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
    <dt>Payload <span class="property-type">object</span>
        <dd> Returns the complete OpenAPI object.</dd>
    </dt>
    </dl>

<h3>Authentification</h3>
    For authentification you can use the Node-Red to get your token. This token has to be set into msg.openApiToken.

<h3>Dynamic fields</h3>
For using dynamic OpenApi URL, operation or parameter put those into msg.openApiUrl (string), msg.operation (operationId as string) and msg.parameters (object with key as parameter name). 

<h3>Error handling</h3>
This handles how to react if the server returns a http status of 4xx or 5xx. You can find the last server response in msg.response.
<dl class="message-properties">
    <dt>Standard  <span class="property-type">string</span> </dt>
    <dd> The flow will move on normally so you can choose how to handle this within your flow.</dd>
    <dt> Other output <span class="property-type">string</span></dt>
    <dd> The flow will move on in a second output.</dd>
    <dt> Throw exception <span class="property-type">string</span></dt>
    <dd> The flow will throw an exception. This exception can be catched by the 'catch' node.</dd>
</dl>

<h3>References</h3>
    <ul>
        <li><a href="https://www.npmjs.com/package/swagger-client">Based on npm swagger-client</a> - which does almost all the magic here</li>
        <li><a href="https://gitlab.com/2WeltenChris/svelte-integration-red">SIR</a> - Node designed with svelte</li>
        <li><a href="https://gitlab.com/2WeltenChris/openapi-red">GitHub</a> - the nodes github repository</li>
    </ul>

            </script>
        