
            <script type='text/javascript'>
              {
                function render (node, options) {
                  try {
                    if (typeof node !== 'object') {
                      return
                    }
                    let minWidth = '400px'
                    if (options) {
                      if (options.minWidth) minWidth = options.minWidth
                    }
                    if (!node.__clone) {
                      node.__clone = window.$.extend(true, {}, node)
                    }
                    new OpenApi_red({
                      target: document.getElementById('openApi-red-svelte-container'),
                      props: { node: node.__clone }
                    })
                    document.getElementById('openApi-red-svelte-container').style.width = minWidth
                    const nodeIsSidebarTab = !!node.onchange
                    if (!nodeIsSidebarTab) {
                      const orgResize = node._def.oneditresize
                      node._def.oneditresize = function (size) {
                        document.getElementById('openApi-red-svelte-container').style.width = 'auto'
                        if (orgResize) orgResize(size)
                        node._def.oneditresize = orgResize
                      }
                    }
                  } catch (e) {
                      console.log(e)
                  }
                }
                function update (node) {
                  if (node.__clone) {
                    const clone = node.__clone
                    delete node.__clone
                    const defaultKeys = Object.keys(node._def.defaults)
                    for (const key of Object.keys(clone)) {
                      if (defaultKeys.indexOf(key) === -1) {
                        delete clone[key]
                      }
                    }
                    Object.assign(node, clone)
                  }
                }
                function revert (node) {
                  delete node.__clone
                }
                function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    if (value === null) {
        node.style.removeProperty(key);
    }
    else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
class HtmlTag {
    constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            if (this.is_svg)
                this.e = svg_element(target.nodeName);
            else
                this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
const managed_styles = new Map();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_style_information(doc, node) {
    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
    managed_styles.set(doc, info);
    return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
    if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        managed_styles.forEach(info => {
            const { stylesheet } = info;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            info.rules = {};
        });
        managed_styles.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update$1(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update$1($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const getBooleanFrom = (property) => {
  return typeof property === 'boolean' ? property : property.toString().toLowerCase() === 'true'
};

const getId = (prop = null) => {
  let id = prop;
  if (!id) {
    id = Date.now() + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
  }
  return id
};

const getFadeDuration = (fading) => {
  let fadeDuration = 800;
  // do not use isNaN with boolean!
  if (typeof fading === 'number' || (typeof fading === 'string' && fading !== 'true' && fading !== 'false')) {
    fadeDuration = Number(fading);
  } else {
    fading = getBooleanFrom(fading);
    if (!fading) fadeDuration = 0;
  }
  return fadeDuration
};

const setInternalValue = (internal, nodeProp, value) => {
  // value must not be undefined, as that can result in strange behaviour but can have other falsy value types (checkbox = false, number = 0)
  if (internal.updateNode && typeof nodeProp !== 'undefined') {
    return nodeProp
  } else if (typeof value !== 'undefined') {
    return value
  } else {
    return ''
  }
};

const initInternal = (nodeProp, value) => {
  const internal = {
    init: true,
    isError: false,
    updateNode: typeof nodeProp !== 'undefined',
    valueHasChanged: false
  };
  internal.value = setInternalValue(internal, nodeProp, value);
  internal.oldValue = internal.value;
  return internal
};

const getNewInternal = (nodeProp, value, internal, validateFunction, error) => {
  internal.valueHasChanged = internal.updateNode ? nodeProp !== internal.value : internal.value !== value;
  if (internal.valueHasChanged) {
    if (internal.value === internal.oldValue) {
      internal.value = setInternalValue(internal, nodeProp, value);
    }
    internal.oldValue = internal.value;
  }
  if (validateFunction) {
    internal.isError = !validateFunction(internal.value);
  } else {
    internal.isError = error;
  }
  return internal
};

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* node_modules/svelte-integration-red/components/Row.svelte generated by Svelte v3.44.2 */

function add_css$g(target) {
	append_styles(target, "svelte-njf2hk", ".sir-Row.svelte-njf2hk{clear:both;margin-bottom:12px;display:flex;align-items:center;justify-content:flex-start}.sir-Row > *:not(:last-child){margin-right:7px}.sir-Row.inline button:not(:last-child){margin-right:3px}.sir-Row label{display:inline-block;min-width:105px;width:105px;margin-right:7px;align-items:center;margin-bottom:0px;overflow-wrap:break-word}i, .sir-Row, .sir-Row label{user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}");
}

// (53:0) {:else}
function create_else_block$7(ctx) {
	let div;
	let t;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*indented*/ ctx[2] && create_if_block_2$a(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"));
			attr(div, "style", /*style*/ ctx[4]);
			toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler_1*/ ctx[14]),
					listen(div, "dblclick", /*dblclick_handler_1*/ ctx[15]),
					listen(div, "mouseenter", /*mouseenter_handler_1*/ ctx[16]),
					listen(div, "mouseleave", /*mouseleave_handler_1*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$a(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*clazz*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*clazz, inline*/ 10) {
				toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (46:0) {#if fadeDuration}
function create_if_block$h(ctx) {
	let div;
	let t;
	let div_class_value;
	let div_intro;
	let current;
	let mounted;
	let dispose;
	let if_block = /*indented*/ ctx[2] && create_if_block_1$e(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "id", /*id*/ ctx[0]);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"));
			attr(div, "style", /*style*/ ctx[4]);
			toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*click_handler*/ ctx[10]),
					listen(div, "dblclick", /*dblclick_handler*/ ctx[11]),
					listen(div, "mouseenter", /*mouseenter_handler*/ ctx[12]),
					listen(div, "mouseleave", /*mouseleave_handler*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*indented*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$e(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr(div, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*clazz*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[3]) + " svelte-njf2hk"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*clazz, inline*/ 10) {
				toggle_class(div, "sir-Row", !/*inline*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fade, { duration: /*fadeDuration*/ ctx[5] });
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (55:4) {#if indented}
function create_if_block_2$a(ctx) {
	let label;

	return {
		c() {
			label = element("label");
			attr(label, "for", /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

// (48:4) {#if indented}
function create_if_block_1$e(ctx) {
	let label;

	return {
		c() {
			label = element("label");
			attr(label, "for", /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

function create_fragment$j(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$h, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*fadeDuration*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id, clazz = '', style = "", inline = false, maximize = false, indented = false, fading = true } = $$props;
	id = id || getId();
	if (!id.toString().startsWith("sir-")) id = "sir-Row-" + id;
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	indented = getBooleanFrom(indented);
	const fadeDuration = getFadeDuration(fading);

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('clazz' in $$props) $$invalidate(3, clazz = $$props.clazz);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('inline' in $$props) $$invalidate(1, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('indented' in $$props) $$invalidate(2, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(7, fading = $$props.fading);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		id,
		inline,
		indented,
		clazz,
		style,
		fadeDuration,
		maximize,
		fading,
		$$scope,
		slots,
		click_handler,
		dblclick_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler_1,
		dblclick_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1
	];
}

class Row extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$j,
			create_fragment$j,
			safe_not_equal,
			{
				id: 0,
				clazz: 3,
				style: 4,
				inline: 1,
				maximize: 6,
				indented: 2,
				fading: 7
			},
			add_css$g
		);
	}
}

/* global localStorage, */

// Translation:
// current way with Node-RED tools:
// - an i18nOptions object for the node where we can set a prefix if the Node-Red node is not in the main folder.
// - to translate in a SIR component object just set the node property and set the path within the json file, e.g.: label:{ label.name }.
// - instead of giving the node property you can set an i18n property with the path to the local folder, e.g.: 'test-node/second-node:' or if in the main folder: 'second-node:'
//
// a different approach to the code below is to use the offical way like:
// - direct i18n in html <span data-i18n="test-node/second-node:second-node.label.name"></span>
// - setting to placeholder prop <input type="text" data-i18n="[placeholder]myNode.placeholder.foo">
//
// Sidenote: This translation is only working for custom nodes. Translations for the sir components are within their files.
// This must be done that way, as we must ensure translation, whether SIR is installed or not. Also it seems that Node-Red only initialize translation files
// for nodes registered in the package.json.
// Addition: Since Node-Red 2.0.3 we can't import i18next as this will break all other translations.

localStorage.getItem('editor-language') || navigator.language || 'en-US';

const i18nTranslate = (RED, node = {}, i18nDOM = true, translateThis) => {
  let result = translateThis;
  // i18n can be a string for the local folder path (which we can't have without node) or boolean false if we don't want to translate this one
  if (i18nDOM === false || i18nDOM.toString().trim() === 'false') {
    return result
  }

  let path = '';
  if (typeof i18nDOM === 'string') {
    path = i18nDOM;
  } else if (node) {
    path = node.type;
    let folder = node?._def?.i18nOptions?.folder;
    if (folder) {
      if (!folder.endsWith('/')) {
        folder += '/';
      }
      path = folder + path;
    }
  }
  if (path) {
    if (!path.endsWith(':')) path += ':';
    result = RED._(path + translateThis);
    // RED._() will replace colon with dot, so we have to check if result is like that pattern
    const translateColonReplacedWithDot = translateThis.replaceAll(':', '.');
    if (result === path + translateThis || result === path + translateColonReplacedWithDot || result === translateColonReplacedWithDot) {
      // couldn't find translation
      result = translateThis;
    }
  }
  return result
};

/* node_modules/svelte-integration-red/components/Button.svelte generated by Svelte v3.44.2 */

function add_css$f(target) {
	append_styles(target, "svelte-1ly0frp", ".sir-Button.svelte-1ly0frp{width:fit-content}.minWidth.svelte-1ly0frp{min-width:33px}.red-ui-button-small.svelte-1ly0frp{min-width:21px}button.red-ui-button.sir-Button:not(.primary):not(.disabled):not(:disabled):hover{background:var(--red-ui-secondary-background-hover)}.maximize.svelte-1ly0frp{width:100%}");
}

// (42:2) {#if indented}
function create_if_block_1$d(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (48:4) {#if icon}
function create_if_block$g(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-1ly0frp");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 512 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[9] + " svelte-1ly0frp")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (41:0) <Row id="sir-Button-Container-{id}" clazz="{clazz} sir-Button-Container" {inline} {fading}>
function create_default_slot$c(ctx) {
	let t0;
	let button;
	let t1;
	let t2_value = (/*label*/ ctx[0] || '') + "";
	let t2;
	let mounted;
	let dispose;
	let if_block0 = /*indented*/ ctx[3] && create_if_block_1$d();
	let if_block1 = /*icon*/ ctx[9] && create_if_block$g(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			button = element("button");
			if (if_block1) if_block1.c();
			t1 = space();
			t2 = text(t2_value);
			attr(button, "id", /*id*/ ctx[2]);
			attr(button, "style", /*style*/ ctx[12]);
			button.disabled = /*disabled*/ ctx[1];
			attr(button, "type", "button");
			attr(button, "class", "red-ui-button sir-Button svelte-1ly0frp");
			toggle_class(button, "maximize", /*maximize*/ ctx[5]);
			toggle_class(button, "selected", /*selected*/ ctx[11]);
			toggle_class(button, "red-ui-button-small", /*small*/ ctx[6]);
			toggle_class(button, "primary", /*primary*/ ctx[10] && !/*disabled*/ ctx[1]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, button, anchor);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			append(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", /*clickHandler*/ ctx[13]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[3]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1$d();
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$g(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*label*/ 1 && t2_value !== (t2_value = (/*label*/ ctx[0] || '') + "")) set_data(t2, t2_value);

			if (dirty & /*id*/ 4) {
				attr(button, "id", /*id*/ ctx[2]);
			}

			if (dirty & /*style*/ 4096) {
				attr(button, "style", /*style*/ ctx[12]);
			}

			if (dirty & /*disabled*/ 2) {
				button.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*maximize*/ 32) {
				toggle_class(button, "maximize", /*maximize*/ ctx[5]);
			}

			if (dirty & /*selected*/ 2048) {
				toggle_class(button, "selected", /*selected*/ ctx[11]);
			}

			if (dirty & /*small*/ 64) {
				toggle_class(button, "red-ui-button-small", /*small*/ ctx[6]);
			}

			if (dirty & /*primary, disabled*/ 1026) {
				toggle_class(button, "primary", /*primary*/ ctx[10] && !/*disabled*/ ctx[1]);
			}
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(button);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$i(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Button-Container-" + /*id*/ ctx[2],
				clazz: "" + (/*clazz*/ ctx[7] + " sir-Button-Container"),
				inline: /*inline*/ ctx[4],
				fading: /*fading*/ ctx[8],
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 4) row_changes.id = "sir-Button-Container-" + /*id*/ ctx[2];
			if (dirty & /*clazz*/ 128) row_changes.clazz = "" + (/*clazz*/ ctx[7] + " sir-Button-Container");
			if (dirty & /*inline*/ 16) row_changes.inline = /*inline*/ ctx[4];
			if (dirty & /*fading*/ 256) row_changes.fading = /*fading*/ ctx[8];

			if (dirty & /*$$scope, id, style, disabled, maximize, selected, small, primary, label, icon, indented*/ 138863) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { clazz = '', disabled = false, fading = true, i18n, icon, id, indented = false, inline = false, label, maximize = false, node, primary = false, selected = false, small = false, style = "" } = $$props;
	small = getBooleanFrom(small);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);
	id = id || getId();
	if (label) label = i18nTranslate(RED, node, i18n, label);
	const dispatch = createEventDispatcher();

	function clickHandler(event) {
		dispatch('click', event.details, { cancelable: true });
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(7, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(8, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(9, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('indented' in $$props) $$invalidate(3, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(4, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(15, node = $$props.node);
		if ('primary' in $$props) $$invalidate(10, primary = $$props.primary);
		if ('selected' in $$props) $$invalidate(11, selected = $$props.selected);
		if ('small' in $$props) $$invalidate(6, small = $$props.small);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*label, node, i18n*/ 49153) {
			{
				if (label) {
					$$invalidate(0, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}
	};

	return [
		label,
		disabled,
		id,
		indented,
		inline,
		maximize,
		small,
		clazz,
		fading,
		icon,
		primary,
		selected,
		style,
		clickHandler,
		i18n,
		node
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$i,
			create_fragment$i,
			safe_not_equal,
			{
				clazz: 7,
				disabled: 1,
				fading: 8,
				i18n: 14,
				icon: 9,
				id: 2,
				indented: 3,
				inline: 4,
				label: 0,
				maximize: 5,
				node: 15,
				primary: 10,
				selected: 11,
				small: 6,
				style: 12
			},
			add_css$f
		);
	}
}

/* node_modules/svelte-integration-red/components/Callout.svelte generated by Svelte v3.44.2 */

function add_css$e(target) {
	append_styles(target, "svelte-13nhx2a", ".sir-Row.sir-Callout{display:flex;align-items:center;margin-bottom:12px;border-left-width:5px;border-left-style:solid;border-left-color:#7e7e7e;background-color:#e4e4e4;color:#202020}.sir-Row.sir-Callout.indented{margin-left:112px}.sir-Callout-icon.svelte-13nhx2a.svelte-13nhx2a{padding-left:30px;margin-right:0px}.sir-Callout-icon.svelte-13nhx2a i.svelte-13nhx2a{font-size:3em;min-width:50px}.sir-Callout-icon-small.svelte-13nhx2a.svelte-13nhx2a{padding-left:10px;margin-right:7px}.sir-Callout-icon-small.svelte-13nhx2a i.svelte-13nhx2a{font-size:1.5em;min-width:25px}.sir-Callout-content.svelte-13nhx2a.svelte-13nhx2a{padding:15px 7px}.sir-Callout-content-small.svelte-13nhx2a.svelte-13nhx2a{padding:3px}.sir-Callout-content :is(p, div, span):last-child{padding-bottom:0px;margin-bottom:0px}.hasButton.svelte-13nhx2a.svelte-13nhx2a{padding-right:5px}.close-button.svelte-13nhx2a.svelte-13nhx2a{margin-bottom:auto;margin-left:auto;margin-top:6px;margin-right:6px}.close-button-small.svelte-13nhx2a.svelte-13nhx2a{margin-left:auto;margin-right:6px}.close-button-small.svelte-13nhx2a .sir-Button-Container.svelte-13nhx2a{margin-bottom:0px}.sir-Row.sir-Callout.info{border-left-color:#325c80;background-color:#def0ff;color:#325c80}.sir-Row.sir-Callout.warning{border-left-color:var(--red-ui-border-color-warning);color:var(--red-ui-text-color-warning)}.sir-Row.sir-Callout.error{border-left-color:var(--red-ui-border-color-error);color:var(--red-ui-text-color-error)}.sir-Row.sir-Callout.success{border-left-color:var(--red-ui-border-color-success);color:var(--red-ui-text-color-success)}.sir-Callout :is(h1, h2, h3, h4, h5, h6){margin-top:0px;margin-bottom:10px\n  }.sir-Callout.sir-Row{user-select:text;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text}");
}

const get_header_slot_changes$3 = dirty => ({});
const get_header_slot_context$3 = ctx => ({});

// (145:0) {#if show}
function create_if_block$f(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Callout-" + /*id*/ ctx[3],
				clazz: /*clazz*/ ctx[8] + " sir-Callout " + /*type*/ ctx[0] + (/*indented*/ ctx[4] ? ' indented' : ''),
				style: /*style*/ ctx[6],
				fading: /*fading*/ ctx[9],
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty & /*id*/ 8) row_changes.id = "sir-Callout-" + /*id*/ ctx[3];
			if (dirty & /*clazz, type, indented*/ 273) row_changes.clazz = /*clazz*/ ctx[8] + " sir-Callout " + /*type*/ ctx[0] + (/*indented*/ ctx[4] ? ' indented' : '');
			if (dirty & /*style*/ 64) row_changes.style = /*style*/ ctx[6];
			if (dirty & /*fading*/ 512) row_changes.fading = /*fading*/ ctx[9];

			if (dirty & /*$$scope, small, show, closeable, $$slots, icon*/ 34982) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

// (149:6) {#if $$slots.header}
function create_if_block_2$9(ctx) {
	let h2;
	let current;
	const header_slot_template = /*#slots*/ ctx[13].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[15], get_header_slot_context$3);

	return {
		c() {
			h2 = element("h2");
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			insert(target, h2, anchor);

			if (header_slot) {
				header_slot.m(h2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[15], dirty, get_header_slot_changes$3),
						get_header_slot_context$3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (154:4) {#if closeable}
function create_if_block_1$c(ctx) {
	let div;
	let button;
	let div_class_value;
	let current;

	button = new Button({
			props: { icon: "close", small: /*small*/ ctx[7] }
		});

	button.$on("click", /*click_handler*/ ctx[14]);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*sizeClasses*/ ctx[10].close) + " svelte-13nhx2a"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*small*/ 128) button_changes.small = /*small*/ ctx[7];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (146:2) <Row id="sir-Callout-{id}" clazz={clazz + " sir-Callout " + type + (indented ? ' indented' : '')} {style} {fading}>
function create_default_slot$b(ctx) {
	let div0;
	let i;
	let i_class_value;
	let t0;
	let div1;
	let t1;
	let t2;
	let if_block1_anchor;
	let current;
	let if_block0 = /*$$slots*/ ctx[11].header && create_if_block_2$9(ctx);
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	let if_block1 = /*closeable*/ ctx[1] && create_if_block_1$c(ctx);

	return {
		c() {
			div0 = element("div");
			i = element("i");
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(i, "class", i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-13nhx2a"));
			attr(div0, "class", "" + (null_to_empty(/*sizeClasses*/ ctx[10].icon) + " svelte-13nhx2a"));
			attr(div1, "class", "" + (null_to_empty(/*sizeClasses*/ ctx[10].content) + " svelte-13nhx2a"));
			toggle_class(div1, "hasButton", /*closeable*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, i);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "" + (null_to_empty(/*icon*/ ctx[2]) + " svelte-13nhx2a"))) {
				attr(i, "class", i_class_value);
			}

			if (/*$$slots*/ ctx[11].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$$slots*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$9(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null),
						null
					);
				}
			}

			if (dirty & /*closeable*/ 2) {
				toggle_class(div1, "hasButton", /*closeable*/ ctx[1]);
			}

			if (/*closeable*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*closeable*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$c(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$h(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*show*/ ctx[5] && create_if_block$f(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*show*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*show*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$f(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { clazz = "", closeable = false, fading = true, icon, id, indented = false, show = true, type = 'info', style = "", small = false } = $$props;
	id = id || getId();
	indented = getBooleanFrom(indented);
	closeable = getBooleanFrom(closeable);
	show = getBooleanFrom(show);
	small = getBooleanFrom(small);
	if (type === 'danger') type = 'error';
	let customIcon = false;

	if (icon) {
		customIcon = true;
		icon = icon.trim();

		if (!icon.startsWith('fa fa-')) {
			if (icon.startsWith('fa-')) icon = 'fa ' + icon; else icon = 'fa fa-' + icon;
		}
	}

	let sizeClasses = {
		"icon": small ? "sir-Callout-icon-small" : "sir-Callout-icon",
		"content": small
		? "sir-Callout-content-small"
		: "sir-Callout-content",
		"close": small ? "close-button-small" : "close-button"
	};

	// get the background color by root variable and reduce opacity
	// if background root variable is one day not hex anymore, use rgba(var(--red-ui-border-color-warning), 0.2) in css directly
	if (type === 'warning' || type === 'success' || type === 'error') {
		const r = document.querySelector(':root');
		let backgroundColor = getComputedStyle(r).getPropertyValue('--red-ui-text-color-' + type).trim();

		if (backgroundColor.startsWith('#')) {
			if (backgroundColor.length === 4) {
				// double all digits except the '#'
				backgroundColor = backgroundColor.split('').map(hex => hex + hex).join('').substring(1);
			}

			style = 'background-color: ' + backgroundColor + 20 + '; ' + style;
		}
	}

	const click_handler = () => $$invalidate(5, show = false);

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(8, clazz = $$props.clazz);
		if ('closeable' in $$props) $$invalidate(1, closeable = $$props.closeable);
		if ('fading' in $$props) $$invalidate(9, fading = $$props.fading);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('indented' in $$props) $$invalidate(4, indented = $$props.indented);
		if ('show' in $$props) $$invalidate(5, show = $$props.show);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('small' in $$props) $$invalidate(7, small = $$props.small);
		if ('$$scope' in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*customIcon, type*/ 4097) {
			{
				if (!customIcon) {
					switch (type) {
						case 'info':
							$$invalidate(2, icon = 'fa fa-info-circle');
							break;
						case 'warning':
							$$invalidate(2, icon = 'fa fa-exclamation-triangle');
							break;
						case 'error':
							$$invalidate(2, icon = 'fa fa-window-close');
							break;
						case 'success':
							$$invalidate(2, icon = 'fa fa-check-circle');
							break;
						default:
							$$invalidate(2, icon = 'fa fa-info-circle');
					}
				}
			}
		}
	};

	return [
		type,
		closeable,
		icon,
		id,
		indented,
		show,
		style,
		small,
		clazz,
		fading,
		sizeClasses,
		$$slots,
		customIcon,
		slots,
		click_handler,
		$$scope
	];
}

class Callout extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$h,
			create_fragment$h,
			safe_not_equal,
			{
				clazz: 8,
				closeable: 1,
				fading: 9,
				icon: 2,
				id: 3,
				indented: 4,
				show: 5,
				type: 0,
				style: 6,
				small: 7
			},
			add_css$e
		);
	}
}

/* node_modules/svelte-integration-red/components/ComponentHeader.svelte generated by Svelte v3.44.2 */

function add_css$d(target) {
	append_styles(target, "svelte-wlzudi", ".header.svelte-wlzudi.svelte-wlzudi{display:inline-flex;align-items:center;justify-content:space-between;width:100%;margin-bottom:6px}.header.svelte-wlzudi label.svelte-wlzudi{width:auto;cursor:initial;min-width:105px;margin-bottom:0px;padding-left:5px}.mousePointer.svelte-wlzudi.svelte-wlzudi,.header.svelte-wlzudi .labelContainer label.mousePointer.svelte-wlzudi,.header.svelte-wlzudi .labelContainer.mousePointer.svelte-wlzudi{cursor:pointer}label.svelte-wlzudi i.svelte-wlzudi{padding-right:5px}.labelContainer.svelte-wlzudi.svelte-wlzudi{width:inherit;display:flex;align-items:center}.labelContainer.svelte-wlzudi.svelte-wlzudi,.content.svelte-wlzudi.svelte-wlzudi{user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}");
}

const get_headerExtension_slot_changes = dirty => ({});
const get_headerExtension_slot_context = ctx => ({});

// (46:4) {#if isCollapsible}
function create_if_block_1$b(ctx) {
	let i;

	return {
		c() {
			i = element("i");
			attr(i, "class", "fa fa-angle-right mousePointer svelte-wlzudi");
			attr(i, "style", /*iconStyle*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*iconStyle*/ 8) {
				attr(i, "style", /*iconStyle*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (50:6) {#if icon}
function create_if_block$e(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-wlzudi");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-wlzudi")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$g(ctx) {
	let div1;
	let div0;
	let t0;
	let label_1;
	let t1;
	let t2;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*isCollapsible*/ ctx[6] && create_if_block_1$b(ctx);
	let if_block1 = /*icon*/ ctx[2] && create_if_block$e(ctx);
	const headerExtension_slot_template = /*#slots*/ ctx[9].headerExtension;
	const headerExtension_slot = create_slot(headerExtension_slot_template, ctx, /*$$scope*/ ctx[8], get_headerExtension_slot_context);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			label_1 = element("label");
			if (if_block1) if_block1.c();
			t1 = text(/*label*/ ctx[4]);
			t2 = space();
			if (headerExtension_slot) headerExtension_slot.c();
			attr(label_1, "for", /*labelFor*/ ctx[5]);
			attr(label_1, "class", "svelte-wlzudi");
			toggle_class(label_1, "mousePointer", /*isCollapsible*/ ctx[6] && !/*openOnlyOnIcon*/ ctx[7]);
			attr(div0, "class", "labelContainer svelte-wlzudi");
			toggle_class(div0, "mousePointer", /*isCollapsible*/ ctx[6] && !/*openOnlyOnIcon*/ ctx[7]);
			attr(div1, "class", div1_class_value = "header " + /*clazz*/ ctx[1] + " svelte-wlzudi");
			attr(div1, "style", /*style*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);
			append(div0, label_1);
			if (if_block1) if_block1.m(label_1, null);
			append(label_1, t1);
			append(div1, t2);

			if (headerExtension_slot) {
				headerExtension_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler*/ ctx[12]),
					listen(div1, "mouseenter", /*mouseenter_handler*/ ctx[10]),
					listen(div1, "mouseleave", /*mouseleave_handler*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isCollapsible*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$b(ctx);
					if_block0.c();
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$e(ctx);
					if_block1.c();
					if_block1.m(label_1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*label*/ 16) set_data(t1, /*label*/ ctx[4]);

			if (!current || dirty & /*labelFor*/ 32) {
				attr(label_1, "for", /*labelFor*/ ctx[5]);
			}

			if (dirty & /*isCollapsible, openOnlyOnIcon*/ 192) {
				toggle_class(label_1, "mousePointer", /*isCollapsible*/ ctx[6] && !/*openOnlyOnIcon*/ ctx[7]);
			}

			if (dirty & /*isCollapsible, openOnlyOnIcon*/ 192) {
				toggle_class(div0, "mousePointer", /*isCollapsible*/ ctx[6] && !/*openOnlyOnIcon*/ ctx[7]);
			}

			if (headerExtension_slot) {
				if (headerExtension_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						headerExtension_slot,
						headerExtension_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(headerExtension_slot_template, /*$$scope*/ ctx[8], dirty, get_headerExtension_slot_changes),
						get_headerExtension_slot_context
					);
				}
			}

			if (!current || dirty & /*clazz*/ 2 && div1_class_value !== (div1_class_value = "header " + /*clazz*/ ctx[1] + " svelte-wlzudi")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*style*/ 1) {
				attr(div1, "style", /*style*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(headerExtension_slot, local);
			current = true;
		},
		o(local) {
			transition_out(headerExtension_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (headerExtension_slot) headerExtension_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = "", icon = "", iconStyle = "", label = "", labelFor = "", style = "", isCollapsible = false, openOnlyOnIcon = false } = $$props;
	if (isCollapsible) style += " margin-bottom: 0px;";

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(1, clazz = $$props.clazz);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('iconStyle' in $$props) $$invalidate(3, iconStyle = $$props.iconStyle);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('labelFor' in $$props) $$invalidate(5, labelFor = $$props.labelFor);
		if ('style' in $$props) $$invalidate(0, style = $$props.style);
		if ('isCollapsible' in $$props) $$invalidate(6, isCollapsible = $$props.isCollapsible);
		if ('openOnlyOnIcon' in $$props) $$invalidate(7, openOnlyOnIcon = $$props.openOnlyOnIcon);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		style,
		clazz,
		icon,
		iconStyle,
		label,
		labelFor,
		isCollapsible,
		openOnlyOnIcon,
		$$scope,
		slots,
		mouseenter_handler,
		mouseleave_handler,
		click_handler
	];
}

class ComponentHeader extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$g,
			create_fragment$g,
			safe_not_equal,
			{
				clazz: 1,
				icon: 2,
				iconStyle: 3,
				label: 4,
				labelFor: 5,
				style: 0,
				isCollapsible: 6,
				openOnlyOnIcon: 7
			},
			add_css$d
		);
	}
}

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        if (duration === 0) {
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            store.set(value = target_value);
            return Promise.resolve();
        }
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

/* node_modules/svelte-integration-red/components/Collapsible.svelte generated by Svelte v3.44.2 */

function add_css$c(target) {
	append_styles(target, "svelte-1pd8dbj", ".border.svelte-1pd8dbj{padding:12px}.content.svelte-1pd8dbj{width:100%;overflow:hidden}[id^='sir-Collapsible-'].sir-Row.sir-Collapsible, [id^='sir-Collapsible-'].sir-Collapsible{display:inline-flex;flex-direction:column;align-items:flex-start;width:100%}.sir-Collapsible .content .slotDiv .sir-Row:last-child{margin-bottom:0px}[id^='sir-Collapsible-'].sir-Collapsible .slotDiv{display:inline-flex;flex-direction:column;width:100%;padding-top:6px}[id^='sir-Collapsible-'].sir-Collapsible .slotDiv.indented{padding-left:12px;width:calc(100% - 12px)\n  }");
}

const get_default_slot_changes$1 = dirty => ({
	_collapsed: dirty[0] & /*_collapsed*/ 512
});

const get_default_slot_context$1 = ctx => ({ _collapsed: /*_collapsed*/ ctx[9] });

const get_header_slot_changes$2 = dirty => ({
	_collapsed: dirty[0] & /*_collapsed*/ 512
});

const get_header_slot_context$2 = ctx => ({
	slot: "headerExtension",
	_collapsed: /*_collapsed*/ ctx[9]
});

// (107:2) {#if label || $$slots.header}
function create_if_block$d(ctx) {
	let componentheader;
	let updating_iconStyle;
	let current;

	function componentheader_iconStyle_binding(value) {
		/*componentheader_iconStyle_binding*/ ctx[26](value);
	}

	let componentheader_props = {
		label: /*label*/ ctx[4],
		labelFor: "sir-Collapsible-" + /*id*/ ctx[1] + "-content",
		icon: /*icon*/ ctx[6],
		isCollapsible: true,
		openOnlyOnIcon: /*openOnlyOnIcon*/ ctx[7],
		$$slots: {
			headerExtension: [create_headerExtension_slot$2]
		},
		$$scope: { ctx }
	};

	if (/*iconStyle*/ ctx[13] !== void 0) {
		componentheader_props.iconStyle = /*iconStyle*/ ctx[13];
	}

	componentheader = new ComponentHeader({ props: componentheader_props });
	binding_callbacks.push(() => bind(componentheader, 'iconStyle', componentheader_iconStyle_binding));
	componentheader.$on("click", /*click_handler_1*/ ctx[27]);
	componentheader.$on("mouseenter", /*mouseenter_handler*/ ctx[28]);
	componentheader.$on("mouseleave", /*mouseleave_handler*/ ctx[29]);
	componentheader.$on("click", /*click_handler*/ ctx[30]);

	return {
		c() {
			create_component(componentheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(componentheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const componentheader_changes = {};
			if (dirty[0] & /*label*/ 16) componentheader_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*id*/ 2) componentheader_changes.labelFor = "sir-Collapsible-" + /*id*/ ctx[1] + "-content";
			if (dirty[0] & /*icon*/ 64) componentheader_changes.icon = /*icon*/ ctx[6];
			if (dirty[0] & /*openOnlyOnIcon*/ 128) componentheader_changes.openOnlyOnIcon = /*openOnlyOnIcon*/ ctx[7];

			if (dirty[0] & /*_collapsed*/ 512 | dirty[1] & /*$$scope*/ 4) {
				componentheader_changes.$$scope = { dirty, ctx };
			}

			if (!updating_iconStyle && dirty[0] & /*iconStyle*/ 8192) {
				updating_iconStyle = true;
				componentheader_changes.iconStyle = /*iconStyle*/ ctx[13];
				add_flush_callback(() => updating_iconStyle = false);
			}

			componentheader.$set(componentheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(componentheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(componentheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(componentheader, detaching);
		}
	};
}

// (109:6) 
function create_headerExtension_slot$2(ctx) {
	let current;
	const header_slot_template = /*#slots*/ ctx[25].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[33], get_header_slot_context$2);

	return {
		c() {
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*_collapsed*/ 512 | dirty[1] & /*$$scope*/ 4)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[33],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[33])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[33], dirty, get_header_slot_changes$2),
						get_header_slot_context$2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (106:0) <Row id="sir-Collapsible-{id}" bind:clazz={classes} {inline} {fading} {style} >
function create_default_slot$a(ctx) {
	let t;
	let div1;
	let div0;
	let div1_id_value;
	let current;
	let if_block = (/*label*/ ctx[4] || /*$$slots*/ ctx[17].header) && create_if_block$d(ctx);
	const default_slot_template = /*#slots*/ ctx[25].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[33], get_default_slot_context$1);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "slotDiv");
			toggle_class(div0, "indented", /*indented*/ ctx[2]);
			toggle_class(div0, "_collapsed", /*_collapsed*/ ctx[9]);
			attr(div1, "id", div1_id_value = "sir-Collapsible-" + /*id*/ ctx[1] + "-content");
			attr(div1, "class", "content svelte-1pd8dbj");
			attr(div1, "style", /*slotHeightStyle*/ ctx[12]);
			toggle_class(div1, "red-ui-editableList-border", /*border*/ ctx[0]);
			toggle_class(div1, "border", /*border*/ ctx[0]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[31](div0);
			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[4] || /*$$slots*/ ctx[17].header) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*label, $$slots*/ 131088) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$d(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*_collapsed*/ 512 | dirty[1] & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[33],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[33])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[33], dirty, get_default_slot_changes$1),
						get_default_slot_context$1
					);
				}
			}

			if (dirty[0] & /*indented*/ 4) {
				toggle_class(div0, "indented", /*indented*/ ctx[2]);
			}

			if (dirty[0] & /*_collapsed*/ 512) {
				toggle_class(div0, "_collapsed", /*_collapsed*/ ctx[9]);
			}

			if (!current || dirty[0] & /*id*/ 2 && div1_id_value !== (div1_id_value = "sir-Collapsible-" + /*id*/ ctx[1] + "-content")) {
				attr(div1, "id", div1_id_value);
			}

			if (!current || dirty[0] & /*slotHeightStyle*/ 4096) {
				attr(div1, "style", /*slotHeightStyle*/ ctx[12]);
			}

			if (dirty[0] & /*border*/ 1) {
				toggle_class(div1, "red-ui-editableList-border", /*border*/ ctx[0]);
			}

			if (dirty[0] & /*border*/ 1) {
				toggle_class(div1, "border", /*border*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[31](null);
		}
	};
}

function create_fragment$f(ctx) {
	let row;
	let updating_clazz;
	let current;

	function row_clazz_binding(value) {
		/*row_clazz_binding*/ ctx[32](value);
	}

	let row_props = {
		id: "sir-Collapsible-" + /*id*/ ctx[1],
		inline: /*inline*/ ctx[3],
		fading: /*fading*/ ctx[5],
		style: /*style*/ ctx[8],
		$$slots: { default: [create_default_slot$a] },
		$$scope: { ctx }
	};

	if (/*classes*/ ctx[11] !== void 0) {
		row_props.clazz = /*classes*/ ctx[11];
	}

	row = new Row({ props: row_props });
	binding_callbacks.push(() => bind(row, 'clazz', row_clazz_binding));

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 2) row_changes.id = "sir-Collapsible-" + /*id*/ ctx[1];
			if (dirty[0] & /*inline*/ 8) row_changes.inline = /*inline*/ ctx[3];
			if (dirty[0] & /*fading*/ 32) row_changes.fading = /*fading*/ ctx[5];
			if (dirty[0] & /*style*/ 256) row_changes.style = /*style*/ ctx[8];

			if (dirty[0] & /*id, slotHeightStyle, border, slotDiv, indented, _collapsed, label, icon, openOnlyOnIcon, iconStyle, $$slots*/ 145111 | dirty[1] & /*$$scope*/ 4) {
				row_changes.$$scope = { dirty, ctx };
			}

			if (!updating_clazz && dirty[0] & /*classes*/ 2048) {
				updating_clazz = true;
				row_changes.clazz = /*classes*/ ctx[11];
				add_flush_callback(() => updating_clazz = false);
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let iconStyle;
	let slotHeightStyle;
	let classes;
	let $slotHeight;
	let $rotation;
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { border = false, clazz = '', collapsed = false, fading = true, i18n, icon, id, indented = true, inline = false, label, node, openOnlyOnIcon = false, style = "" } = $$props;
	id = id || getId();
	indented = getBooleanFrom(indented);
	border = getBooleanFrom(border);
	inline = getBooleanFrom(inline);
	collapsed = getBooleanFrom(collapsed);

	// intern variable if used without bind
	let _collapsed = collapsed;

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	// collapsible icon styling
	const rotation = tweened(_collapsed ? 0 : 90, { duration: 400, easing: cubicOut });

	component_subscribe($$self, rotation, value => $$invalidate(24, $rotation = value));
	let slotDiv;
	let maxSlotHeight = 0;
	const slotHeight = tweened(0, { duration: 400, easing: cubicOut });
	component_subscribe($$self, slotHeight, value => $$invalidate(23, $slotHeight = value));

	onMount(() => {
		handleResize(true);
	});

	function handleResize(initial = false) {
		let computedSlotHeight = slotDiv.offsetHeight;

		if (_collapsed && maxSlotHeight !== computedSlotHeight) {
			// Prevent flickering when the content was changed after DOM created
			slotHeight.set(computedSlotHeight, { duration: 0 });
		}

		if (computedSlotHeight && computedSlotHeight !== 'auto') {
			$$invalidate(22, maxSlotHeight = computedSlotHeight);
		}

		if (initial) {
			// We do not want animation on first render
			slotHeight.set(_collapsed ? 0 : maxSlotHeight, { duration: 0 });
		} else {
			slotHeight.set(_collapsed ? 0 : maxSlotHeight);
		}
	}

	function openSlot(path) {
		// openOnlyOnIcon is a very special case for tree nodes where we only want to open it with the '>' icon
		// as the click event self is still needed for marking on select and e.g. pekfinger show description, we can't deactivate it completly.
		// this is bit dirty, but to change it on componentHeader will bloat the code for a perhabs single use case. Therefore this won't be shown in the Readme.
		if (openOnlyOnIcon && !path[0].classList.contains('fa-angle-right')) {
			return;
		}

		if (_collapsed) {
			rotation.set(90);
		} else {
			rotation.set(0);
		}

		$$invalidate(18, collapsed = !collapsed);
		$$invalidate(9, _collapsed = !_collapsed);
		handleResize();
	}

	function componentheader_iconStyle_binding(value) {
		iconStyle = value;
		($$invalidate(13, iconStyle), $$invalidate(24, $rotation));
	}

	const click_handler_1 = event => openSlot(event.path);

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			slotDiv = $$value;
			$$invalidate(10, slotDiv);
		});
	}

	function row_clazz_binding(value) {
		classes = value;
		(($$invalidate(11, classes), $$invalidate(19, clazz)), $$invalidate(9, _collapsed));
	}

	$$self.$$set = $$props => {
		if ('border' in $$props) $$invalidate(0, border = $$props.border);
		if ('clazz' in $$props) $$invalidate(19, clazz = $$props.clazz);
		if ('collapsed' in $$props) $$invalidate(18, collapsed = $$props.collapsed);
		if ('fading' in $$props) $$invalidate(5, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(20, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('indented' in $$props) $$invalidate(2, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(3, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('node' in $$props) $$invalidate(21, node = $$props.node);
		if ('openOnlyOnIcon' in $$props) $$invalidate(7, openOnlyOnIcon = $$props.openOnlyOnIcon);
		if ('style' in $$props) $$invalidate(8, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(33, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$rotation*/ 16777216) {
			$$invalidate(13, iconStyle = 'transform:rotate(' + $rotation + 'deg);');
		}

		if ($$self.$$.dirty[0] & /*_collapsed, $slotHeight, maxSlotHeight*/ 12583424) {
			$$invalidate(12, slotHeightStyle = 'height: ' + (!_collapsed && $slotHeight === maxSlotHeight
			? '100%;'
			: $slotHeight + 'px;'));
		}

		if ($$self.$$.dirty[0] & /*clazz, _collapsed*/ 524800) {
			$$invalidate(11, classes = clazz + " sir-Collapsible" + (_collapsed ? "" : " open"));
		}
	};

	return [
		border,
		id,
		indented,
		inline,
		label,
		fading,
		icon,
		openOnlyOnIcon,
		style,
		_collapsed,
		slotDiv,
		classes,
		slotHeightStyle,
		iconStyle,
		rotation,
		slotHeight,
		openSlot,
		$$slots,
		collapsed,
		clazz,
		i18n,
		node,
		maxSlotHeight,
		$slotHeight,
		$rotation,
		slots,
		componentheader_iconStyle_binding,
		click_handler_1,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		div0_binding,
		row_clazz_binding,
		$$scope
	];
}

class Collapsible extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$f,
			create_fragment$f,
			safe_not_equal,
			{
				border: 0,
				clazz: 19,
				collapsed: 18,
				fading: 5,
				i18n: 20,
				icon: 6,
				id: 1,
				indented: 2,
				inline: 3,
				label: 4,
				node: 21,
				openOnlyOnIcon: 7,
				style: 8
			},
			add_css$c,
			[-1, -1]
		);
	}
}

function flip(node, { from, to }, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
        easing,
        css: (t, u) => {
            const x = u * dx;
            const y = u * dy;
            const sx = t + u * from.width / to.width;
            const sy = t + u * from.height / to.height;
            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
        }
    };
}

/* node_modules/svelte-integration-red/components/EditableList.svelte generated by Svelte v3.44.2 */

function add_css$b(target) {
	append_styles(target, "svelte-1dpe4ic", "li.svelte-1dpe4ic.svelte-1dpe4ic{display:inline-flex;width:100%;align-items:center}li.svelte-1dpe4ic .red-ui-editableList-item-content.svelte-1dpe4ic{width:100%;margin:0px 8px}li.svelte-1dpe4ic .red-ui-editableList-item-remove.svelte-1dpe4ic{position:initial;margin:0px 3px 0px 0px}li.svelte-1dpe4ic .red-ui-editableList-item-handle.svelte-1dpe4ic{position:initial;margin:0px 0px 0px 3px}.disabled.svelte-1dpe4ic.svelte-1dpe4ic{pointer-events:none}[id^='sir-EditableList-'].sir-Row.sir-EditableList{align-items:flex-start;flex-direction:column}.indented.svelte-1dpe4ic.svelte-1dpe4ic{padding-left:12px}[id^='sir-EditableList-'].sir-Row.sir-EditableList div:last-child{margin-bottom:0px}.sir-EditableList .red-ui-editableList-item-remove .sir-Row, .sir-EditableList .header .sir-Row{margin-bottom:0px}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList-container{min-height:100px;overflow-y:auto !important;overflow-x:hidden;padding-top:0px}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList{width:100%}[id^='sir-EditableList-'].sir-Row.sir-EditableList .red-ui-editableList-item-remove button{min-width:auto}.halfTransparent.svelte-1dpe4ic.svelte-1dpe4ic{opacity:.5}.dropzoneCurrent.svelte-1dpe4ic.svelte-1dpe4ic{border-top:2px solid #ccc;border-bottom:3px solid #ccc}.dropzoneUnder.svelte-1dpe4ic.svelte-1dpe4ic{border-top:3px solid #ccc}.dropzoneAbove.svelte-1dpe4ic.svelte-1dpe4ic{border-bottom:3px solid #ccc}");
}

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[56] = list[i];
	child_ctx[58] = i;
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	element: dirty[0] & /*elements*/ 2,
	index: dirty[0] & /*elements*/ 2
});

const get_default_slot_context = ctx => ({
	element: /*element*/ ctx[56],
	index: /*index*/ ctx[58]
});

const get_tableHeader_slot_changes = dirty => ({
	element: dirty[0] & /*elements*/ 2,
	index: dirty[0] & /*elements*/ 2
});

const get_tableHeader_slot_context = ctx => ({
	element: /*element*/ ctx[56],
	index: /*index*/ ctx[58]
});

const get_header_slot_changes$1 = dirty => ({
	element: dirty[0] & /*elements*/ 2,
	index: dirty[0] & /*elements*/ 2
});

const get_header_slot_context$1 = ctx => ({
	slot: "headerExtension",
	element: /*element*/ ctx[56],
	index: /*index*/ ctx[58]
});

// (135:2) {#if label || $$slots.header}
function create_if_block_4$3(ctx) {
	let componentheader;
	let current;

	componentheader = new ComponentHeader({
			props: {
				label: /*label*/ ctx[6],
				labelFor: "sir-EditableList-" + /*id*/ ctx[3] + "-content",
				icon: /*icon*/ ctx[14],
				$$slots: {
					headerExtension: [create_headerExtension_slot$1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(componentheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(componentheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const componentheader_changes = {};
			if (dirty[0] & /*label*/ 64) componentheader_changes.label = /*label*/ ctx[6];
			if (dirty[0] & /*id*/ 8) componentheader_changes.labelFor = "sir-EditableList-" + /*id*/ ctx[3] + "-content";
			if (dirty[0] & /*icon*/ 16384) componentheader_changes.icon = /*icon*/ ctx[14];

			if (dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 4194304) {
				componentheader_changes.$$scope = { dirty, ctx };
			}

			componentheader.$set(componentheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(componentheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(componentheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(componentheader, detaching);
		}
	};
}

// (137:6) 
function create_headerExtension_slot$1(ctx) {
	let current;
	const header_slot_template = /*#slots*/ ctx[33].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[53], get_header_slot_context$1);

	return {
		c() {
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[53],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[53])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[53], dirty, get_header_slot_changes$1),
						get_header_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (150:6) {#if $$slots.tableHeader}
function create_if_block_3$6(ctx) {
	let div;
	let current;
	const tableHeader_slot_template = /*#slots*/ ctx[33].tableHeader;
	const tableHeader_slot = create_slot(tableHeader_slot_template, ctx, /*$$scope*/ ctx[53], get_tableHeader_slot_context);

	return {
		c() {
			div = element("div");
			if (tableHeader_slot) tableHeader_slot.c();
			attr(div, "class", "red-ui-editableList-header");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (tableHeader_slot) {
				tableHeader_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (tableHeader_slot) {
				if (tableHeader_slot.p && (!current || dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 4194304)) {
					update_slot_base(
						tableHeader_slot,
						tableHeader_slot_template,
						ctx,
						/*$$scope*/ ctx[53],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[53])
						: get_slot_changes(tableHeader_slot_template, /*$$scope*/ ctx[53], dirty, get_tableHeader_slot_changes),
						get_tableHeader_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(tableHeader_slot, local);
			current = true;
		},
		o(local) {
			transition_out(tableHeader_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (tableHeader_slot) tableHeader_slot.d(detaching);
		}
	};
}

// (172:12) {#if sortable}
function create_if_block_2$8(ctx) {
	let i;
	let mounted;
	let dispose;

	return {
		c() {
			i = element("i");
			attr(i, "class", "red-ui-editableList-item-handle fa fa-bars svelte-1dpe4ic");
			toggle_class(i, "disabled", /*disabled*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, i, anchor);

			if (!mounted) {
				dispose = [
					listen(i, "mouseover", /*mouseover_handler*/ ctx[45]),
					listen(i, "focus", /*focus_handler*/ ctx[46]),
					listen(i, "mouseout", /*mouseout_handler*/ ctx[47]),
					listen(i, "blur", /*blur_handler*/ ctx[48])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 1) {
				toggle_class(i, "disabled", /*disabled*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (181:12) {#if removable}
function create_if_block_1$a(ctx) {
	let div;
	let button;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[49](/*index*/ ctx[58]);
	}

	button = new Button({
			props: {
				small: true,
				icon: "remove",
				disabled: /*disabled*/ ctx[0]
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "red-ui-editableList-item-remove svelte-1dpe4ic");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty[0] & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (156:8) {#each elements as element, index (typeof element === 'object' ? element.id || element : index)}
function create_each_block$5(key_1, ctx) {
	let li;
	let t0;
	let div;
	let t1;
	let t2;
	let li_id_value;
	let rect;
	let stop_animation = noop;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*sortable*/ ctx[11] && create_if_block_2$8(ctx);
	const default_slot_template = /*#slots*/ ctx[33].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[53], get_default_slot_context);
	let if_block1 = /*removable*/ ctx[10] && create_if_block_1$a(ctx);

	function dragstart_handler(...args) {
		return /*dragstart_handler*/ ctx[50](/*index*/ ctx[58], ...args);
	}

	function drop_handler_2(...args) {
		return /*drop_handler_2*/ ctx[51](/*index*/ ctx[58], ...args);
	}

	function dragenter_handler_2(...args) {
		return /*dragenter_handler_2*/ ctx[52](/*index*/ ctx[58], ...args);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			attr(div, "class", "red-ui-editableList-item-content svelte-1dpe4ic");
			attr(li, "id", li_id_value = /*index*/ ctx[58]);
			attr(li, "draggable", /*isDraggable*/ ctx[17]);
			attr(li, "class", "svelte-1dpe4ic");
			toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[11]);
			toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[10]);
			toggle_class(li, "dropzoneUnder", /*hovering*/ ctx[15] === /*index*/ ctx[58] && /*hovering*/ ctx[15] < /*draggingIndex*/ ctx[16]);
			toggle_class(li, "dropzoneAbove", /*hovering*/ ctx[15] === /*index*/ ctx[58] && /*hovering*/ ctx[15] > /*draggingIndex*/ ctx[16]);
			toggle_class(li, "dropzoneCurrent", /*hovering*/ ctx[15] === /*index*/ ctx[58] && /*index*/ ctx[58] === /*draggingIndex*/ ctx[16]);
			toggle_class(li, "halfTransparent", /*hovering*/ ctx[15] !== /*index*/ ctx[58] && /*index*/ ctx[58] === /*draggingIndex*/ ctx[16]);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append(li, t0);
			append(li, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(li, t1);
			if (if_block1) if_block1.m(li, null);
			append(li, t2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "dragstart", stop_propagation(dragstart_handler)),
					listen(li, "drag", stop_propagation(/*drag_handler_1*/ ctx[40])),
					listen(li, "drop", stop_propagation(prevent_default(drop_handler_2))),
					listen(li, "drop", /*drop_handler_1*/ ctx[41]),
					listen(li, "dragover", stop_propagation(prevent_default(/*dragover_handler_1*/ ctx[42]))),
					listen(li, "dragenter", stop_propagation(prevent_default(dragenter_handler_2))),
					listen(li, "dragenter", stop_propagation(prevent_default(/*dragenter_handler_1*/ ctx[43]))),
					listen(li, "dragleave", stop_propagation(/*dragleave_handler_1*/ ctx[44])),
					listen(li, "dragend", stop_propagation(/*dragend*/ ctx[25]))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*sortable*/ ctx[11]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$8(ctx);
					if_block0.c();
					if_block0.m(li, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*elements*/ 2 | dirty[1] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[53],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[53])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[53], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}

			if (/*removable*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*removable*/ 1024) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$a(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*elements*/ 2 && li_id_value !== (li_id_value = /*index*/ ctx[58])) {
				attr(li, "id", li_id_value);
			}

			if (!current || dirty[0] & /*isDraggable*/ 131072) {
				attr(li, "draggable", /*isDraggable*/ ctx[17]);
			}

			if (dirty[0] & /*sortable*/ 2048) {
				toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[11]);
			}

			if (dirty[0] & /*removable*/ 1024) {
				toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[10]);
			}

			if (dirty[0] & /*hovering, elements, draggingIndex*/ 98306) {
				toggle_class(li, "dropzoneUnder", /*hovering*/ ctx[15] === /*index*/ ctx[58] && /*hovering*/ ctx[15] < /*draggingIndex*/ ctx[16]);
			}

			if (dirty[0] & /*hovering, elements, draggingIndex*/ 98306) {
				toggle_class(li, "dropzoneAbove", /*hovering*/ ctx[15] === /*index*/ ctx[58] && /*hovering*/ ctx[15] > /*draggingIndex*/ ctx[16]);
			}

			if (dirty[0] & /*hovering, elements, draggingIndex*/ 98306) {
				toggle_class(li, "dropzoneCurrent", /*hovering*/ ctx[15] === /*index*/ ctx[58] && /*index*/ ctx[58] === /*draggingIndex*/ ctx[16]);
			}

			if (dirty[0] & /*hovering, elements, draggingIndex*/ 98306) {
				toggle_class(li, "halfTransparent", /*hovering*/ ctx[15] !== /*index*/ ctx[58] && /*index*/ ctx[58] === /*draggingIndex*/ ctx[16]);
			}
		},
		r() {
			rect = li.getBoundingClientRect();
		},
		f() {
			fix_position(li);
			stop_animation();
		},
		a() {
			stop_animation();
			stop_animation = create_animation(li, rect, flip, { duration: 200 });
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (190:4) {#if _addButton}
function create_if_block$c(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				style: "margin-top: 6px;",
				icon: "plus",
				disabled: /*disabled*/ ctx[0],
				label: /*addButtonLabel*/ ctx[19],
				small: true
			}
		});

	button.$on("click", /*addHandler*/ ctx[26]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*disabled*/ 1) button_changes.disabled = /*disabled*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (134:0) <Row id="sir-EditableList-{id}" clazz="{clazz} sir-EditableList" {inline} {maximize} fading={fadeDuration} {style}>
function create_default_slot$9(ctx) {
	let t0;
	let div1;
	let div0;
	let t1;
	let ol;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div0_id_value;
	let div0_style_value;
	let t2;
	let current;
	let mounted;
	let dispose;
	let if_block0 = (/*label*/ ctx[6] || /*$$slots*/ ctx[28].header) && create_if_block_4$3(ctx);
	let if_block1 = /*$$slots*/ ctx[28].tableHeader && create_if_block_3$6(ctx);
	let each_value = /*elements*/ ctx[1];

	const get_key = ctx => typeof /*element*/ ctx[56] === 'object'
	? /*element*/ ctx[56].id || /*element*/ ctx[56]
	: /*index*/ ctx[58];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$5(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
	}

	let if_block2 = /*_addButton*/ ctx[18] && create_if_block$c(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block2) if_block2.c();
			attr(ol, "id", /*nodeInputId*/ ctx[20]);
			attr(ol, "class", "red-ui-editableList-list sir-EditableList-list");
			attr(ol, "style", /*style*/ ctx[12]);
			toggle_class(ol, "ui-sortable", /*sortable*/ ctx[11]);
			attr(div0, "id", div0_id_value = "sir-EditableList-" + /*id*/ ctx[3] + "-content");
			attr(div0, "class", "red-ui-editableList-border red-ui-editableList-container svelte-1dpe4ic");
			attr(div0, "style", div0_style_value = `${/*style*/ ctx[12]} min-height: ${/*minHeight*/ ctx[9]}; height: ${/*height*/ ctx[2]}; max-height: ${/*maxHeight*/ ctx[7]}`);
			toggle_class(div0, "indented", /*indented*/ ctx[4]);
			attr(div1, "class", "red-ui-editableList");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			append(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t1);
			append(div0, ol);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			append(div1, t2);
			if (if_block2) if_block2.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "drag", stop_propagation(/*drag_handler*/ ctx[34])),
					listen(div0, "drop", stop_propagation(prevent_default(/*drop_handler*/ ctx[35]))),
					listen(div0, "dragover", stop_propagation(prevent_default(/*dragover_handler*/ ctx[36]))),
					listen(div0, "dragenter", stop_propagation(prevent_default(/*dragenter_handler*/ ctx[37]))),
					listen(div0, "dragleave", stop_propagation(/*dragleave_handler*/ ctx[38])),
					listen(div0, "dragend", stop_propagation(/*dragend_handler*/ ctx[39]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[6] || /*$$slots*/ ctx[28].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*label, $$slots*/ 268435520) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$$slots*/ ctx[28].tableHeader) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*$$slots*/ 268435456) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*elements, isDraggable, sortable, removable, hovering, draggingIndex, dragstart, drop, dragenter, dragend, disabled, removeHandler*/ 197364739 | dirty[1] & /*$$scope*/ 4194304) {
				each_value = /*elements*/ ctx[1];
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ol, fix_and_outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}

			if (!current || dirty[0] & /*style*/ 4096) {
				attr(ol, "style", /*style*/ ctx[12]);
			}

			if (dirty[0] & /*sortable*/ 2048) {
				toggle_class(ol, "ui-sortable", /*sortable*/ ctx[11]);
			}

			if (!current || dirty[0] & /*id*/ 8 && div0_id_value !== (div0_id_value = "sir-EditableList-" + /*id*/ ctx[3] + "-content")) {
				attr(div0, "id", div0_id_value);
			}

			if (!current || dirty[0] & /*style, minHeight, height, maxHeight*/ 4740 && div0_style_value !== (div0_style_value = `${/*style*/ ctx[12]} min-height: ${/*minHeight*/ ctx[9]}; height: ${/*height*/ ctx[2]}; max-height: ${/*maxHeight*/ ctx[7]}`)) {
				attr(div0, "style", div0_style_value);
			}

			if (dirty[0] & /*indented*/ 16) {
				toggle_class(div0, "indented", /*indented*/ ctx[4]);
			}

			if (/*_addButton*/ ctx[18]) if_block2.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			if (if_block1) if_block1.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$e(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-EditableList-" + /*id*/ ctx[3],
				clazz: "" + (/*clazz*/ ctx[13] + " sir-EditableList"),
				inline: /*inline*/ ctx[5],
				maximize: /*maximize*/ ctx[8],
				fading: /*fadeDuration*/ ctx[21],
				style: /*style*/ ctx[12],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 8) row_changes.id = "sir-EditableList-" + /*id*/ ctx[3];
			if (dirty[0] & /*clazz*/ 8192) row_changes.clazz = "" + (/*clazz*/ ctx[13] + " sir-EditableList");
			if (dirty[0] & /*inline*/ 32) row_changes.inline = /*inline*/ ctx[5];
			if (dirty[0] & /*maximize*/ 256) row_changes.maximize = /*maximize*/ ctx[8];
			if (dirty[0] & /*style*/ 4096) row_changes.style = /*style*/ ctx[12];

			if (dirty[0] & /*disabled, id, style, minHeight, height, maxHeight, indented, sortable, elements, isDraggable, removable, hovering, draggingIndex, $$slots, label, icon*/ 268689119 | dirty[1] & /*$$scope*/ 4194304) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { addButton = false, clazz = "", disabled = false, elements, fading = true, height = 'auto', i18n, icon, id, indented = false, inline = false, label = '', maxHeight = 300, maximize = false, minHeight = 100, node, removable = false, sortable = false, style = '' } = $$props;
	id = id || getId();
	const _addButton = getBooleanFrom(!!addButton);
	sortable = getBooleanFrom(sortable);
	removable = getBooleanFrom(removable);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);

	const addButtonLabel = typeof addButton === 'string'
	? addButton
	: RED._("editableList.add");

	if (style && !style.endsWith(";")) {
		style = style + ";";
	}

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	const nodeInputId = "node-input-" + id + "-container";
	const fadeDuration = getFadeDuration(fading);

	// note: if height is set, min and max height have no effect
	if (!isNaN(height)) height += "px";

	if (!isNaN(minHeight)) minHeight += "px";
	if (!isNaN(maxHeight)) maxHeight += "px";
	const dispatch = createEventDispatcher();

	// sorting mechanism
	let hovering = false;

	let draggingIndex = null;
	let isDraggable = false;
	let dropzone;

	const drop = (e, target) => {
		if (dropzone) {
			e.dataTransfer.dropEffect = 'move';
			const start = parseInt(e.dataTransfer.getData("text/plain"));
			const newTracklist = [...elements];

			if (start < target) {
				newTracklist.splice(target + 1, 0, newTracklist[start]);
				newTracklist.splice(start, 1);
			} else {
				newTracklist.splice(target, 0, newTracklist[start]);
				newTracklist.splice(start + 1, 1);
			}

			$$invalidate(1, elements = newTracklist);
			$$invalidate(15, hovering = null);
			$$invalidate(16, draggingIndex = null);
			dispatch('changed', { elements }, { cancelable: false });
		}
	};

	const dragstart = (e, i) => {
		dropzone = e.target.closest('ol').id;
		$$invalidate(16, draggingIndex = i);
		e.dataTransfer.effectAllowed = 'move';
		e.dataTransfer.dropEffect = 'move';
		const start = i;
		e.dataTransfer.setData('text/plain', start);
	};

	const dragenter = (e, i) => {
		if (dropzone) {
			$$invalidate(15, hovering = i);
		}
	};

	const dragend = () => {
		dropzone = false;
		$$invalidate(15, hovering = null);
		$$invalidate(16, draggingIndex = null);
	};

	// add / remove content
	const addHandler = () => dispatch('add', { index: elements.length });

	const removeHandler = index => {
		const removed = elements[index];
		$$invalidate(1, elements = [...elements.slice(0, index), ...elements.slice(index + 1)]);
		dispatch('remove', { removed }, { cancelable: false });
	};

	function drag_handler(event) {
		bubble.call(this, $$self, event);
	}

	function drop_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragend_handler(event) {
		bubble.call(this, $$self, event);
	}

	function drag_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function drop_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dragover_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dragenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function dragleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	const mouseover_handler = () => $$invalidate(17, isDraggable = true);
	const focus_handler = () => $$invalidate(17, isDraggable = true);
	const mouseout_handler = () => $$invalidate(17, isDraggable = false);
	const blur_handler = () => $$invalidate(17, isDraggable = false);
	const click_handler = index => removeHandler(index);
	const dragstart_handler = (index, e) => dragstart(e, index);
	const drop_handler_2 = (index, e) => drop(e, index);

	const dragenter_handler_2 = (index, e) => {
		dragenter(e, index);
	};

	$$self.$$set = $$props => {
		if ('addButton' in $$props) $$invalidate(29, addButton = $$props.addButton);
		if ('clazz' in $$props) $$invalidate(13, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
		if ('elements' in $$props) $$invalidate(1, elements = $$props.elements);
		if ('fading' in $$props) $$invalidate(30, fading = $$props.fading);
		if ('height' in $$props) $$invalidate(2, height = $$props.height);
		if ('i18n' in $$props) $$invalidate(31, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(14, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('indented' in $$props) $$invalidate(4, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(5, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('maxHeight' in $$props) $$invalidate(7, maxHeight = $$props.maxHeight);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('minHeight' in $$props) $$invalidate(9, minHeight = $$props.minHeight);
		if ('node' in $$props) $$invalidate(32, node = $$props.node);
		if ('removable' in $$props) $$invalidate(10, removable = $$props.removable);
		if ('sortable' in $$props) $$invalidate(11, sortable = $$props.sortable);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(53, $$scope = $$props.$$scope);
	};

	return [
		disabled,
		elements,
		height,
		id,
		indented,
		inline,
		label,
		maxHeight,
		maximize,
		minHeight,
		removable,
		sortable,
		style,
		clazz,
		icon,
		hovering,
		draggingIndex,
		isDraggable,
		_addButton,
		addButtonLabel,
		nodeInputId,
		fadeDuration,
		drop,
		dragstart,
		dragenter,
		dragend,
		addHandler,
		removeHandler,
		$$slots,
		addButton,
		fading,
		i18n,
		node,
		slots,
		drag_handler,
		drop_handler,
		dragover_handler,
		dragenter_handler,
		dragleave_handler,
		dragend_handler,
		drag_handler_1,
		drop_handler_1,
		dragover_handler_1,
		dragenter_handler_1,
		dragleave_handler_1,
		mouseover_handler,
		focus_handler,
		mouseout_handler,
		blur_handler,
		click_handler,
		dragstart_handler,
		drop_handler_2,
		dragenter_handler_2,
		$$scope
	];
}

class EditableList extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$e,
			create_fragment$e,
			safe_not_equal,
			{
				addButton: 29,
				clazz: 13,
				disabled: 0,
				elements: 1,
				fading: 30,
				height: 2,
				i18n: 31,
				icon: 14,
				id: 3,
				indented: 4,
				inline: 5,
				label: 6,
				maxHeight: 7,
				maximize: 8,
				minHeight: 9,
				node: 32,
				removable: 10,
				sortable: 11,
				style: 12
			},
			add_css$b,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Group.svelte generated by Svelte v3.44.2 */

function add_css$a(target) {
	append_styles(target, "svelte-2ebxwy", ".sir-Group-container.svelte-2ebxwy{padding:12px 12px 0px 12px}[id^='sir-Group-'].sir-Row.sir-Group, [id^='sir-Group-'].sir-Group{flex-direction:column;align-items:stretch}.maximize.svelte-2ebxwy{width:100%}");
}

const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({ slot: "headerExtension" });

// (32:2) {#if label || $$slots.header}
function create_if_block$b(ctx) {
	let componentheader;
	let current;

	componentheader = new ComponentHeader({
			props: {
				label: /*label*/ ctx[1],
				labelFor: "sir-EditableList-" + /*id*/ ctx[7] + "-content",
				icon: /*icon*/ ctx[5],
				$$slots: {
					headerExtension: [create_headerExtension_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(componentheader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(componentheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const componentheader_changes = {};
			if (dirty & /*label*/ 2) componentheader_changes.label = /*label*/ ctx[1];
			if (dirty & /*id*/ 128) componentheader_changes.labelFor = "sir-EditableList-" + /*id*/ ctx[7] + "-content";
			if (dirty & /*icon*/ 32) componentheader_changes.icon = /*icon*/ ctx[5];

			if (dirty & /*$$scope*/ 4096) {
				componentheader_changes.$$scope = { dirty, ctx };
			}

			componentheader.$set(componentheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(componentheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(componentheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(componentheader, detaching);
		}
	};
}

// (34:6) 
function create_headerExtension_slot(ctx) {
	let current;
	const header_slot_template = /*#slots*/ ctx[11].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[12], get_header_slot_context);

	return {
		c() {
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[12], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (31:0) <Row id="sir-Group-{id}" clazz="{clazz} sir-Group" {inline} {fading}>
function create_default_slot$8(ctx) {
	let t;
	let div;
	let div_id_value;
	let current;
	let if_block = (/*label*/ ctx[1] || /*$$slots*/ ctx[8].header) && create_if_block$b(ctx);
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "id", div_id_value = "sir-Group-" + /*id*/ ctx[7] + "-container");
			attr(div, "class", "red-ui-editableList-border sir-Group-container svelte-2ebxwy");
			attr(div, "style", /*style*/ ctx[6]);
			toggle_class(div, "maximize", /*maximize*/ ctx[2]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[1] || /*$$slots*/ ctx[8].header) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label, $$slots*/ 258) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 128 && div_id_value !== (div_id_value = "sir-Group-" + /*id*/ ctx[7] + "-container")) {
				attr(div, "id", div_id_value);
			}

			if (!current || dirty & /*style*/ 64) {
				attr(div, "style", /*style*/ ctx[6]);
			}

			if (dirty & /*maximize*/ 4) {
				toggle_class(div, "maximize", /*maximize*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$d(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Group-" + /*id*/ ctx[7],
				clazz: "" + (/*clazz*/ ctx[3] + " sir-Group"),
				inline: /*inline*/ ctx[0],
				fading: /*fading*/ ctx[4],
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 128) row_changes.id = "sir-Group-" + /*id*/ ctx[7];
			if (dirty & /*clazz*/ 8) row_changes.clazz = "" + (/*clazz*/ ctx[3] + " sir-Group");
			if (dirty & /*inline*/ 1) row_changes.inline = /*inline*/ ctx[0];
			if (dirty & /*fading*/ 16) row_changes.fading = /*fading*/ ctx[4];

			if (dirty & /*$$scope, id, style, maximize, label, icon, $$slots*/ 4582) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { clazz = '', fading = true, i18n, icon, inline = false, label, maximize = false, node, style = '' } = $$props;
	let { id = getId() } = $$props;
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(3, clazz = $$props.clazz);
		if ('fading' in $$props) $$invalidate(4, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(5, icon = $$props.icon);
		if ('inline' in $$props) $$invalidate(0, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(2, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(10, node = $$props.node);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('id' in $$props) $$invalidate(7, id = $$props.id);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	return [
		inline,
		label,
		maximize,
		clazz,
		fading,
		icon,
		style,
		id,
		$$slots,
		i18n,
		node,
		slots,
		$$scope
	];
}

class Group extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$d,
			create_fragment$d,
			safe_not_equal,
			{
				clazz: 3,
				fading: 4,
				i18n: 9,
				icon: 5,
				inline: 0,
				label: 1,
				maximize: 2,
				node: 10,
				style: 6,
				id: 7
			},
			add_css$a
		);
	}
}

/* node_modules/svelte-integration-red/components/PlainInput.svelte generated by Svelte v3.44.2 */

function add_css$9(target) {
	append_styles(target, "svelte-1ux37oi", ".maximize.svelte-1ux37oi{width:100%}");
}

// (110:0) {:else}
function create_else_block_1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-1ux37oi");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (78:0) {#if !internal.updateNode || prop}
function create_if_block$a(ctx) {
	let t;
	let if_block1_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[6] !== 'checkbox' && /*label*/ ctx[0] || /*type*/ ctx[6] === 'checkbox' && /*label*/ ctx[0] && /*labelBeforeCheckbox*/ ctx[5]) return create_if_block_10;
		if (/*indented*/ ctx[4]) return create_if_block_12;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[6] === 'text') return create_if_block_1$9;
		if (/*type*/ ctx[6] === 'number') return create_if_block_2$7;
		if (/*type*/ ctx[6] === 'password') return create_if_block_3$5;
		if (/*type*/ ctx[6] === 'email') return create_if_block_4$2;
		if (/*type*/ ctx[6] === 'url') return create_if_block_5$2;
		if (/*type*/ ctx[6] === 'color') return create_if_block_6;
		if (/*type*/ ctx[6] === 'checkbox') return create_if_block_7;
		return create_else_block$6;
	}

	let current_block_type_1 = select_block_type_2(ctx);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},
		d(detaching) {
			if (if_block0) {
				if_block0.d(detaching);
			}

			if (detaching) detach(t);
			if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (83:21) 
function create_if_block_12(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (79:2) {#if (type !== 'checkbox' && label) || (type === 'checkbox' && label && labelBeforeCheckbox)}
function create_if_block_10(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[3] && create_if_block_11(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[0]);
			attr(label_1, "for", /*inputFieldId*/ ctx[11]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[50]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[51])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (81:6) {#if icon}
function create_if_block_11(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1ux37oi");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 8 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1ux37oi")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (107:2) {:else}
function create_else_block$6(ctx) {
	let span;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text("Error: Unsupported property type '");
			t1 = text(/*type*/ ctx[6]);
			t2 = text("'.");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*type*/ 64) set_data(t1, /*type*/ ctx[6]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (100:32) 
function create_if_block_7(ctx) {
	let div;
	let input;
	let t;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[0] && !/*labelBeforeCheckbox*/ ctx[5] && create_if_block_8(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "title", /*tooltip*/ ctx[9]);
			attr(input, "type", "checkbox");
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			attr(div, "class", "checkbox");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			input.checked = /*internal*/ ctx[10].value;
			append(div, t);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*input_change_handler*/ ctx[59]),
					listen(input, "mouseenter", /*mouseenter_handler_7*/ ctx[46]),
					listen(input, "mouseleave", /*mouseleave_handler_7*/ ctx[47]),
					listen(input, "keypress", /*keypress_handler_6*/ ctx[48]),
					listen(input, "click", /*click_handler_6*/ ctx[49])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*tooltip*/ 512) {
				attr(input, "title", /*tooltip*/ ctx[9]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				input.checked = /*internal*/ ctx[10].value;
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}

			if (/*label*/ ctx[0] && !/*labelBeforeCheckbox*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_8(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:29) 
function create_if_block_6(ctx) {
	let input0;
	let t;
	let input1;
	let mounted;
	let dispose;

	return {
		c() {
			input0 = element("input");
			t = space();
			input1 = element("input");
			input0.disabled = /*disabled*/ ctx[2];
			set_style(input0, "max-width", "30px");
			attr(input0, "type", "color");
			toggle_class(input0, "input-error", /*internal*/ ctx[10].isError);
			attr(input1, "id", /*inputFieldId*/ ctx[11]);
			attr(input1, "placeholder", /*placeholder*/ ctx[1]);
			input1.disabled = /*disabled*/ ctx[2];
			attr(input1, "title", /*tooltip*/ ctx[9]);
			attr(input1, "type", "text");
			attr(input1, "class", "svelte-1ux37oi");
			toggle_class(input1, "maximize", /*maximize*/ ctx[7]);
			toggle_class(input1, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input0, anchor);
			set_input_value(input0, /*internal*/ ctx[10].value);
			insert(target, t, anchor);
			insert(target, input1, anchor);
			set_input_value(input1, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input0, "input", /*input0_input_handler*/ ctx[57]),
					listen(input1, "input", /*input1_input_handler*/ ctx[58]),
					listen(input1, "mouseenter", /*mouseenter_handler_6*/ ctx[39]),
					listen(input1, "mouseleave", /*mouseleave_handler_6*/ ctx[40]),
					listen(input1, "keypress", /*keypress_handler_5*/ ctx[41]),
					listen(input1, "click", /*click_handler_5*/ ctx[42])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 4) {
				input0.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*internal*/ 1024) {
				set_input_value(input0, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input0, "input-error", /*internal*/ ctx[10].isError);
			}

			if (dirty[0] & /*placeholder*/ 2) {
				attr(input1, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 4) {
				input1.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*tooltip*/ 512) {
				attr(input1, "title", /*tooltip*/ ctx[9]);
			}

			if (dirty[0] & /*internal*/ 1024 && input1.value !== /*internal*/ ctx[10].value) {
				set_input_value(input1, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 128) {
				toggle_class(input1, "maximize", /*maximize*/ ctx[7]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input1, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input0);
			if (detaching) detach(t);
			if (detaching) detach(input1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (95:27) 
function create_if_block_5$2(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "title", /*tooltip*/ ctx[9]);
			attr(input, "type", "url");
			attr(input, "class", "svelte-1ux37oi");
			toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_4*/ ctx[56]),
					listen(input, "mouseenter", /*mouseenter_handler_5*/ ctx[35]),
					listen(input, "mouseleave", /*mouseleave_handler_5*/ ctx[36]),
					listen(input, "keypress", /*keypress_handler_4*/ ctx[37]),
					listen(input, "click", /*click_handler_4*/ ctx[38])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*tooltip*/ 512) {
				attr(input, "title", /*tooltip*/ ctx[9]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 128) {
				toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (93:29) 
function create_if_block_4$2(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "title", /*tooltip*/ ctx[9]);
			attr(input, "type", "email");
			attr(input, "class", "svelte-1ux37oi");
			toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_3*/ ctx[55]),
					listen(input, "mouseenter", /*mouseenter_handler_4*/ ctx[31]),
					listen(input, "mouseleave", /*mouseleave_handler_4*/ ctx[32]),
					listen(input, "keypress", /*keypress_handler_3*/ ctx[33]),
					listen(input, "click", /*click_handler_3*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*tooltip*/ 512) {
				attr(input, "title", /*tooltip*/ ctx[9]);
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 128) {
				toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (91:32) 
function create_if_block_3$5(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "title", /*tooltip*/ ctx[9]);
			attr(input, "type", "password");
			attr(input, "class", "svelte-1ux37oi");
			toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_2*/ ctx[54]),
					listen(input, "mouseenter", /*mouseenter_handler_3*/ ctx[27]),
					listen(input, "mouseleave", /*mouseleave_handler_3*/ ctx[28]),
					listen(input, "keypress", /*keypress_handler_2*/ ctx[29]),
					listen(input, "click", /*click_handler_2*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*tooltip*/ 512) {
				attr(input, "title", /*tooltip*/ ctx[9]);
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 128) {
				toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (89:30) 
function create_if_block_2$7(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "title", /*tooltip*/ ctx[9]);
			attr(input, "type", "number");
			attr(input, "class", "svelte-1ux37oi");
			toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_1*/ ctx[53]),
					listen(input, "mouseenter", /*mouseenter_handler_2*/ ctx[23]),
					listen(input, "mouseleave", /*mouseleave_handler_2*/ ctx[24]),
					listen(input, "keypress", /*keypress_handler_1*/ ctx[25]),
					listen(input, "click", /*click_handler_1*/ ctx[26])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*tooltip*/ 512) {
				attr(input, "title", /*tooltip*/ ctx[9]);
			}

			if (dirty[0] & /*internal*/ 1024 && to_number(input.value) !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 128) {
				toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (87:2) {#if type === 'text'}
function create_if_block_1$9(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputFieldId*/ ctx[11]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "title", /*tooltip*/ ctx[9]);
			attr(input, "type", "text");
			attr(input, "class", "svelte-1ux37oi");
			toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*internal*/ ctx[10].value);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[52]),
					listen(input, "mouseenter", /*mouseenter_handler_1*/ ctx[19]),
					listen(input, "mouseleave", /*mouseleave_handler_1*/ ctx[20]),
					listen(input, "keypress", /*keypress_handler*/ ctx[21]),
					listen(input, "click", /*click_handler*/ ctx[22])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty[0] & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty[0] & /*tooltip*/ 512) {
				attr(input, "title", /*tooltip*/ ctx[9]);
			}

			if (dirty[0] & /*internal*/ 1024 && input.value !== /*internal*/ ctx[10].value) {
				set_input_value(input, /*internal*/ ctx[10].value);
			}

			if (dirty[0] & /*maximize*/ 128) {
				toggle_class(input, "maximize", /*maximize*/ ctx[7]);
			}

			if (dirty[0] & /*internal*/ 1024) {
				toggle_class(input, "input-error", /*internal*/ ctx[10].isError);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (103:8) {#if label && !labelBeforeCheckbox}
function create_if_block_8(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[3] && create_if_block_9(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[0]);
			attr(label_1, "for", /*inputFieldId*/ ctx[11]);
			set_style(label_1, "width", "100%");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler_8*/ ctx[43]),
					listen(label_1, "mouseleave", /*mouseleave_handler_8*/ ctx[44]),
					listen(label_1, "click", /*click_handler_7*/ ctx[45])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_9(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 1) set_data(t1, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (104:93) {#if icon}
function create_if_block_9(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1ux37oi");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 8 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[3] + " svelte-1ux37oi")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$c(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*internal*/ ctx[10].updateNode || /*prop*/ ctx[8]) return create_if_block$a;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { credentials = false, disabled = false, error = false, i18n, icon, id, indented = false, label, labelBeforeCheckbox = false, maximize, node, placeholder, prop, tooltip, type, value } = $$props;
	id = id || getId(prop);
	credentials = getBooleanFrom(credentials);
	indented = getBooleanFrom(indented);
	disabled = getBooleanFrom(disabled);
	error = getBooleanFrom(error);
	labelBeforeCheckbox = getBooleanFrom(labelBeforeCheckbox);
	const inputFieldId = 'node-input-' + id;
	let defaults = {};

	if (node) {
		defaults = credentials ? node._def.credentials : node._def.defaults;
	}

	let internal = initInternal(defaults[prop], value);

	// Credentials is a special case, which only occurs in Input field. Therefore we won't put the initialization of them in initInternal.
	if (credentials && node.credentials[prop]) {
		internal.value = node.credentials[prop];
	}

	// If credential is type password and has an old value we won't get that value in the editor.
	// Instead there is a "has_"+prop flag to differentate if the UI should show an empty input field or with an value.
	// If the value is "__PWRD__" the value will not be saved/changed till deploy in node.credentials[prop].
	// https://github.com/node-red/node-red/blob/master/packages/node_modules/%40node-red/editor-client/src/js/ui/editor.js
	if (internal.updateNode && credentials && node.credentials['has_' + prop]) {
		internal.value = "__PWRD__";
	}

	icon = icon || defaults[prop]?.icon || '';

	if (label !== false) {
		label = label || defaults[prop]?.label || prop || '';
	}

	placeholder = placeholder || defaults[prop]?.placeholder || '';

	if (!type) {
		let testValue = typeof defaults[prop] !== 'undefined'
		? defaults[prop].value
		: internal.value;

		if (typeof testValue === 'number') {
			type = 'number';
		} else if (typeof testValue === 'boolean') {
			type = 'checkbox';
		} else {
			type = 'text';
		}
	}

	const dispatch = createEventDispatcher();

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_8(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_8(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	function input_input_handler_1() {
		internal.value = to_number(this.value);
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	function input_input_handler_2() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	function input_input_handler_3() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	function input_input_handler_4() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	function input0_input_handler() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	function input1_input_handler() {
		internal.value = this.value;
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	function input_change_handler() {
		internal.value = this.checked;
		(((((($$invalidate(10, internal), $$invalidate(14, node)), $$invalidate(8, prop)), $$invalidate(15, value)), $$invalidate(18, defaults)), $$invalidate(12, error)), $$invalidate(13, id));
	}

	$$self.$$set = $$props => {
		if ('credentials' in $$props) $$invalidate(16, credentials = $$props.credentials);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(12, error = $$props.error);
		if ('i18n' in $$props) $$invalidate(17, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(3, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(13, id = $$props.id);
		if ('indented' in $$props) $$invalidate(4, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('labelBeforeCheckbox' in $$props) $$invalidate(5, labelBeforeCheckbox = $$props.labelBeforeCheckbox);
		if ('maximize' in $$props) $$invalidate(7, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(14, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(8, prop = $$props.prop);
		if ('tooltip' in $$props) $$invalidate(9, tooltip = $$props.tooltip);
		if ('type' in $$props) $$invalidate(6, type = $$props.type);
		if ('value' in $$props) $$invalidate(15, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*node, prop, value, internal, defaults, error, id*/ 324864) {
			{
				$$invalidate(10, internal = getNewInternal(node?.[prop], value, internal, defaults?.[prop]?.validate, error));

				if (internal.updateNode) {
					$$invalidate(14, node[prop] = internal.value, node);
				} else {
					$$invalidate(15, value = internal.value);
				}

				if (!internal.init && internal.valueHasChanged) {
					dispatch('change', { id, value: internal.value }, { cancelable: false });
				}

				$$invalidate(10, internal.init = false, internal);
			}
		}

		if ($$self.$$.dirty[0] & /*label, node, i18n*/ 147457) {
			{
				if (label) {
					$$invalidate(0, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*placeholder, node, i18n*/ 147458) {
			{
				if (placeholder) {
					$$invalidate(1, placeholder = i18nTranslate(RED, node, i18n, placeholder));
				}
			}
		}
	};

	return [
		label,
		placeholder,
		disabled,
		icon,
		indented,
		labelBeforeCheckbox,
		type,
		maximize,
		prop,
		tooltip,
		internal,
		inputFieldId,
		error,
		id,
		node,
		value,
		credentials,
		i18n,
		defaults,
		mouseenter_handler_1,
		mouseleave_handler_1,
		keypress_handler,
		click_handler,
		mouseenter_handler_2,
		mouseleave_handler_2,
		keypress_handler_1,
		click_handler_1,
		mouseenter_handler_3,
		mouseleave_handler_3,
		keypress_handler_2,
		click_handler_2,
		mouseenter_handler_4,
		mouseleave_handler_4,
		keypress_handler_3,
		click_handler_3,
		mouseenter_handler_5,
		mouseleave_handler_5,
		keypress_handler_4,
		click_handler_4,
		mouseenter_handler_6,
		mouseleave_handler_6,
		keypress_handler_5,
		click_handler_5,
		mouseenter_handler_8,
		mouseleave_handler_8,
		click_handler_7,
		mouseenter_handler_7,
		mouseleave_handler_7,
		keypress_handler_6,
		click_handler_6,
		mouseenter_handler,
		mouseleave_handler,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input0_input_handler,
		input1_input_handler,
		input_change_handler
	];
}

class PlainInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$c,
			create_fragment$c,
			safe_not_equal,
			{
				credentials: 16,
				disabled: 2,
				error: 12,
				i18n: 17,
				icon: 3,
				id: 13,
				indented: 4,
				label: 0,
				labelBeforeCheckbox: 5,
				maximize: 7,
				node: 14,
				placeholder: 1,
				prop: 8,
				tooltip: 9,
				type: 6,
				value: 15
			},
			add_css$9,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/ConfigNodeInput.svelte generated by Svelte v3.44.2 */

function add_css$8(target) {
	append_styles(target, "svelte-1grox8e", ".disabled.svelte-1grox8e{pointer-events:none}.maximize.svelte-1grox8e{width:100%}");
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i].id;
	child_ctx[4] = list[i].label;
	return child_ctx;
}

// (107:0) {:else}
function create_else_block$5(ctx) {
	let span;
	let t0;
	let t1;

	return {
		c() {
			span = element("span");
			t0 = text("Error: ");
			t1 = text(/*error*/ ctx[8]);
			attr(span, "class", "maximize svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*error*/ 256) set_data(t1, /*error*/ ctx[8]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (97:0) {#if node && prop}
function create_if_block$9(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let t2;
	let select;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let select_id_value;
	let select_placeholder_value;
	let t3;
	let button;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[1] && create_if_block_1$8(ctx);
	let each_value = /*configNodes*/ ctx[9];
	const get_key = ctx => /*id*/ ctx[5];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$4(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
	}

	button = new Button({
			props: {
				id: "node-input-lookup-" + /*prop*/ ctx[6],
				inline: true,
				disabled: /*disabled*/ ctx[2],
				icon: "pencil"
			}
		});

	button.$on("click", /*editConfigNode*/ ctx[11]);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[4]);
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			create_component(button.$$.fragment);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*prop*/ ctx[6]);
			attr(select, "id", select_id_value = "node-input-" + /*prop*/ ctx[6]);
			attr(select, "placeholder", select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[6]].label);
			select.disabled = /*disabled*/ ctx[2];
			attr(select, "class", "svelte-1grox8e");
			if (/*selectedNode*/ ctx[7] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[17].call(select));
			toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			toggle_class(select, "maximize", /*maximize*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
			insert(target, t2, anchor);
			insert(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*selectedNode*/ ctx[7]);
			insert(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[17]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[15]),
					listen(select, "click", /*click_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$8(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*label*/ 16) set_data(t1, /*label*/ ctx[4]);

			if (!current || dirty & /*prop*/ 64 && label_1_for_value !== (label_1_for_value = "node-input-" + /*prop*/ ctx[6])) {
				attr(label_1, "for", label_1_for_value);
			}

			if (dirty & /*configNodes*/ 512) {
				each_value = /*configNodes*/ ctx[9];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$4, null, get_each_context$4);
			}

			if (!current || dirty & /*prop*/ 64 && select_id_value !== (select_id_value = "node-input-" + /*prop*/ ctx[6])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*prop*/ 64 && select_placeholder_value !== (select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[6]].label)) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (!current || dirty & /*disabled*/ 4) {
				select.disabled = /*disabled*/ ctx[2];
			}

			if (dirty & /*selectedNode, configNodes*/ 640) {
				select_option(select, /*selectedNode*/ ctx[7]);
			}

			if (dirty & /*selectedNode*/ 128) {
				toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			}

			if (dirty & /*maximize*/ 8) {
				toggle_class(select, "maximize", /*maximize*/ ctx[3]);
			}

			const button_changes = {};
			if (dirty & /*prop*/ 64) button_changes.id = "node-input-lookup-" + /*prop*/ ctx[6];
			if (dirty & /*disabled*/ 4) button_changes.disabled = /*disabled*/ ctx[2];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			if (detaching) detach(t2);
			if (detaching) detach(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t3);
			destroy_component(button, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (98:33) {#if icon}
function create_if_block_1$8(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[1] + " svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[1] + " svelte-1grox8e")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (102:6) {#each configNodes as { id, label }
function create_each_block$4(key_1, ctx) {
	let option;
	let t_value = /*label*/ ctx[4] + "";
	let t;
	let option_value_value;

	return {
		key: key_1,
		first: null,
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*id*/ ctx[5];
			option.value = option.__value;
			this.first = option;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*configNodes*/ 512 && t_value !== (t_value = /*label*/ ctx[4] + "")) set_data(t, t_value);

			if (dirty & /*configNodes*/ 512 && option_value_value !== (option_value_value = /*id*/ ctx[5])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$b(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$9, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0] && /*prop*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { node, prop, icon, label, id, disabled = false, maximize = true, i18n } = $$props;
	id = id || getId(prop);
	let error = '';
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);

	if (!node) {
		node = {};
		error = "No node property given.";
	} else if (!prop) {
		error = "No property name given.";
	}

	const dispatch = createEventDispatcher();
	let defaults = node._def.defaults;
	icon = icon || defaults?.[prop]?.icon || '';
	label = label || defaults[prop] && defaults[prop].label || prop;
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let configNodes = [];
	let previouslySelectedNode = node[prop] || '_ADD_';
	let selectedNode = node[prop] || '_ADD_';

	function updateConfigNodes() {
		$$invalidate(9, configNodes = []);
		const type = defaults[prop].type;
		const node_def = RED.nodes.getType(type);

		RED.nodes.eachConfig(function (config) {
			if (config.type === type) {
				let label = '';

				if (typeof node_def.label === 'function') {
					label = node_def.label.call(config);
				} else {
					label = node_def.label;
				}

				configNodes.push({ id: config.id, label });
			}
		});

		$$invalidate(9, configNodes = [...configNodes, { id: '_ADD_', label: `Add new ${type}...` }]);
	}

	onMount(() => {
		updateConfigNodes();

		RED.events.on('nodes:add', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
				$$invalidate(7, selectedNode = e.id);
			}
		});

		RED.events.on('nodes:change', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
			}
		});

		RED.events.on('nodes:remove', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();

				// Always select '_ADD_' after deleting (standard behaviour)
				// otherwise it breaks the node if only one other option was available
				$$invalidate(7, selectedNode = '_ADD_');
			}
		});
	});

	function editConfigNode() {
		// The prefix is omitted so the select gets updated by us and not by Node-RED
		RED.editor.editConfig(prop, defaults[prop].type, selectedNode); /*, 'node-input' */
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		selectedNode = select_value(this);
		$$invalidate(7, selectedNode);
		$$invalidate(9, configNodes);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('prop' in $$props) $$invalidate(6, prop = $$props.prop);
		if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(3, maximize = $$props.maximize);
		if ('i18n' in $$props) $$invalidate(12, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selectedNode, previouslySelectedNode, prop*/ 8384) {
			{
				if (selectedNode !== previouslySelectedNode) {
					$$invalidate(0, node[prop] = selectedNode, node);

					dispatch(
						'change',
						{
							before: previouslySelectedNode,
							after: selectedNode
						},
						{ cancelable: false }
					);

					$$invalidate(13, previouslySelectedNode = selectedNode);
				}
			}
		}
	};

	return [
		node,
		icon,
		disabled,
		maximize,
		label,
		id,
		prop,
		selectedNode,
		error,
		configNodes,
		defaults,
		editConfigNode,
		i18n,
		previouslySelectedNode,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		select_change_handler
	];
}

class ConfigNodeInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$b,
			create_fragment$b,
			safe_not_equal,
			{
				node: 0,
				prop: 6,
				icon: 1,
				label: 4,
				id: 5,
				disabled: 2,
				maximize: 3,
				i18n: 12
			},
			add_css$8
		);
	}
}

/* node_modules/svelte-integration-red/components/Input.svelte generated by Svelte v3.44.2 */

function add_css$7(target) {
	append_styles(target, "svelte-p54s0v", ".sir-Input-Container{display:inline-flex;align-items:center;width:100%}");
}

// (48:2) {:else}
function create_else_block$4(ctx) {
	let plaininput;
	let updating_node;
	let updating_prop;
	let updating_icon;
	let updating_label;
	let updating_disabled;
	let updating_value;
	let updating_type;
	let updating_placeholder;
	let updating_maximize;
	let updating_error;
	let updating_tooltip;
	let current;

	function plaininput_node_binding(value) {
		/*plaininput_node_binding*/ ctx[30](value);
	}

	function plaininput_prop_binding(value) {
		/*plaininput_prop_binding*/ ctx[31](value);
	}

	function plaininput_icon_binding(value) {
		/*plaininput_icon_binding*/ ctx[32](value);
	}

	function plaininput_label_binding(value) {
		/*plaininput_label_binding*/ ctx[33](value);
	}

	function plaininput_disabled_binding(value) {
		/*plaininput_disabled_binding*/ ctx[34](value);
	}

	function plaininput_value_binding(value) {
		/*plaininput_value_binding*/ ctx[35](value);
	}

	function plaininput_type_binding(value) {
		/*plaininput_type_binding*/ ctx[36](value);
	}

	function plaininput_placeholder_binding(value) {
		/*plaininput_placeholder_binding*/ ctx[37](value);
	}

	function plaininput_maximize_binding(value) {
		/*plaininput_maximize_binding*/ ctx[38](value);
	}

	function plaininput_error_binding(value) {
		/*plaininput_error_binding*/ ctx[39](value);
	}

	function plaininput_tooltip_binding(value) {
		/*plaininput_tooltip_binding*/ ctx[40](value);
	}

	let plaininput_props = {
		i18n: /*i18n*/ ctx[18],
		indented: /*indented*/ ctx[6],
		credentials: /*credentials*/ ctx[16],
		labelBeforeCheckbox: /*labelBeforeCheckbox*/ ctx[9],
		id: /*id*/ ctx[5]
	};

	if (/*node*/ ctx[11] !== void 0) {
		plaininput_props.node = /*node*/ ctx[11];
	}

	if (/*prop*/ ctx[13] !== void 0) {
		plaininput_props.prop = /*prop*/ ctx[13];
	}

	if (/*icon*/ ctx[4] !== void 0) {
		plaininput_props.icon = /*icon*/ ctx[4];
	}

	if (/*label*/ ctx[8] !== void 0) {
		plaininput_props.label = /*label*/ ctx[8];
	}

	if (/*disabled*/ ctx[2] !== void 0) {
		plaininput_props.disabled = /*disabled*/ ctx[2];
	}

	if (/*value*/ ctx[1] !== void 0) {
		plaininput_props.value = /*value*/ ctx[1];
	}

	if (/*type*/ ctx[0] !== void 0) {
		plaininput_props.type = /*type*/ ctx[0];
	}

	if (/*placeholder*/ ctx[12] !== void 0) {
		plaininput_props.placeholder = /*placeholder*/ ctx[12];
	}

	if (/*maximize*/ ctx[10] !== void 0) {
		plaininput_props.maximize = /*maximize*/ ctx[10];
	}

	if (/*error*/ ctx[3] !== void 0) {
		plaininput_props.error = /*error*/ ctx[3];
	}

	if (/*tooltip*/ ctx[14] !== void 0) {
		plaininput_props.tooltip = /*tooltip*/ ctx[14];
	}

	plaininput = new PlainInput({ props: plaininput_props });
	binding_callbacks.push(() => bind(plaininput, 'node', plaininput_node_binding));
	binding_callbacks.push(() => bind(plaininput, 'prop', plaininput_prop_binding));
	binding_callbacks.push(() => bind(plaininput, 'icon', plaininput_icon_binding));
	binding_callbacks.push(() => bind(plaininput, 'label', plaininput_label_binding));
	binding_callbacks.push(() => bind(plaininput, 'disabled', plaininput_disabled_binding));
	binding_callbacks.push(() => bind(plaininput, 'value', plaininput_value_binding));
	binding_callbacks.push(() => bind(plaininput, 'type', plaininput_type_binding));
	binding_callbacks.push(() => bind(plaininput, 'placeholder', plaininput_placeholder_binding));
	binding_callbacks.push(() => bind(plaininput, 'maximize', plaininput_maximize_binding));
	binding_callbacks.push(() => bind(plaininput, 'error', plaininput_error_binding));
	binding_callbacks.push(() => bind(plaininput, 'tooltip', plaininput_tooltip_binding));
	plaininput.$on("change", /*change_handler_1*/ ctx[41]);
	plaininput.$on("mouseenter", /*mouseenter_handler_1*/ ctx[42]);
	plaininput.$on("mouseleave", /*mouseleave_handler_1*/ ctx[43]);
	plaininput.$on("click", /*click_handler_1*/ ctx[44]);
	plaininput.$on("keypress", /*keypress_handler*/ ctx[45]);

	return {
		c() {
			create_component(plaininput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaininput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaininput_changes = {};
			if (dirty[0] & /*i18n*/ 262144) plaininput_changes.i18n = /*i18n*/ ctx[18];
			if (dirty[0] & /*indented*/ 64) plaininput_changes.indented = /*indented*/ ctx[6];
			if (dirty[0] & /*credentials*/ 65536) plaininput_changes.credentials = /*credentials*/ ctx[16];
			if (dirty[0] & /*labelBeforeCheckbox*/ 512) plaininput_changes.labelBeforeCheckbox = /*labelBeforeCheckbox*/ ctx[9];
			if (dirty[0] & /*id*/ 32) plaininput_changes.id = /*id*/ ctx[5];

			if (!updating_node && dirty[0] & /*node*/ 2048) {
				updating_node = true;
				plaininput_changes.node = /*node*/ ctx[11];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8192) {
				updating_prop = true;
				plaininput_changes.prop = /*prop*/ ctx[13];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_icon && dirty[0] & /*icon*/ 16) {
				updating_icon = true;
				plaininput_changes.icon = /*icon*/ ctx[4];
				add_flush_callback(() => updating_icon = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 256) {
				updating_label = true;
				plaininput_changes.label = /*label*/ ctx[8];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 4) {
				updating_disabled = true;
				plaininput_changes.disabled = /*disabled*/ ctx[2];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 2) {
				updating_value = true;
				plaininput_changes.value = /*value*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty[0] & /*type*/ 1) {
				updating_type = true;
				plaininput_changes.type = /*type*/ ctx[0];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_placeholder && dirty[0] & /*placeholder*/ 4096) {
				updating_placeholder = true;
				plaininput_changes.placeholder = /*placeholder*/ ctx[12];
				add_flush_callback(() => updating_placeholder = false);
			}

			if (!updating_maximize && dirty[0] & /*maximize*/ 1024) {
				updating_maximize = true;
				plaininput_changes.maximize = /*maximize*/ ctx[10];
				add_flush_callback(() => updating_maximize = false);
			}

			if (!updating_error && dirty[0] & /*error*/ 8) {
				updating_error = true;
				plaininput_changes.error = /*error*/ ctx[3];
				add_flush_callback(() => updating_error = false);
			}

			if (!updating_tooltip && dirty[0] & /*tooltip*/ 16384) {
				updating_tooltip = true;
				plaininput_changes.tooltip = /*tooltip*/ ctx[14];
				add_flush_callback(() => updating_tooltip = false);
			}

			plaininput.$set(plaininput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaininput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaininput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaininput, detaching);
		}
	};
}

// (46:2) {#if type === 'config'}
function create_if_block$8(ctx) {
	let confignodeinput;
	let updating_node;
	let updating_prop;
	let updating_label;
	let updating_disabled;
	let updating_tooltip;
	let current;

	function confignodeinput_node_binding(value) {
		/*confignodeinput_node_binding*/ ctx[21](value);
	}

	function confignodeinput_prop_binding(value) {
		/*confignodeinput_prop_binding*/ ctx[22](value);
	}

	function confignodeinput_label_binding(value) {
		/*confignodeinput_label_binding*/ ctx[23](value);
	}

	function confignodeinput_disabled_binding(value) {
		/*confignodeinput_disabled_binding*/ ctx[24](value);
	}

	function confignodeinput_tooltip_binding(value) {
		/*confignodeinput_tooltip_binding*/ ctx[25](value);
	}

	let confignodeinput_props = {
		icon: /*icon*/ ctx[4],
		i18n: /*i18n*/ ctx[18],
		indented: /*indented*/ ctx[6]
	};

	if (/*node*/ ctx[11] !== void 0) {
		confignodeinput_props.node = /*node*/ ctx[11];
	}

	if (/*prop*/ ctx[13] !== void 0) {
		confignodeinput_props.prop = /*prop*/ ctx[13];
	}

	if (/*label*/ ctx[8] !== void 0) {
		confignodeinput_props.label = /*label*/ ctx[8];
	}

	if (/*disabled*/ ctx[2] !== void 0) {
		confignodeinput_props.disabled = /*disabled*/ ctx[2];
	}

	if (/*tooltip*/ ctx[14] !== void 0) {
		confignodeinput_props.tooltip = /*tooltip*/ ctx[14];
	}

	confignodeinput = new ConfigNodeInput({ props: confignodeinput_props });
	binding_callbacks.push(() => bind(confignodeinput, 'node', confignodeinput_node_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'prop', confignodeinput_prop_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'label', confignodeinput_label_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'disabled', confignodeinput_disabled_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'tooltip', confignodeinput_tooltip_binding));
	confignodeinput.$on("change", /*change_handler*/ ctx[26]);
	confignodeinput.$on("mouseenter", /*mouseenter_handler*/ ctx[27]);
	confignodeinput.$on("mouseleave", /*mouseleave_handler*/ ctx[28]);
	confignodeinput.$on("click", /*click_handler*/ ctx[29]);

	return {
		c() {
			create_component(confignodeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(confignodeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const confignodeinput_changes = {};
			if (dirty[0] & /*icon*/ 16) confignodeinput_changes.icon = /*icon*/ ctx[4];
			if (dirty[0] & /*i18n*/ 262144) confignodeinput_changes.i18n = /*i18n*/ ctx[18];
			if (dirty[0] & /*indented*/ 64) confignodeinput_changes.indented = /*indented*/ ctx[6];

			if (!updating_node && dirty[0] & /*node*/ 2048) {
				updating_node = true;
				confignodeinput_changes.node = /*node*/ ctx[11];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8192) {
				updating_prop = true;
				confignodeinput_changes.prop = /*prop*/ ctx[13];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 256) {
				updating_label = true;
				confignodeinput_changes.label = /*label*/ ctx[8];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 4) {
				updating_disabled = true;
				confignodeinput_changes.disabled = /*disabled*/ ctx[2];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_tooltip && dirty[0] & /*tooltip*/ 16384) {
				updating_tooltip = true;
				confignodeinput_changes.tooltip = /*tooltip*/ ctx[14];
				add_flush_callback(() => updating_tooltip = false);
			}

			confignodeinput.$set(confignodeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(confignodeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(confignodeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(confignodeinput, detaching);
		}
	};
}

// (45:0) <Row id="sir-Input-Container-{id}" clazz="{clazz} sir-Input-Container" {inline} {maximize} {fading} {style}>
function create_default_slot$7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$8, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[0] === 'config') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$a(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Input-Container-" + /*id*/ ctx[5],
				clazz: "" + (/*clazz*/ ctx[15] + " sir-Input-Container"),
				inline: /*inline*/ ctx[7],
				maximize: /*maximize*/ ctx[10],
				fading: /*fading*/ ctx[17],
				style: /*style*/ ctx[19],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*id*/ 32) row_changes.id = "sir-Input-Container-" + /*id*/ ctx[5];
			if (dirty[0] & /*clazz*/ 32768) row_changes.clazz = "" + (/*clazz*/ ctx[15] + " sir-Input-Container");
			if (dirty[0] & /*inline*/ 128) row_changes.inline = /*inline*/ ctx[7];
			if (dirty[0] & /*maximize*/ 1024) row_changes.maximize = /*maximize*/ ctx[10];
			if (dirty[0] & /*fading*/ 131072) row_changes.fading = /*fading*/ ctx[17];
			if (dirty[0] & /*style*/ 524288) row_changes.style = /*style*/ ctx[19];

			if (dirty[0] & /*icon, i18n, indented, node, prop, label, disabled, tooltip, type, credentials, labelBeforeCheckbox, id, value, placeholder, maximize, error*/ 360319 | dirty[1] & /*$$scope*/ 32768) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { checked, clazz = '', credentials, disabled = false, error, fading = true, i18n, icon, id, indented = false, inline = false, label, labelBeforeCheckbox = false, maximize = true, node, placeholder, prop, style = '', tooltip = '', type, value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);
	labelBeforeCheckbox = getBooleanFrom(labelBeforeCheckbox);

	if (typeof error !== 'undefined') {
		error = getBooleanFrom(error);
	}

	// loading node: if only node is bound for any input field in the svelte code, value would be undefined if the input field is empty or false
	if (type !== 'checkbox' && typeof value === 'undefined' && typeof node?.[prop] !== 'undefined') {
		value = node[prop];
	} else if (type === 'checkbox' && typeof value === 'undefined') {
		// special case for checkbox: bind:checked (offical property) could also be used and has prio before getting it possibly from node[prop]
		if (typeof checked !== 'undefined') {
			value = getBooleanFrom(checked);
		} else if (typeof node?.[prop] !== 'undefined') {
			value = getBooleanFrom(node[prop]);
		}
	}

	function confignodeinput_node_binding(value) {
		node = value;
		$$invalidate(11, node);
	}

	function confignodeinput_prop_binding(value) {
		prop = value;
		$$invalidate(13, prop);
	}

	function confignodeinput_label_binding(value) {
		label = value;
		$$invalidate(8, label);
	}

	function confignodeinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(2, disabled);
	}

	function confignodeinput_tooltip_binding(value) {
		tooltip = value;
		$$invalidate(14, tooltip);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function plaininput_node_binding(value) {
		node = value;
		$$invalidate(11, node);
	}

	function plaininput_prop_binding(value) {
		prop = value;
		$$invalidate(13, prop);
	}

	function plaininput_icon_binding(value) {
		icon = value;
		$$invalidate(4, icon);
	}

	function plaininput_label_binding(value) {
		label = value;
		$$invalidate(8, label);
	}

	function plaininput_disabled_binding(value) {
		disabled = value;
		$$invalidate(2, disabled);
	}

	function plaininput_value_binding(value$1) {
		value = value$1;
		$$invalidate(1, value);
	}

	function plaininput_type_binding(value) {
		type = value;
		$$invalidate(0, type);
	}

	function plaininput_placeholder_binding(value) {
		placeholder = value;
		$$invalidate(12, placeholder);
	}

	function plaininput_maximize_binding(value) {
		maximize = value;
		$$invalidate(10, maximize);
	}

	function plaininput_error_binding(value) {
		error = value;
		$$invalidate(3, error);
	}

	function plaininput_tooltip_binding(value) {
		tooltip = value;
		$$invalidate(14, tooltip);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('checked' in $$props) $$invalidate(20, checked = $$props.checked);
		if ('clazz' in $$props) $$invalidate(15, clazz = $$props.clazz);
		if ('credentials' in $$props) $$invalidate(16, credentials = $$props.credentials);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(3, error = $$props.error);
		if ('fading' in $$props) $$invalidate(17, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(18, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('indented' in $$props) $$invalidate(6, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(7, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(8, label = $$props.label);
		if ('labelBeforeCheckbox' in $$props) $$invalidate(9, labelBeforeCheckbox = $$props.labelBeforeCheckbox);
		if ('maximize' in $$props) $$invalidate(10, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(11, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(12, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(13, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(19, style = $$props.style);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*type, checked, value*/ 1048579) {
			// if checkbox has checked bound it must be updated with the value property (needed)
			if (type === 'checkbox' && typeof checked !== 'undefined' && typeof value !== 'undefined') {
				$$invalidate(20, checked = getBooleanFrom(value));
			}
		}
	};

	return [
		type,
		value,
		disabled,
		error,
		icon,
		id,
		indented,
		inline,
		label,
		labelBeforeCheckbox,
		maximize,
		node,
		placeholder,
		prop,
		tooltip,
		clazz,
		credentials,
		fading,
		i18n,
		style,
		checked,
		confignodeinput_node_binding,
		confignodeinput_prop_binding,
		confignodeinput_label_binding,
		confignodeinput_disabled_binding,
		confignodeinput_tooltip_binding,
		change_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		plaininput_node_binding,
		plaininput_prop_binding,
		plaininput_icon_binding,
		plaininput_label_binding,
		plaininput_disabled_binding,
		plaininput_value_binding,
		plaininput_type_binding,
		plaininput_placeholder_binding,
		plaininput_maximize_binding,
		plaininput_error_binding,
		plaininput_tooltip_binding,
		change_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1,
		click_handler_1,
		keypress_handler
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$a,
			create_fragment$a,
			safe_not_equal,
			{
				checked: 20,
				clazz: 15,
				credentials: 16,
				disabled: 2,
				error: 3,
				fading: 17,
				i18n: 18,
				icon: 4,
				id: 5,
				indented: 6,
				inline: 7,
				label: 8,
				labelBeforeCheckbox: 9,
				maximize: 10,
				node: 11,
				placeholder: 12,
				prop: 13,
				style: 19,
				tooltip: 14,
				type: 0,
				value: 1
			},
			add_css$7,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/Select.svelte generated by Svelte v3.44.2 */

function add_css$6(target) {
	append_styles(target, "svelte-1m0uqs8", ".disabled.svelte-1m0uqs8{pointer-events:none}.maximize.svelte-1m0uqs8{width:100%}.sir-Input-Container select, .sir-Select select{padding-left:3px}.sir-Select{display:inline-flex;width:100%;align-items:center}");
}

// (55:2) {#if label}
function create_if_block$7(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let if_block = /*icon*/ ctx[4] && create_if_block_1$7(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$7(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);

			if (dirty & /*id*/ 1 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[0])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (56:33) {#if icon}
function create_if_block_1$7(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1m0uqs8");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1m0uqs8")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (54:0) <Row id="sir-Select-{id}-Container" clazz="{clazz} sir-Select" {inline} {style} {fading}>
function create_default_slot$6(ctx) {
	let t;
	let select;
	let select_id_value;
	let select_placeholder_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[1] && create_if_block$7(ctx);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			select = element("select");
			if (default_slot) default_slot.c();
			attr(select, "id", select_id_value = "node-input-" + /*id*/ ctx[0]);
			select.disabled = /*disabled*/ ctx[3];
			attr(select, "placeholder", select_placeholder_value = /*node*/ ctx[2] && /*defaults*/ ctx[12][/*prop*/ ctx[9]].label || '');
			attr(select, "class", "svelte-1m0uqs8");
			if (/*internal*/ ctx[11].value === void 0) add_render_callback(() => /*select_change_handler*/ ctx[19].call(select));
			toggle_class(select, "maximize", /*maximize*/ ctx[6]);
			toggle_class(select, "input-error", /*internal*/ ctx[11].isError);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*internal*/ ctx[11].value);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[19]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[17]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 1 && select_id_value !== (select_id_value = "node-input-" + /*id*/ ctx[0])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*disabled*/ 8) {
				select.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*node, prop*/ 516 && select_placeholder_value !== (select_placeholder_value = /*node*/ ctx[2] && /*defaults*/ ctx[12][/*prop*/ ctx[9]].label || '')) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (dirty & /*internal*/ 2048) {
				select_option(select, /*internal*/ ctx[11].value);
			}

			if (dirty & /*maximize*/ 64) {
				toggle_class(select, "maximize", /*maximize*/ ctx[6]);
			}

			if (dirty & /*internal*/ 2048) {
				toggle_class(select, "input-error", /*internal*/ ctx[11].isError);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$9(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-Select-" + /*id*/ ctx[0] + "-Container",
				clazz: "" + (/*clazz*/ ctx[7] + " sir-Select"),
				inline: /*inline*/ ctx[5],
				style: /*style*/ ctx[10],
				fading: /*fading*/ ctx[8],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 1) row_changes.id = "sir-Select-" + /*id*/ ctx[0] + "-Container";
			if (dirty & /*clazz*/ 128) row_changes.clazz = "" + (/*clazz*/ ctx[7] + " sir-Select");
			if (dirty & /*inline*/ 32) row_changes.inline = /*inline*/ ctx[5];
			if (dirty & /*style*/ 1024) row_changes.style = /*style*/ ctx[10];
			if (dirty & /*fading*/ 256) row_changes.fading = /*fading*/ ctx[8];

			if (dirty & /*$$scope, id, disabled, node, prop, internal, maximize, label, icon*/ 1051231) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', disabled = false, error = false, fading = true, i18n, icon, id, inline = false, label, maximize = true, node, prop, style = "", value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	error = getBooleanFrom(error);
	let defaults = node ? node._def.defaults : {};
	icon = icon || defaults?.[prop]?.icon || '';

	if (label !== false) {
		label = label || node && (defaults[prop] && defaults[prop].label || prop);
	}

	const dispatch = createEventDispatcher();
	let internal = initInternal(defaults[prop], value);

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		internal.value = select_value(this);
		(((((($$invalidate(11, internal), $$invalidate(2, node)), $$invalidate(9, prop)), $$invalidate(14, value)), $$invalidate(12, defaults)), $$invalidate(13, error)), $$invalidate(0, id));
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(7, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('error' in $$props) $$invalidate(13, error = $$props.error);
		if ('fading' in $$props) $$invalidate(8, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(15, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('inline' in $$props) $$invalidate(5, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(2, node = $$props.node);
		if ('prop' in $$props) $$invalidate(9, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
		if ('value' in $$props) $$invalidate(14, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*node, prop, value, internal, error, id*/ 27141) {
			{
				$$invalidate(11, internal = getNewInternal(node?.[prop], value, internal, defaults?.[prop]?.validate, error));

				if (internal.updateNode) {
					$$invalidate(2, node[prop] = internal.value, node);
				} else {
					$$invalidate(14, value = internal.value);
				}

				if (!internal.init && internal.valueHasChanged) {
					dispatch('change', { id, value: internal.value }, { cancelable: false });
				}

				$$invalidate(11, internal.init = false, internal);
			}
		}

		if ($$self.$$.dirty & /*label, node, i18n*/ 32774) {
			{
				if (label) {
					$$invalidate(1, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}
	};

	return [
		id,
		label,
		node,
		disabled,
		icon,
		inline,
		maximize,
		clazz,
		fading,
		prop,
		style,
		internal,
		defaults,
		error,
		value,
		i18n,
		slots,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler,
		$$scope
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				clazz: 7,
				disabled: 3,
				error: 13,
				fading: 8,
				i18n: 15,
				icon: 4,
				id: 0,
				inline: 5,
				label: 1,
				maximize: 6,
				node: 2,
				prop: 9,
				style: 10,
				value: 14
			},
			add_css$6
		);
	}
}

/* node_modules/svelte-integration-red/components/TabbedPane.svelte generated by Svelte v3.44.2 */

function add_css$5(target) {
	append_styles(target, "svelte-10kvkej", ".sir-TabedPane.svelte-10kvkej.svelte-10kvkej{margin-bottom:12px;overflow:hidden}.sir-TabedPane.svelte-10kvkej ul.sir-Tablist li.svelte-10kvkej{min-width:80px}.scrollButton.svelte-10kvkej.svelte-10kvkej{width:20px;margin-top:3px;position:absolute;z-index:10;border:1px solid var(--red-ui-primary-border-color);height:30px;cursor:pointer;background:var(--red-ui-primary-background)}.scrollButton.svelte-10kvkej.svelte-10kvkej:hover{background:var(--red-ui-secondary-background-hover)}.scrollButtonLeft.svelte-10kvkej.svelte-10kvkej{left:0px}.scrollButtonRight.svelte-10kvkej.svelte-10kvkej{top:0px;right:0px}.hasScrollButtons.svelte-10kvkej.svelte-10kvkej{margin-left:21px;margin-right:22px}.scrollButton.svelte-10kvkej i.svelte-10kvkej{padding-left:7px;padding-top:8px}.sir-TabedPaneContainer.svelte-10kvkej.svelte-10kvkej{position:relative}");
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i].id;
	child_ctx[26] = list[i].name;
	child_ctx[27] = list[i].icon;
	child_ctx[29] = i;
	return child_ctx;
}

// (124:2) {#if showScrollButton}
function create_if_block_2$6(ctx) {
	let div;
	let i;
	let div_id_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			i = element("i");
			attr(i, "class", "fa fa-caret-left svelte-10kvkej");
			attr(div, "id", div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollLeft");
			attr(div, "class", "scrollButton scrollButtonLeft svelte-10kvkej");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, i);

			if (!mounted) {
				dispose = [
					listen(div, "mouseover", /*mouseover_handler*/ ctx[15]),
					listen(div, "focus", /*focus_handler*/ ctx[16]),
					listen(div, "mouseout", /*stopScroll*/ ctx[9]),
					listen(div, "blur", /*stopScroll*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 2 && div_id_value !== (div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollLeft")) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (139:14) {#if icon}
function create_if_block_1$6(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "red-ui-tab-icon fa fa-" + /*icon*/ ctx[27] + " svelte-10kvkej");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*shadowTabs*/ 16 && i_class_value !== (i_class_value = "red-ui-tab-icon fa fa-" + /*icon*/ ctx[27] + " svelte-10kvkej")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (135:8) {#each shadowTabs as {id, name, icon}
function create_each_block$3(key_1, ctx) {
	let li;
	let a;
	let t0;
	let span0;
	let t1_value = /*name*/ ctx[26] + "";
	let t1;
	let t2;
	let span1;
	let t3;
	let span2;
	let a_href_value;
	let a_title_value;
	let t4;
	let li_id_value;
	let li_style_value;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[27] && create_if_block_1$6(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[17](/*id*/ ctx[1]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			a = element("a");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			t1 = text(t1_value);
			t2 = space();
			span1 = element("span");
			t3 = space();
			span2 = element("span");
			t4 = space();
			attr(span0, "class", "red-ui-text-bidi-aware");
			attr(span0, "dir", "");
			attr(span1, "class", "red-ui-tabs-fade");
			attr(span2, "class", "red-ui-tabs-badges");
			attr(a, "href", a_href_value = '#');
			attr(a, "class", "red-ui-tab-label");
			attr(a, "title", a_title_value = /*name*/ ctx[26]);
			attr(a, "draggable", "false");
			attr(li, "id", li_id_value = "sir-Tabselection-" + /*id*/ ctx[1]);
			attr(li, "class", "red-ui-tab svelte-10kvkej");
			attr(li, "style", li_style_value = "width: " + /*tabWidth*/ ctx[5]);
			toggle_class(li, "active", /*active*/ ctx[0] === /*id*/ ctx[1]);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			if (if_block) if_block.m(a, null);
			append(a, t0);
			append(a, span0);
			append(span0, t1);
			append(a, t2);
			append(a, span1);
			append(a, t3);
			append(a, span2);
			append(li, t4);

			if (!mounted) {
				dispose = listen(a, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*icon*/ ctx[27]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(a, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*shadowTabs*/ 16 && t1_value !== (t1_value = /*name*/ ctx[26] + "")) set_data(t1, t1_value);

			if (dirty & /*shadowTabs*/ 16 && a_title_value !== (a_title_value = /*name*/ ctx[26])) {
				attr(a, "title", a_title_value);
			}

			if (dirty & /*shadowTabs*/ 16 && li_id_value !== (li_id_value = "sir-Tabselection-" + /*id*/ ctx[1])) {
				attr(li, "id", li_id_value);
			}

			if (dirty & /*tabWidth*/ 32 && li_style_value !== (li_style_value = "width: " + /*tabWidth*/ ctx[5])) {
				attr(li, "style", li_style_value);
			}

			if (dirty & /*active, shadowTabs*/ 17) {
				toggle_class(li, "active", /*active*/ ctx[0] === /*id*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (152:2) {#if showScrollButton}
function create_if_block$6(ctx) {
	let div;
	let i;
	let div_id_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			i = element("i");
			attr(i, "class", "fa fa-caret-right svelte-10kvkej");
			attr(div, "id", div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollRight");
			attr(div, "class", "scrollButton scrollButtonRight svelte-10kvkej");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, i);

			if (!mounted) {
				dispose = [
					listen(div, "mouseover", /*mouseover_handler_1*/ ctx[18]),
					listen(div, "focus", /*focus_handler_1*/ ctx[19]),
					listen(div, "mouseout", /*stopScroll*/ ctx[9]),
					listen(div, "blur", /*stopScroll*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 2 && div_id_value !== (div_id_value = "tabs-" + /*id*/ ctx[1] + "-scrollRight")) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$8(ctx) {
	let div1;
	let t0;
	let div0;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let ul_id_value;
	let div0_id_value;
	let t1;
	let div1_class_value;
	let t2;
	let div2;
	let div2_id_value;
	let current;
	let if_block0 = /*showScrollButton*/ ctx[6] && create_if_block_2$6(ctx);
	let each_value = /*shadowTabs*/ ctx[4];
	const get_key = ctx => /*i*/ ctx[29];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	let if_block1 = /*showScrollButton*/ ctx[6] && create_if_block$6(ctx);
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			attr(ul, "id", ul_id_value = "tabs-" + /*id*/ ctx[1]);
			attr(ul, "class", "sir-Tablist");
			attr(div0, "id", div0_id_value = "sir-TabedPane-" + /*id*/ ctx[1]);
			attr(div0, "class", "sir-TabedPane red-ui-tabs svelte-10kvkej");
			toggle_class(div0, "hasScrollButtons", /*showScrollButton*/ ctx[6]);
			attr(div1, "class", div1_class_value = "" + (/*clazz*/ ctx[2] + " sir-TabedPaneContainer" + " svelte-10kvkej"));
			attr(div1, "style", /*style*/ ctx[3]);
			attr(div2, "id", div2_id_value = "tabs-content-" + /*id*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			insert(target, t2, anchor);
			insert(target, div2, anchor);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*showScrollButton*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$6(ctx);
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*shadowTabs, tabWidth, active, showTabContent*/ 177) {
				each_value = /*shadowTabs*/ ctx[4];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, destroy_block, create_each_block$3, null, get_each_context$3);
			}

			if (!current || dirty & /*id*/ 2 && ul_id_value !== (ul_id_value = "tabs-" + /*id*/ ctx[1])) {
				attr(ul, "id", ul_id_value);
			}

			if (!current || dirty & /*id*/ 2 && div0_id_value !== (div0_id_value = "sir-TabedPane-" + /*id*/ ctx[1])) {
				attr(div0, "id", div0_id_value);
			}

			if (dirty & /*showScrollButton*/ 64) {
				toggle_class(div0, "hasScrollButtons", /*showScrollButton*/ ctx[6]);
			}

			if (/*showScrollButton*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*clazz*/ 4 && div1_class_value !== (div1_class_value = "" + (/*clazz*/ ctx[2] + " sir-TabedPaneContainer" + " svelte-10kvkej"))) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*style*/ 8) {
				attr(div1, "style", /*style*/ ctx[3]);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 2 && div2_id_value !== (div2_id_value = "tabs-content-" + /*id*/ ctx[1])) {
				attr(div2, "id", div2_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block1) if_block1.d();
			if (detaching) detach(t2);
			if (detaching) detach(div2);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { active, clazz = '', i18n, id, node, style = "", tabs = { "0": "No tabs defined" } } = $$props;
	id = id || getId();

	// lets keep the tabs property as an Object to ensure for the user that each key name only exists one time. Intern we can handle it as an array.
	let shadowTabs = [];

	let tabWidth = 0;

	const updateTabs = () => {
		$$invalidate(4, shadowTabs = []);

		Object.keys(tabs).forEach(tabKey => {
			if (typeof tabs[tabKey] === "string") {
				// downward compatible
				shadowTabs.push({
					id: tabKey,
					name: i18nTranslate(RED, node, i18n, tabs[tabKey])
				});
			} else {
				const tabClone = Object.assign({}, tabs[tabKey]);
				tabClone.id = tabClone.id || tabKey;
				tabClone.name = i18nTranslate(RED, node, i18n, tabClone.name);
				shadowTabs.push(tabClone);
			}
		});

		// tabWidth = (100 / shadowTabs.length) + '%'
		$$invalidate(5, tabWidth = 'calc(' + 100 / shadowTabs.length + '% - 6px);');
	};

	const showTabContent = tabKey => {
		const tabsContent = document.getElementById('tabs-content-' + id).querySelectorAll('div.sir-Tab');

		tabsContent.forEach(tab => {
			tab.style.display = 'none';
		});

		// class is unique here...
		document.getElementById('tabs-content-' + id).getElementsByClassName('tab-' + tabKey)[0].style.display = 'block';

		$$invalidate(0, active = tabKey);
	};

	// Button left and right for scrolling!
	let overflowIntervall;

	let showScrollButton = false;

	const checkOverflow = (_e, once = false) => {
		let counter = 0;

		overflowIntervall = setInterval(
			function () {
				counter++;
				const tabsElement = document.getElementById("tabs-" + id);
				if (!tabsElement?.scrollWidth) stopCheckOverflow();

				if (tabsElement.scrollWidth > tabsElement.clientWidth && document.getElementById("tabs-" + id).children[0].clientWidth < 100) {
					$$invalidate(6, showScrollButton = true);
				} else {
					$$invalidate(6, showScrollButton = false);
					document.getElementById("sir-TabedPane-" + id).scrollLeft = 0;
				}

				// just in case...
				if (counter > 2000 || once) stopCheckOverflow();
			},
			100
		);
	};

	const stopCheckOverflow = () => {
		if (overflowIntervall) clearInterval(overflowIntervall);
	};

	const resizeHandle = document.getElementsByClassName("red-ui-tray-resize-handle ui-draggable-handle")[0];
	resizeHandle.addEventListener("mousedown", checkOverflow);
	resizeHandle.addEventListener("mouseup", stopCheckOverflow);
	let scrollIntervall;

	const doScroll = amount => {
		scrollIntervall = setInterval(
			function () {
				document.getElementById('sir-TabedPane-' + id).scrollLeft += amount;
			},
			100
		);
	};

	const stopScroll = () => {
		if (scrollIntervall) clearInterval(scrollIntervall);
	};

	onMount(() => {
		$$invalidate(0, active = active || shadowTabs[0].id);
		showTabContent(active);
		checkOverflow(null, true);
	});

	const mouseover_handler = () => doScroll(-20);
	const focus_handler = () => doScroll(-20);
	const click_handler = id => showTabContent(id);
	const mouseover_handler_1 = () => doScroll(20);
	const focus_handler_1 = () => doScroll(20);

	$$self.$$set = $$props => {
		if ('active' in $$props) $$invalidate(0, active = $$props.active);
		if ('clazz' in $$props) $$invalidate(2, clazz = $$props.clazz);
		if ('i18n' in $$props) $$invalidate(10, i18n = $$props.i18n);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('node' in $$props) $$invalidate(11, node = $$props.node);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('tabs' in $$props) $$invalidate(12, tabs = $$props.tabs);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*tabs*/ 4096) {
			updateTabs();
		}
	};

	return [
		active,
		id,
		clazz,
		style,
		shadowTabs,
		tabWidth,
		showScrollButton,
		showTabContent,
		doScroll,
		stopScroll,
		i18n,
		node,
		tabs,
		$$scope,
		slots,
		mouseover_handler,
		focus_handler,
		click_handler,
		mouseover_handler_1,
		focus_handler_1
	];
}

class TabbedPane extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				active: 0,
				clazz: 2,
				i18n: 10,
				id: 1,
				node: 11,
				style: 3,
				tabs: 12
			},
			add_css$5
		);
	}
}

/* node_modules/svelte-integration-red/components/TabContent.svelte generated by Svelte v3.44.2 */

function add_css$4(target) {
	append_styles(target, "svelte-12yzo6k", ".sir-Tab.svelte-12yzo6k{display:inline-flex;flex-direction:column;width:100%}");
}

function create_fragment$7(ctx) {
	let div;
	let div_class_value;
	let div_style_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = "" + (/*clazz*/ ctx[0] + " sir-Tab tab-" + /*tab*/ ctx[2] + " svelte-12yzo6k"));
			attr(div, "style", div_style_value = "display:none; " + /*style*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*clazz, tab*/ 5 && div_class_value !== (div_class_value = "" + (/*clazz*/ ctx[0] + " sir-Tab tab-" + /*tab*/ ctx[2] + " svelte-12yzo6k"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 2 && div_style_value !== (div_style_value = "display:none; " + /*style*/ ctx[1])) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', style = '', tab } = $$props;

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(0, clazz = $$props.clazz);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('tab' in $$props) $$invalidate(2, tab = $$props.tab);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [clazz, style, tab, $$scope, slots, click_handler];
}

class TabContent extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { clazz: 0, style: 1, tab: 2 }, add_css$4);
	}
}

/* node_modules/svelte-integration-red/components/PlainTypedInput.svelte generated by Svelte v3.44.2 */

function add_css$3(target) {
	append_styles(target, "svelte-97xgpi", ".maximize.svelte-97xgpi{width:100%}.sir-Row :is(.red-ui-typedInput-container, .red-ui-typedInput-input-wrap){display:inline-flex;align-items:center}.sir-Row button:is(.red-ui-typedInput-type-select, .red-ui-typedInput-option-expand, .red-ui-typedInput-option-trigger){display:inline-flex;align-items:center;line-height:32px}.sir-Input-Container .red-ui-typedInput-type-select:not(.red-ui-typedInput-full-width){padding-right:3px}.sir-Input-Container .red-ui-typedInput-option-label{border-left-color:var(--red-ui-form-input-border-color);border-left-width:1px;border-left-style:double}.sir-Input-Container .red-ui-typedInput-focus .red-ui-typedInput-option-label{border-left-color:var(--red-ui-form-input-border-color-focus)}.sir-Input-Container .input-error .red-ui-typedInput-option-label{border-left-color:var(--red-ui-form-input-border-color-error)}.sir-Input-Container .red-ui-typedInput-option-label:hover{background-color:var(--red-ui-secondary-background-hover)}.sir-Input-Container button.red-ui-typedInput-option-trigger:focus .red-ui-typedInput-option-caret{box-shadow:none}");
}

// (105:0) {:else}
function create_else_block$3(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: Neither property nor type property name given.";
			attr(span, "class", "maximize svelte-97xgpi");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (103:19) 
function create_if_block_5$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-97xgpi");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (101:15) 
function create_if_block_4$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No type property name given.";
			attr(span, "class", "maximize svelte-97xgpi");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (91:0) {#if !updateNode || (prop && typeProp)}
function create_if_block$5(ctx) {
	let t0;
	let input0;
	let input0_id_value;
	let t1;
	let input1;
	let input1_id_value;
	let mounted;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (/*label*/ ctx[3]) return create_if_block_1$5;
		if (/*indented*/ ctx[5]) return create_if_block_3$4;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			input0 = element("input");
			t1 = space();
			input1 = element("input");
			attr(input0, "type", "text");
			attr(input0, "id", input0_id_value = "node-input-" + /*id*/ ctx[4]);
			attr(input0, "style", /*style*/ ctx[8]);
			attr(input1, "type", "hidden");
			attr(input1, "id", input1_id_value = "node-input-" + /*id*/ ctx[4] + "-type");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, input0, anchor);
			set_input_value(input0, /*value*/ ctx[1]);
			insert(target, t1, anchor);
			insert(target, input1, anchor);
			set_input_value(input1, /*type*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input0, "mouseenter", /*mouseenter_handler_1*/ ctx[21]),
					listen(input0, "mouseleave", /*mouseleave_handler_1*/ ctx[22]),
					listen(input0, "click", /*click_handler*/ ctx[23]),
					listen(input0, "keypress", /*keypress_handler*/ ctx[24]),
					listen(input0, "input", /*input0_input_handler*/ ctx[28]),
					listen(input1, "mouseenter", /*mouseenter_handler_2*/ ctx[17]),
					listen(input1, "mouseleave", /*mouseleave_handler_2*/ ctx[18]),
					listen(input1, "click", /*click_handler_1*/ ctx[19]),
					listen(input1, "keypress", /*keypress_handler_1*/ ctx[20]),
					listen(input1, "input", /*input1_input_handler*/ ctx[29])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			}

			if (dirty[0] & /*id*/ 16 && input0_id_value !== (input0_id_value = "node-input-" + /*id*/ ctx[4])) {
				attr(input0, "id", input0_id_value);
			}

			if (dirty[0] & /*style*/ 256) {
				attr(input0, "style", /*style*/ ctx[8]);
			}

			if (dirty[0] & /*value*/ 2 && input0.value !== /*value*/ ctx[1]) {
				set_input_value(input0, /*value*/ ctx[1]);
			}

			if (dirty[0] & /*id*/ 16 && input1_id_value !== (input1_id_value = "node-input-" + /*id*/ ctx[4] + "-type")) {
				attr(input1, "id", input1_id_value);
			}

			if (dirty[0] & /*type*/ 1) {
				set_input_value(input1, /*type*/ ctx[0]);
			}
		},
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(t0);
			if (detaching) detach(input0);
			if (detaching) detach(t1);
			if (detaching) detach(input1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (94:21) 
function create_if_block_3$4(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (92:2) {#if label}
function create_if_block_1$5(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[2] && create_if_block_2$5(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[25]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[26]),
					listen(label_1, "click", /*click_handler_2*/ ctx[27])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$5(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

			if (dirty[0] & /*id*/ 16 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[4])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (93:91) {#if icon}
function create_if_block_2$5(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-97xgpi");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 4 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-97xgpi")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$6(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*updateNode*/ ctx[9] || /*prop*/ ctx[6] && /*typeProp*/ ctx[7]) return create_if_block$5;
		if (/*prop*/ ctx[6]) return create_if_block_4$1;
		if (/*typeProp*/ ctx[7]) return create_if_block_5$1;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { disabled = false, i18n, icon, id, indented = false, label, maximize, node, placeholder, prop, type, typeProp, types, value } = $$props;
	let defaults = node?._def?.defaults || {};
	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';

	if (label !== false) {
		label = label || defaults[prop] && defaults[prop].label || prop;
	}

	if (!types && node[typeProp]) {
		types = defaults[typeProp].types;
	}

	icon = icon || defaults?.[prop]?.icon || '';
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let initialized = false;

	onMount(() => {
		// placeholder must be stated before changing to a TypedInput field
		if (placeholder) window.$('#node-input-' + id).attr("placeholder", placeholder);

		window.$('#node-input-' + id).typedInput({
			types,
			typeField: `#node-input-${id}-type`
		});

		window.$('#node-input-' + id).typedInput('disable', disabled); // no effect if stated in the object above

		window.$('#node-input-' + id).on('change', (_event, type, value) => {
			// if DOM does not exist, an editor was used
			if (window.$('#node-input-' + id).length) {
				value = window.$('#node-input-' + id).typedInput('value');
				type = window.$('#node-input-' + id).typedInput('type');
			}

			if (updateNode) {
				$$invalidate(11, node[prop] = value, node);
				$$invalidate(11, node[typeProp] = type, node);
			}

			dispatch('change', { id, value, type }, { cancelable: false });
		});

		initialized = true;
	});

	// we set style for typed input direct as classes won't work
	let style = 'margin-right: 0px; ';

	if (maximize) style += 'width: 100%;';

	const setFocus = e => {
		// TypedInput has a dummy input field which has no id. Therefor we must reroute the label onclick -> focus.
		window.$(e.target.parentNode.children).find('.red-ui-typedInput-input').focus();
	};

	const update = (key, value) => {
		if (initialized) {
			window.$('#node-input-' + id).typedInput(key, value);
		}
	};

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler_2 = e => setFocus(e);

	function input0_input_handler() {
		value = this.value;
		(($$invalidate(1, value), $$invalidate(11, node)), $$invalidate(6, prop));
	}

	function input1_input_handler() {
		type = this.value;
		(($$invalidate(0, type), $$invalidate(11, node)), $$invalidate(7, typeProp));
	}

	$$self.$$set = $$props => {
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(15, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(11, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(16, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(6, prop = $$props.prop);
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('typeProp' in $$props) $$invalidate(7, typeProp = $$props.typeProp);
		if ('types' in $$props) $$invalidate(12, types = $$props.types);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*node, prop, value*/ 2114) {
			$$invalidate(1, value = updateNode && node[prop] || value);
		}

		if ($$self.$$.dirty[0] & /*node, typeProp, type*/ 2177) {
			$$invalidate(0, type = updateNode && node[typeProp] || type);
		}

		if ($$self.$$.dirty[0] & /*types*/ 4096) {
			update('types', types);
		}

		if ($$self.$$.dirty[0] & /*value*/ 2) {
			if (updateNode) update('value', value);
		}

		if ($$self.$$.dirty[0] & /*type*/ 1) {
			if (updateNode) update('type', type);
		}

		if ($$self.$$.dirty[0] & /*disabled*/ 8192) {
			update('disable', disabled);
		}
	};

	return [
		type,
		value,
		icon,
		label,
		id,
		indented,
		prop,
		typeProp,
		style,
		updateNode,
		setFocus,
		node,
		types,
		disabled,
		i18n,
		maximize,
		placeholder,
		mouseenter_handler_2,
		mouseleave_handler_2,
		click_handler_1,
		keypress_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1,
		click_handler,
		keypress_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler_2,
		input0_input_handler,
		input1_input_handler
	];
}

class PlainTypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				disabled: 13,
				i18n: 14,
				icon: 2,
				id: 4,
				indented: 5,
				label: 3,
				maximize: 15,
				node: 11,
				placeholder: 16,
				prop: 6,
				type: 0,
				typeProp: 7,
				types: 12,
				value: 1
			},
			add_css$3,
			[-1, -1]
		);
	}
}

/* node_modules/svelte-integration-red/components/TypedInput.svelte generated by Svelte v3.44.2 */

function create_default_slot$5(ctx) {
	let plaintypedinput;
	let updating_node;
	let updating_prop;
	let updating_typeProp;
	let updating_value;
	let updating_type;
	let updating_types;
	let updating_label;
	let updating_disabled;
	let current;

	function plaintypedinput_node_binding(value) {
		/*plaintypedinput_node_binding*/ ctx[18](value);
	}

	function plaintypedinput_prop_binding(value) {
		/*plaintypedinput_prop_binding*/ ctx[19](value);
	}

	function plaintypedinput_typeProp_binding(value) {
		/*plaintypedinput_typeProp_binding*/ ctx[20](value);
	}

	function plaintypedinput_value_binding(value) {
		/*plaintypedinput_value_binding*/ ctx[21](value);
	}

	function plaintypedinput_type_binding(value) {
		/*plaintypedinput_type_binding*/ ctx[22](value);
	}

	function plaintypedinput_types_binding(value) {
		/*plaintypedinput_types_binding*/ ctx[23](value);
	}

	function plaintypedinput_label_binding(value) {
		/*plaintypedinput_label_binding*/ ctx[24](value);
	}

	function plaintypedinput_disabled_binding(value) {
		/*plaintypedinput_disabled_binding*/ ctx[25](value);
	}

	let plaintypedinput_props = {
		placeholder: /*placeholder*/ ctx[16],
		icon: /*icon*/ ctx[15],
		maximize: /*maximize*/ ctx[5],
		id: /*id*/ ctx[1],
		i18n: /*i18n*/ ctx[14],
		indented: /*indented*/ ctx[2]
	};

	if (/*node*/ ctx[6] !== void 0) {
		plaintypedinput_props.node = /*node*/ ctx[6];
	}

	if (/*prop*/ ctx[7] !== void 0) {
		plaintypedinput_props.prop = /*prop*/ ctx[7];
	}

	if (/*typeProp*/ ctx[9] !== void 0) {
		plaintypedinput_props.typeProp = /*typeProp*/ ctx[9];
	}

	if (/*value*/ ctx[11] !== void 0) {
		plaintypedinput_props.value = /*value*/ ctx[11];
	}

	if (/*type*/ ctx[8] !== void 0) {
		plaintypedinput_props.type = /*type*/ ctx[8];
	}

	if (/*types*/ ctx[10] !== void 0) {
		plaintypedinput_props.types = /*types*/ ctx[10];
	}

	if (/*label*/ ctx[4] !== void 0) {
		plaintypedinput_props.label = /*label*/ ctx[4];
	}

	if (/*disabled*/ ctx[0] !== void 0) {
		plaintypedinput_props.disabled = /*disabled*/ ctx[0];
	}

	plaintypedinput = new PlainTypedInput({ props: plaintypedinput_props });
	binding_callbacks.push(() => bind(plaintypedinput, 'node', plaintypedinput_node_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'prop', plaintypedinput_prop_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'typeProp', plaintypedinput_typeProp_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'value', plaintypedinput_value_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'type', plaintypedinput_type_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'types', plaintypedinput_types_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'label', plaintypedinput_label_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'disabled', plaintypedinput_disabled_binding));
	plaintypedinput.$on("click", /*click_handler*/ ctx[26]);
	plaintypedinput.$on("change", /*change_handler*/ ctx[27]);
	plaintypedinput.$on("mouseenter", /*mouseenter_handler*/ ctx[28]);
	plaintypedinput.$on("mouseleave", /*mouseleave_handler*/ ctx[29]);

	return {
		c() {
			create_component(plaintypedinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaintypedinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaintypedinput_changes = {};
			if (dirty & /*placeholder*/ 65536) plaintypedinput_changes.placeholder = /*placeholder*/ ctx[16];
			if (dirty & /*icon*/ 32768) plaintypedinput_changes.icon = /*icon*/ ctx[15];
			if (dirty & /*maximize*/ 32) plaintypedinput_changes.maximize = /*maximize*/ ctx[5];
			if (dirty & /*id*/ 2) plaintypedinput_changes.id = /*id*/ ctx[1];
			if (dirty & /*i18n*/ 16384) plaintypedinput_changes.i18n = /*i18n*/ ctx[14];
			if (dirty & /*indented*/ 4) plaintypedinput_changes.indented = /*indented*/ ctx[2];

			if (!updating_node && dirty & /*node*/ 64) {
				updating_node = true;
				plaintypedinput_changes.node = /*node*/ ctx[6];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty & /*prop*/ 128) {
				updating_prop = true;
				plaintypedinput_changes.prop = /*prop*/ ctx[7];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_typeProp && dirty & /*typeProp*/ 512) {
				updating_typeProp = true;
				plaintypedinput_changes.typeProp = /*typeProp*/ ctx[9];
				add_flush_callback(() => updating_typeProp = false);
			}

			if (!updating_value && dirty & /*value*/ 2048) {
				updating_value = true;
				plaintypedinput_changes.value = /*value*/ ctx[11];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty & /*type*/ 256) {
				updating_type = true;
				plaintypedinput_changes.type = /*type*/ ctx[8];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_types && dirty & /*types*/ 1024) {
				updating_types = true;
				plaintypedinput_changes.types = /*types*/ ctx[10];
				add_flush_callback(() => updating_types = false);
			}

			if (!updating_label && dirty & /*label*/ 16) {
				updating_label = true;
				plaintypedinput_changes.label = /*label*/ ctx[4];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty & /*disabled*/ 1) {
				updating_disabled = true;
				plaintypedinput_changes.disabled = /*disabled*/ ctx[0];
				add_flush_callback(() => updating_disabled = false);
			}

			plaintypedinput.$set(plaintypedinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaintypedinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaintypedinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaintypedinput, detaching);
		}
	};
}

function create_fragment$5(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				id: "sir-TypedInput-Container-" + /*id*/ ctx[1],
				clazz: "" + (/*clazz*/ ctx[12] + " sir-Input-Container"),
				inline: /*inline*/ ctx[3],
				fading: /*fading*/ ctx[13],
				style: /*style*/ ctx[17],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*id*/ 2) row_changes.id = "sir-TypedInput-Container-" + /*id*/ ctx[1];
			if (dirty & /*clazz*/ 4096) row_changes.clazz = "" + (/*clazz*/ ctx[12] + " sir-Input-Container");
			if (dirty & /*inline*/ 8) row_changes.inline = /*inline*/ ctx[3];
			if (dirty & /*fading*/ 8192) row_changes.fading = /*fading*/ ctx[13];
			if (dirty & /*style*/ 131072) row_changes.style = /*style*/ ctx[17];

			if (dirty & /*$$scope, placeholder, icon, maximize, id, i18n, indented, node, prop, typeProp, value, type, types, label, disabled*/ 1073860599) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { clazz = '', disabled = false, fading = true, i18n, icon, id, indented = false, inline = false, label, maximize = true, node, placeholder, prop, style = '', type, typeProp, types, value } = $$props;
	id = id || getId(prop);
	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);
	maximize = getBooleanFrom(maximize);

	function plaintypedinput_node_binding(value) {
		node = value;
		$$invalidate(6, node);
	}

	function plaintypedinput_prop_binding(value) {
		prop = value;
		$$invalidate(7, prop);
	}

	function plaintypedinput_typeProp_binding(value) {
		typeProp = value;
		$$invalidate(9, typeProp);
	}

	function plaintypedinput_value_binding(value$1) {
		value = value$1;
		$$invalidate(11, value);
	}

	function plaintypedinput_type_binding(value) {
		type = value;
		$$invalidate(8, type);
	}

	function plaintypedinput_types_binding(value) {
		types = value;
		$$invalidate(10, types);
	}

	function plaintypedinput_label_binding(value) {
		label = value;
		$$invalidate(4, label);
	}

	function plaintypedinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(0, disabled);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(12, clazz = $$props.clazz);
		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(13, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('icon' in $$props) $$invalidate(15, icon = $$props.icon);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('indented' in $$props) $$invalidate(2, indented = $$props.indented);
		if ('inline' in $$props) $$invalidate(3, inline = $$props.inline);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('node' in $$props) $$invalidate(6, node = $$props.node);
		if ('placeholder' in $$props) $$invalidate(16, placeholder = $$props.placeholder);
		if ('prop' in $$props) $$invalidate(7, prop = $$props.prop);
		if ('style' in $$props) $$invalidate(17, style = $$props.style);
		if ('type' in $$props) $$invalidate(8, type = $$props.type);
		if ('typeProp' in $$props) $$invalidate(9, typeProp = $$props.typeProp);
		if ('types' in $$props) $$invalidate(10, types = $$props.types);
		if ('value' in $$props) $$invalidate(11, value = $$props.value);
	};

	return [
		disabled,
		id,
		indented,
		inline,
		label,
		maximize,
		node,
		prop,
		type,
		typeProp,
		types,
		value,
		clazz,
		fading,
		i18n,
		icon,
		placeholder,
		style,
		plaintypedinput_node_binding,
		plaintypedinput_prop_binding,
		plaintypedinput_typeProp_binding,
		plaintypedinput_value_binding,
		plaintypedinput_type_binding,
		plaintypedinput_types_binding,
		plaintypedinput_label_binding,
		plaintypedinput_disabled_binding,
		click_handler,
		change_handler,
		mouseenter_handler,
		mouseleave_handler
	];
}

class TypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			clazz: 12,
			disabled: 0,
			fading: 13,
			i18n: 14,
			icon: 15,
			id: 1,
			indented: 2,
			inline: 3,
			label: 4,
			maximize: 5,
			node: 6,
			placeholder: 16,
			prop: 7,
			style: 17,
			type: 8,
			typeProp: 9,
			types: 10,
			value: 11
		});
	}
}

const getOpenApiSpec = async (openApiUrl, devMode = false) => {
  let url = 'getOpenApiSpec?openApiUrl=' + encodeURI(openApiUrl);
  if (devMode) {
    url += '&devMode=true';
  }
  // server call
  return window.$.get(url, function (response) {
    return response
  }).fail(function (message) {
    return message
  })
};

const setError = (message, inputFieldId = null, data) => {
  data.contentTypes.request = [];
  data.contentTypes.response = [];
  if (typeof message !== 'string') {
    message = JSON.stringify(message);
  }
  data.error = message;
  if (inputFieldId) {
    document.getElementById(inputFieldId).classList.add('input-error');
  }
};

const createApi = async (node, data) => {
  try {
    data.error = '';
    data.openApiSpec = await getOpenApiSpec(node.openApiUrl, node.devMode);
    // if a string was returned it is a node error
    if (typeof data.openApiSpec === 'string') {
      setError(data.openApiSpec, 'node-input-openApiUrl', data);
    } else if (!Object.keys(data.openApiSpec.apiList).length) {
      setError('No api list found', 'node-input-openApiUrl', data);
    } else {
      // trigger svelte to show latest data
      data.openApiSpec.apiList = data.openApiSpec.apiList || {};
      data.openApiSpec.servers = data.openApiSpec.servers || [];

      if (data.openApiSpec.servers.length <= 1) node.server = '';
      // save old parameter objects (openApi-red version <0.2) - changed from object to array objects
      if (!Array.isArray(node.parameters) && node.api && node.operation) {
        Object.assign(data.oldParameters, node.parameters);
        node.parameters = [];
        data.prevOperation = '';
        node.operationData = data.openApiSpec.apiList?.[node.api]?.[node.operation];
      }
      node.internalErrors.readUrl = false;
    }
  } catch (e) {
    node.internalErrors.readUrl = true;
    setError(e, 'node-input-openApiUrl', data);
  }
  data.init = false;
};

const getCorrectType = (param) => {
  const type = param?.schema?.type || param.type;
  if (type === 'boolean') return 'bool'
  if (type === 'integer') return 'num'
  if (param.name === 'Json Request Body' || param.name === 'body' || type === 'body' || type === 'object') return 'json'
  if (param?.items?.enum?.length > 0 || param?.schema?.enum?.length) return 'select'
  return 'str'
};

const getAllowedTypes = (input) => {
  let type;
  if (typeof input === 'string') type = input;
  else type = getCorrectType(input);
  if (type === 'bool') return ['bool', 'msg', 'flow', 'global']
  if (type === 'num') return ['num', 'jsonata', 'msg', 'flow', 'global']
  if (type === 'json') return ['json', 'jsonata', 'msg', 'flow', 'global']
  if (type === 'select') {
    const options = input?.items?.enum || input?.schema?.enum;
    return [{ value: 'select', label: 'Select', options: options }, 'str', 'msg', 'flow', 'global']
  }
  return ['str', 'json', 'jsonata', 'msg', 'flow', 'global']
};

const sortKeys = (schema) => {
  let keys = null;
  if (schema?.properties) {
    // ordering keys helps later with svelte #each (first required then normal and sorted alphabetical)
    keys = Object.keys(schema.properties).sort();
    if (schema.required) {
      const notRequiredKeys = keys.filter(prop => !schema.required.includes(prop));
      keys = schema.required.sort().concat(notRequiredKeys.sort());
    }
  }
  return keys
};

const orderRequired = (a, b) => {
  let comparison = 0;
  if (b.required) {
    comparison = 1;
  } else if (a.required) {
    comparison = -1;
  }
  return comparison
};

const createParameters = (node, oldParameters) => {
  // new in openApi: body request
  // check if requestBody is in parameters or separate
  if (!node.operationData.parameters?.requestBody && node.operationData?.requestBody?.content) {
    const requestBody = node.operationData.requestBody;
    const content = requestBody.content;
    const keys = sortKeys(content[node.requestContentType].schema);
    if (content[node.requestContentType]) {
      const newParameter = {
        id: 'requestBody',
        name: 'Request body',
        in: '',
        schema: content[node.requestContentType].schema || null,
        value: oldParameters?.[' Request body']?.value || '{}',
        required: !!requestBody?.required || false,
        isActive: !!requestBody?.required || oldParameters?.[' Request body']?.isActive || false,
        description: requestBody?.description || '-',
        type: oldParameters?.[' Request body']?.inputType || 'json',
        allowedTypes: getAllowedTypes('json'),
        keys
      };
      node.parameters.push(newParameter);
    }
  }
  // add standard parameters
  const parameters = node.operationData?.parameters?.sort(orderRequired) || [];
  parameters.forEach(param => {
    const keys = sortKeys(param.schema);
    node.parameters.push(
      {
        id: param.name + param.in,
        name: param.name,
        in: param.in,
        required: param.required,
        value: oldParameters?.[param.name + ' ' + param.in]?.value || '',
        isActive: !!param.required || oldParameters?.[param.name + ' ' + param.in]?.isActive || false,
        type: oldParameters?.[param.name + ' ' + param.in]?.inputType || getCorrectType(param), // selected type
        allowedTypes: getAllowedTypes(param),
        description: param.description || '-',
        schema: param.schema || null,
        keys
      }
    );
  });
};

const createOperationDescription = (apiList, node) => {
  let operationDescription = '';
  if (apiList?.[node.api]?.[node.operation]?.description) {
    operationDescription = apiList[node.api][node.operation].description;
    // sanitize html
    const denyList = ['script', 'object', 'embed', 'link'];
    denyList.forEach(d => {
      const searchParam = new RegExp('<\/?' + d + '>', 'gm'); // eslint-disable-line
      operationDescription = operationDescription.replace(searchParam, '"<"' + d + '">"');
    });
  }
  return operationDescription
};

const getRequestContentTypes = (operationSchema) => {
  // needed input since an update from swagger.js
  let requestContentTypes = ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'];
  if (operationSchema?.requestBody?.content) {
    requestContentTypes = Object.keys(operationSchema.requestBody.content || {});
  }
  return requestContentTypes
};

const getResponseContentTypes = (operationSchema) => {
  let responseContentTypes = [];
  if (operationSchema?.responses) {
    Object.values(operationSchema.responses).forEach(response => {
      if (response?.content) {
        Object.keys(response.content)?.forEach(cT => responseContentTypes.push(cT));
      }
    });
  }
  if (responseContentTypes.length) {
    // distinct array
    responseContentTypes = Array.from(new Set(responseContentTypes));
  }
  return responseContentTypes
};

var htmlFunctions = {
  getOpenApiSpec,
  getCorrectType,
  getAllowedTypes,
  sortKeys,
  createParameters,
  createOperationDescription,
  getRequestContentTypes,
  getResponseContentTypes,
  createApi
};

/* src/components/GeneralOptions.svelte generated by Svelte v3.44.2 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

// (19:4) <Row>
function create_default_slot_6$1(ctx) {
	let input;
	let updating_node;
	let t;
	let button;
	let current;

	function input_node_binding_1(value) {
		/*input_node_binding_1*/ ctx[5](value);
	}

	let input_props = { prop: "openApiUrl", inline: true };

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_1));
	input.$on("change", /*change_handler*/ ctx[6]);

	button = new Button({
			props: {
				icon: /*node*/ ctx[0].internalErrors.readUrl
				? "edit"
				: "check-square",
				clazz: /*node*/ ctx[0].internalErrors.readUrl ? "" : "success",
				label: /*node*/ ctx[0].internalErrors.readUrl ? "read" : "ok",
				inline: true,
				disabled: !/*node*/ ctx[0].internalErrors.readUrl
			}
		});

	button.$on("click", /*getApiFromUrl*/ ctx[3]);

	return {
		c() {
			create_component(input.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const button_changes = {};

			if (dirty & /*node*/ 1) button_changes.icon = /*node*/ ctx[0].internalErrors.readUrl
			? "edit"
			: "check-square";

			if (dirty & /*node*/ 1) button_changes.clazz = /*node*/ ctx[0].internalErrors.readUrl ? "" : "success";
			if (dirty & /*node*/ 1) button_changes.label = /*node*/ ctx[0].internalErrors.readUrl ? "read" : "ok";
			if (dirty & /*node*/ 1) button_changes.disabled = !/*node*/ ctx[0].internalErrors.readUrl;
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t);
			destroy_component(button, detaching);
		}
	};
}

// (23:4) {#if data.openApiSpec.servers?.length > 1}
function create_if_block$4(ctx) {
	let div;
	let t;
	let row;
	let current;
	let if_block = /*node*/ ctx[0].alternServer && create_if_block_2$4(ctx);

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			create_component(row.$$.fragment);
			set_style(div, "margin-left", "113px");
			set_style(div, "margin-bottom", "12px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			insert(target, t, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*node*/ ctx[0].alternServer) {
				if (if_block) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const row_changes = {};

			if (dirty & /*$$scope, node, data*/ 65539) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (detaching) detach(t);
			destroy_component(row, detaching);
		}
	};
}

// (25:8) {#if node.alternServer}
function create_if_block_2$4(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "warning",
				closeable: true,
				$$slots: {
					header: [create_header_slot$2],
					default: [create_default_slot_5$2]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (26:8) <Callout type="warning" closeable>
function create_default_slot_5$2(ctx) {
	let t;

	return {
		c() {
			t = text("Setting an alternative server was not tested in a practical environment, but should work. If not, please make a bug report!");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (27:10) 
function create_header_slot$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Alternative Server is an experimental Feature!";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (35:12) {#if s.description}
function create_if_block_1$4(ctx) {
	let option;
	let t_value = /*s*/ ctx[13].description + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.disabled = true;
			option.__value = option_value_value = /*s*/ ctx[13].description;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && t_value !== (t_value = /*s*/ ctx[13].description + "")) set_data(t, t_value);

			if (dirty & /*data*/ 2 && option_value_value !== (option_value_value = /*s*/ ctx[13].description)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (34:10) {#each data.openApiSpec.servers as s}
function create_each_block_1$2(ctx) {
	let t0;
	let option0;
	let t1_value = /*s*/ ctx[13].url + "";
	let t1;
	let option0_value_value;
	let t2;
	let option1;
	let if_block = /*s*/ ctx[13].description && create_if_block_1$4(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			option0 = element("option");
			t1 = text(t1_value);
			t2 = space();
			option1 = element("option");
			option1.textContent = "-------------------------";
			option0.__value = option0_value_value = /*s*/ ctx[13].url;
			option0.value = option0.__value;
			option1.disabled = true;
			option1.__value = "-------------------------";
			option1.value = option1.__value;
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, option0, anchor);
			append(option0, t1);
			insert(target, t2, anchor);
			insert(target, option1, anchor);
		},
		p(ctx, dirty) {
			if (/*s*/ ctx[13].description) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*data*/ 2 && t1_value !== (t1_value = /*s*/ ctx[13].url + "")) set_data(t1, t1_value);

			if (dirty & /*data*/ 2 && option0_value_value !== (option0_value_value = /*s*/ ctx[13].url)) {
				option0.__value = option0_value_value;
				option0.value = option0.__value;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(option0);
			if (detaching) detach(t2);
			if (detaching) detach(option1);
		}
	};
}

// (33:8) <Select inline bind:node prop="server"  disabled={!node.alternServer}>
function create_default_slot_4$3(ctx) {
	let each_1_anchor;
	let each_value_1 = /*data*/ ctx[1].openApiSpec.servers;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2) {
				each_value_1 = /*data*/ ctx[1].openApiSpec.servers;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (32:6) <Row>
function create_default_slot_3$3(ctx) {
	let select;
	let updating_node;
	let t;
	let input;
	let updating_node_1;
	let current;

	function select_node_binding(value) {
		/*select_node_binding*/ ctx[7](value);
	}

	let select_props = {
		inline: true,
		prop: "server",
		disabled: !/*node*/ ctx[0].alternServer,
		$$slots: { default: [create_default_slot_4$3] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding));

	function input_node_binding_2(value) {
		/*input_node_binding_2*/ ctx[8](value);
	}

	let input_props = { prop: "alternServer", inline: true };

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding_2));

	return {
		c() {
			create_component(select.$$.fragment);
			t = space();
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			insert(target, t, anchor);
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty & /*node*/ 1) select_changes.disabled = !/*node*/ ctx[0].alternServer;

			if (dirty & /*$$scope, data*/ 65538) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			select.$set(select_changes);
			const input_changes = {};

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
			if (detaching) detach(t);
			destroy_component(input, detaching);
		}
	};
}

// (47:6) {#each errorHandlingOptions as eOption}
function create_each_block$2(ctx) {
	let option;
	let t_value = /*eOption*/ ctx[10] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*eOption*/ ctx[10];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (46:4) <Select bind:node prop="errorHandling" icon="warning" >
function create_default_slot_2$3(ctx) {
	let each_1_anchor;
	let each_value = /*errorHandlingOptions*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*errorHandlingOptions*/ 4) {
				each_value = /*errorHandlingOptions*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (17:2) <Group clazz="paddingBottom">
function create_default_slot_1$3(ctx) {
	let input;
	let updating_node;
	let t0;
	let row;
	let t1;
	let t2;
	let select;
	let updating_node_1;
	let current;

	function input_node_binding(value) {
		/*input_node_binding*/ ctx[4](value);
	}

	let input_props = { prop: "name" };

	if (/*node*/ ctx[0] !== void 0) {
		input_props.node = /*node*/ ctx[0];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'node', input_node_binding));

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			}
		});

	let if_block = /*data*/ ctx[1].openApiSpec.servers?.length > 1 && create_if_block$4(ctx);

	function select_node_binding_1(value) {
		/*select_node_binding_1*/ ctx[9](value);
	}

	let select_props = {
		prop: "errorHandling",
		icon: "warning",
		$$slots: { default: [create_default_slot_2$3] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding_1));

	return {
		c() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(row.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t0, anchor);
			mount_component(row, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t2, anchor);
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				input_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input.$set(input_changes);
			const row_changes = {};

			if (dirty & /*$$scope, node*/ 65537) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (/*data*/ ctx[1].openApiSpec.servers?.length > 1) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t2.parentNode, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const select_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(if_block);
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(if_block);
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t0);
			destroy_component(row, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t2);
			destroy_component(select, detaching);
		}
	};
}

// (16:0) <Collapsible label="General" indented={false}>
function create_default_slot$4(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};

			if (dirty & /*$$scope, node, data*/ 65539) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

function create_fragment$4(ctx) {
	let collapsible;
	let current;

	collapsible = new Collapsible({
			props: {
				label: "General",
				indented: false,
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(collapsible.$$.fragment);
		},
		m(target, anchor) {
			mount_component(collapsible, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const collapsible_changes = {};

			if (dirty & /*$$scope, node, data*/ 65539) {
				collapsible_changes.$$scope = { dirty, ctx };
			}

			collapsible.$set(collapsible_changes);
		},
		i(local) {
			if (current) return;
			transition_in(collapsible.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(collapsible.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(collapsible, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { node, data } = $$props;
	const errorHandlingOptions = ['Standard', 'other output', 'throw exception'];

	const getApiFromUrl = () => {
		htmlFunctions.createApi(node, data).then(() => {
			$$invalidate(0, node);
			$$invalidate(1, data);
		});
	};

	function input_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	const change_handler = () => $$invalidate(0, node.internalErrors.readUrl = true, node);

	function select_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function input_node_binding_2(value) {
		node = value;
		$$invalidate(0, node);
	}

	function select_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	return [
		node,
		data,
		errorHandlingOptions,
		getApiFromUrl,
		input_node_binding,
		input_node_binding_1,
		change_handler,
		select_node_binding,
		input_node_binding_2,
		select_node_binding_1
	];
}

class GeneralOptions extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { node: 0, data: 1 });
	}
}

/* src/components/ApiOptions.svelte generated by Svelte v3.44.2 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

// (13:10) {:else}
function create_else_block$2(ctx) {
	let option;
	let t_value = /*api*/ ctx[18] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*api*/ ctx[18];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && t_value !== (t_value = /*api*/ ctx[18] + "")) set_data(t, t_value);

			if (dirty & /*data*/ 2 && option_value_value !== (option_value_value = /*api*/ ctx[18])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (11:10) {#if node.api === api}
function create_if_block_3$3(ctx) {
	let option;
	let t_value = /*api*/ ctx[18] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*api*/ ctx[18];
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && t_value !== (t_value = /*api*/ ctx[18] + "")) set_data(t, t_value);

			if (dirty & /*data*/ 2 && option_value_value !== (option_value_value = /*api*/ ctx[18])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (10:8) { #each Object.keys(data.openApiSpec.apiList || {}) as api}
function create_each_block_3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0].api === /*api*/ ctx[18]) return create_if_block_3$3;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (8:4) <Select bind:node prop="api" icon="tag" on:change={() => node.operation = ""}>
function create_default_slot_7(ctx) {
	let option;
	let t;
	let each_1_anchor;
	let each_value_3 = Object.keys(/*data*/ ctx[1].openApiSpec.apiList || {});
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	return {
		c() {
			option = element("option");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = "";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, data, node*/ 3) {
				each_value_3 = Object.keys(/*data*/ ctx[1].openApiSpec.apiList || {});
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (21:8) {#each Object.values(data.openApiSpec?.apiList?.[node.api] || {}) as operation}
function create_each_block_2$1(ctx) {
	let option;
	let t_value = /*operation*/ ctx[15].summary + "";
	let t;
	let option_value_value;
	let option_selected_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*operation*/ ctx[15].operationId;
			option.value = option.__value;
			option.selected = option_selected_value = /*node*/ ctx[0].operation === /*operation*/ ctx[15].operationId;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*data, node*/ 3 && t_value !== (t_value = /*operation*/ ctx[15].summary + "")) set_data(t, t_value);

			if (dirty & /*data, node*/ 3 && option_value_value !== (option_value_value = /*operation*/ ctx[15].operationId)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}

			if (dirty & /*node, data*/ 3 && option_selected_value !== (option_selected_value = /*node*/ ctx[0].operation === /*operation*/ ctx[15].operationId)) {
				option.selected = option_selected_value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (19:6) <Select inline bind:node prop="operation" icon="wrench">
function create_default_slot_6(ctx) {
	let option;
	let t;
	let each_1_anchor;
	let each_value_2 = Object.values(/*data*/ ctx[1].openApiSpec?.apiList?.[/*node*/ ctx[0].api] || {});
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	}

	return {
		c() {
			option = element("option");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = "";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, data, node*/ 3) {
				each_value_2 = Object.values(/*data*/ ctx[1].openApiSpec?.apiList?.[/*node*/ ctx[0].api] || {});
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (25:6) {#if data.operationDescription && !node.showDescription}
function create_if_block_2$3(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				inline: true,
				label: "show description",
				icon: "eye"
			}
		});

	button.$on("click", /*click_handler*/ ctx[5]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (18:4) <Row>
function create_default_slot_5$1(ctx) {
	let select;
	let updating_node;
	let t;
	let if_block_anchor;
	let current;

	function select_node_binding(value) {
		/*select_node_binding*/ ctx[4](value);
	}

	let select_props = {
		inline: true,
		prop: "operation",
		icon: "wrench",
		$$slots: { default: [create_default_slot_6] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding));
	let if_block = /*data*/ ctx[1].operationDescription && !/*node*/ ctx[0].showDescription && create_if_block_2$3(ctx);

	return {
		c() {
			create_component(select.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};

			if (dirty & /*$$scope, data, node*/ 2097155) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			select.$set(select_changes);

			if (/*data*/ ctx[1].operationDescription && !/*node*/ ctx[0].showDescription) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*data, node*/ 3) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (30:4) {#if data.operationDescription}
function create_if_block_1$3(ctx) {
	let callout;
	let updating_show;
	let current;

	function callout_show_binding(value) {
		/*callout_show_binding*/ ctx[6](value);
	}

	let callout_props = {
		type: "info",
		closeable: true,
		fading: !/*data*/ ctx[1].init,
		$$slots: { default: [create_default_slot_4$2] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0].showDescription !== void 0) {
		callout_props.show = /*node*/ ctx[0].showDescription;
	}

	callout = new Callout({ props: callout_props });
	binding_callbacks.push(() => bind(callout, 'show', callout_show_binding));

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};
			if (dirty & /*data*/ 2) callout_changes.fading = !/*data*/ ctx[1].init;

			if (dirty & /*$$scope, data*/ 2097154) {
				callout_changes.$$scope = { dirty, ctx };
			}

			if (!updating_show && dirty & /*node*/ 1) {
				updating_show = true;
				callout_changes.show = /*node*/ ctx[0].showDescription;
				add_flush_callback(() => updating_show = false);
			}

			callout.$set(callout_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (32:6) <Callout type="info" closeable bind:show={node.showDescription} fading={!data.init}>
function create_default_slot_4$2(ctx) {
	let html_tag;
	let raw_value = /*data*/ ctx[1].operationDescription + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag();
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && raw_value !== (raw_value = /*data*/ ctx[1].operationDescription + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (40:6) {#each data.contentTypes.request as reqCT}
function create_each_block_1$1(ctx) {
	let option;
	let t_value = /*reqCT*/ ctx[12] + "";
	let t;
	let option_value_value;
	let option_selected_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*reqCT*/ ctx[12];
			option.value = option.__value;
			option.selected = option_selected_value = /*node*/ ctx[0].requestContentType === /*reqCT*/ ctx[12];
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && t_value !== (t_value = /*reqCT*/ ctx[12] + "")) set_data(t, t_value);

			if (dirty & /*data*/ 2 && option_value_value !== (option_value_value = /*reqCT*/ ctx[12])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}

			if (dirty & /*node, data*/ 3 && option_selected_value !== (option_selected_value = /*node*/ ctx[0].requestContentType === /*reqCT*/ ctx[12])) {
				option.selected = option_selected_value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (39:4) <Select clazz="noLongLabel" bind:node prop="requestContentType">
function create_default_slot_3$2(ctx) {
	let each_1_anchor;
	let each_value_1 = /*data*/ ctx[1].contentTypes.request;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*data, node*/ 3) {
				each_value_1 = /*data*/ ctx[1].contentTypes.request;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (44:4) {#if data.contentTypes.response.length }
function create_if_block$3(ctx) {
	let select;
	let updating_node;
	let current;

	function select_node_binding_1(value) {
		/*select_node_binding_1*/ ctx[8](value);
	}

	let select_props = {
		clazz: "noLongLabel",
		prop: "responseContentType",
		fading: !/*data*/ ctx[1].init,
		$$slots: { default: [create_default_slot_2$2] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select_props.node = /*node*/ ctx[0];
	}

	select = new Select({ props: select_props });
	binding_callbacks.push(() => bind(select, 'node', select_node_binding_1));

	return {
		c() {
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty & /*data*/ 2) select_changes.fading = !/*data*/ ctx[1].init;

			if (dirty & /*$$scope, data, node*/ 2097155) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				select_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

// (46:8) {#each data.contentTypes.response as resCT}
function create_each_block$1(ctx) {
	let option;
	let t_value = /*resCT*/ ctx[9] + "";
	let t;
	let option_value_value;
	let option_selected_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*resCT*/ ctx[9];
			option.value = option.__value;
			option.selected = option_selected_value = /*node*/ ctx[0].responseContentType === /*resCT*/ ctx[9];
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && t_value !== (t_value = /*resCT*/ ctx[9] + "")) set_data(t, t_value);

			if (dirty & /*data*/ 2 && option_value_value !== (option_value_value = /*resCT*/ ctx[9])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}

			if (dirty & /*node, data*/ 3 && option_selected_value !== (option_selected_value = /*node*/ ctx[0].responseContentType === /*resCT*/ ctx[9])) {
				option.selected = option_selected_value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (45:6) <Select clazz="noLongLabel" bind:node prop="responseContentType" fading={!data.init} >
function create_default_slot_2$2(ctx) {
	let each_1_anchor;
	let each_value = /*data*/ ctx[1].contentTypes.response;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*data, node*/ 3) {
				each_value = /*data*/ ctx[1].contentTypes.response;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (7:2) <Group clazz="paddingBottom">
function create_default_slot_1$2(ctx) {
	let select0;
	let updating_node;
	let t0;
	let row;
	let t1;
	let t2;
	let select1;
	let updating_node_1;
	let t3;
	let if_block1_anchor;
	let current;

	function select0_node_binding(value) {
		/*select0_node_binding*/ ctx[2](value);
	}

	let select0_props = {
		prop: "api",
		icon: "tag",
		$$slots: { default: [create_default_slot_7] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select0_props.node = /*node*/ ctx[0];
	}

	select0 = new Select({ props: select0_props });
	binding_callbacks.push(() => bind(select0, 'node', select0_node_binding));
	select0.$on("change", /*change_handler*/ ctx[3]);

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			}
		});

	let if_block0 = /*data*/ ctx[1].operationDescription && create_if_block_1$3(ctx);

	function select1_node_binding(value) {
		/*select1_node_binding*/ ctx[7](value);
	}

	let select1_props = {
		clazz: "noLongLabel",
		prop: "requestContentType",
		$$slots: { default: [create_default_slot_3$2] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select1_props.node = /*node*/ ctx[0];
	}

	select1 = new Select({ props: select1_props });
	binding_callbacks.push(() => bind(select1, 'node', select1_node_binding));
	let if_block1 = /*data*/ ctx[1].contentTypes.response.length && create_if_block$3(ctx);

	return {
		c() {
			create_component(select0.$$.fragment);
			t0 = space();
			create_component(row.$$.fragment);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			create_component(select1.$$.fragment);
			t3 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			mount_component(select0, target, anchor);
			insert(target, t0, anchor);
			mount_component(row, target, anchor);
			insert(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t2, anchor);
			mount_component(select1, target, anchor);
			insert(target, t3, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select0_changes = {};

			if (dirty & /*$$scope, data, node*/ 2097155) {
				select0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				select0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			select0.$set(select0_changes);
			const row_changes = {};

			if (dirty & /*$$scope, node, data*/ 2097155) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (/*data*/ ctx[1].operationDescription) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const select1_changes = {};

			if (dirty & /*$$scope, data, node*/ 2097155) {
				select1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				select1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			select1.$set(select1_changes);

			if (/*data*/ ctx[1].contentTypes.response.length) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(select0.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(if_block0);
			transition_in(select1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(select0.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(if_block0);
			transition_out(select1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			destroy_component(select0, detaching);
			if (detaching) detach(t0);
			destroy_component(row, detaching);
			if (detaching) detach(t1);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t2);
			destroy_component(select1, detaching);
			if (detaching) detach(t3);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (6:0) <Collapsible label="Api options" indented={false}>
function create_default_slot$3(ctx) {
	let group;
	let current;

	group = new Group({
			props: {
				clazz: "paddingBottom",
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(group.$$.fragment);
		},
		m(target, anchor) {
			mount_component(group, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const group_changes = {};

			if (dirty & /*$$scope, data, node*/ 2097155) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
		},
		i(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(group, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let collapsible;
	let current;

	collapsible = new Collapsible({
			props: {
				label: "Api options",
				indented: false,
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(collapsible.$$.fragment);
		},
		m(target, anchor) {
			mount_component(collapsible, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const collapsible_changes = {};

			if (dirty & /*$$scope, data, node*/ 2097155) {
				collapsible_changes.$$scope = { dirty, ctx };
			}

			collapsible.$set(collapsible_changes);
		},
		i(local) {
			if (current) return;
			transition_in(collapsible.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(collapsible.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(collapsible, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { node, data } = $$props;

	function select0_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	const change_handler = () => $$invalidate(0, node.operation = "", node);

	function select_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	const click_handler = () => $$invalidate(0, node.showDescription = !node.showDescription, node);

	function callout_show_binding(value) {
		if ($$self.$$.not_equal(node.showDescription, value)) {
			node.showDescription = value;
			$$invalidate(0, node);
		}
	}

	function select1_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function select_node_binding_1(value) {
		node = value;
		$$invalidate(0, node);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('data' in $$props) $$invalidate(1, data = $$props.data);
	};

	return [
		node,
		data,
		select0_node_binding,
		change_handler,
		select_node_binding,
		click_handler,
		callout_show_binding,
		select1_node_binding,
		select_node_binding_1
	];
}

class ApiOptions extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { node: 0, data: 1 });
	}
}

/* src/components/JsonParamHelper.svelte generated by Svelte v3.44.2 */

function add_css$2(target) {
	append_styles(target, "svelte-qzpchp", ".jsonObjectKeyList.svelte-qzpchp{margin-bottom:0px}.jsonKeys.svelte-qzpchp{display:none}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i][0];
	child_ctx[11] = list[i][1];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i][0];
	child_ctx[11] = list[i][1];
	return child_ctx;
}

// (49:0) <Row>
function create_default_slot$2(ctx) {
	let button0;
	let t0;
	let button1;
	let t1;
	let button2;
	let current;

	button0 = new Button({
			props: {
				inline: true,
				small: true,
				icon: /*hideJsonKeys*/ ctx[1] ? "eye" : "eye-slash",
				label: /*hideJsonKeys*/ ctx[1] ? "Show keys" : "Hide keys"
			}
		});

	button0.$on("click", /*click_handler*/ ctx[3]);

	button1 = new Button({
			props: {
				inline: true,
				small: true,
				icon: "edit",
				label: "Set default"
			}
		});

	button1.$on("click", /*click_handler_1*/ ctx[4]);

	button2 = new Button({
			props: {
				inline: true,
				small: true,
				icon: "edit",
				label: "Set required"
			}
		});

	button2.$on("click", /*click_handler_2*/ ctx[5]);

	return {
		c() {
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			create_component(button2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t0, anchor);
			mount_component(button1, target, anchor);
			insert(target, t1, anchor);
			mount_component(button2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};
			if (dirty & /*hideJsonKeys*/ 2) button0_changes.icon = /*hideJsonKeys*/ ctx[1] ? "eye" : "eye-slash";
			if (dirty & /*hideJsonKeys*/ 2) button0_changes.label = /*hideJsonKeys*/ ctx[1] ? "Show keys" : "Hide keys";
			button0.$set(button0_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t0);
			destroy_component(button1, detaching);
			if (detaching) detach(t1);
			destroy_component(button2, detaching);
		}
	};
}

// (93:2) {:else}
function create_else_block$1(ctx) {
	let t;

	return {
		c() {
			t = text("No properties defined.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (55:2) {#if param.schema && param.keys}
function create_if_block$2(ctx) {
	let each_1_anchor;
	let each_value = /*param*/ ctx[0].keys;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value = /*param*/ ctx[0].keys;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (62:10) {#if param.schema.properties[propKey].description}
function create_if_block_5(ctx) {
	let div;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].description + "";
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text("Description: ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].description + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (65:10) {#if param.schema.properties[propKey].example}
function create_if_block_4(ctx) {
	let div;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].example + "";
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text("Example: ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].example + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (76:119) 
function create_if_block_2$2(ctx) {
	let div1;
	let div0;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].items.type + "";
	let t1;
	let t2;
	let if_block = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]]?.items?.properties && create_if_block_3$2(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t0 = text("Containing: ");
			t1 = text(t1_value);
			t2 = space();
			if (if_block) if_block.c();
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, t0);
			append(div0, t1);
			append(div1, t2);
			if (if_block) if_block.m(div1, null);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].items.type + "")) set_data(t1, t1_value);

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]]?.items?.properties) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$2(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
		}
	};
}

// (68:10) {#if param.schema.properties[propKey].type === "object"}
function create_if_block_1$2(ctx) {
	let t0_value = "{" + "";
	let t0;
	let t1;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let t3_value = "}" + "";
	let t3;
	let each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].properties);
	const get_key = ctx => /*pKey*/ ctx[10];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].properties);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, destroy_block, create_each_block_1, null, get_each_context_1);
			}
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (79:14) {#if param.schema.properties[propKey].items.type === "object" && param.schema.properties[propKey]?.items?.properties}
function create_if_block_3$2(ctx) {
	let t0_value = "{" + "";
	let t0;
	let t1;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let t3_value = "}" + "";
	let t3;
	let each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].items.properties);
	const get_key = ctx => /*pKey*/ ctx[10];

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
	}

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].items.properties);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, ul, destroy_block, create_each_block_2, null, get_each_context_2);
			}
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (82:18) {#each Object.entries(param.schema.properties[propKey].items.properties) as [pKey, p] (pKey)}
function create_each_block_2(key_1, ctx) {
	let p;
	let t0_value = /*pKey*/ ctx[10] + "";
	let t0;
	let t1;
	let t2_value = /*p*/ ctx[11].type + "";
	let t2;

	return {
		key: key_1,
		first: null,
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
			this.first = p;
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[10] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[11].type + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (71:14) {#each Object.entries(param.schema.properties[propKey].properties) as [pKey, p] (pKey)}
function create_each_block_1(key_1, ctx) {
	let p;
	let t0_value = /*pKey*/ ctx[10] + "";
	let t0;
	let t1;
	let t2_value = /*p*/ ctx[11].type + "";
	let t2;

	return {
		key: key_1,
		first: null,
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
			this.first = p;
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[10] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[11].type + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (56:4) {#each param.keys as propKey}
function create_each_block(ctx) {
	let ul;
	let li;
	let div;
	let t0_value = /*propKey*/ ctx[7] + "";
	let t0;
	let t1;
	let t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].type + "";
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;

	function func(...args) {
		return /*func*/ ctx[6](/*propKey*/ ctx[7], ...args);
	}

	let if_block0 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].description && create_if_block_5(ctx);
	let if_block1 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].example && create_if_block_4(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].type === "object") return create_if_block_1$2;
		if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].type === "array" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]]?.items?.type) return create_if_block_2$2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block2 = current_block_type && current_block_type(ctx);

	return {
		c() {
			ul = element("ul");
			li = element("li");
			div = element("div");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			if (if_block2) if_block2.c();
			t6 = space();
			toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
		},
		m(target, anchor) {
			insert(target, ul, anchor);
			append(ul, li);
			append(li, div);
			append(div, t0);
			append(div, t1);
			append(div, t2);
			append(li, t3);
			if (if_block0) if_block0.m(li, null);
			append(li, t4);
			if (if_block1) if_block1.m(li, null);
			append(li, t5);
			if (if_block2) if_block2.m(li, null);
			append(ul, t6);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*propKey*/ ctx[7] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].type + "")) set_data(t2, t2_value);

			if (dirty & /*param*/ 1) {
				toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
			}

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].description) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					if_block0.m(li, t4);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[7]].example) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					if_block1.m(li, t5);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if (if_block2) if_block2.d(1);
				if_block2 = current_block_type && current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(li, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();

			if (if_block2) {
				if_block2.d();
			}
		}
	};
}

function create_fragment$2(ctx) {
	let row;
	let t;
	let div;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	function select_block_type(ctx, dirty) {
		if (/*param*/ ctx[0].schema && /*param*/ ctx[0].keys) return create_if_block$2;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			create_component(row.$$.fragment);
			t = space();
			div = element("div");
			if_block.c();
			attr(div, "class", "svelte-qzpchp");
			toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);
			if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};

			if (dirty & /*$$scope, param, hideJsonKeys*/ 65539) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*hideJsonKeys*/ 2) {
				toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { param } = $$props;

	const setJsonKeys = (param, option) => {
		const required = [];
		const notRequired = [];
		const exists = [];
		const propKeys = Object.keys(param.schema.properties);
		let fieldValue = window.$('#node-input-' + param.id).typedInput('value');

		try {
			fieldValue = JSON.parse(fieldValue);
		} catch {
			fieldValue = {};
		}

		propKeys.forEach(prop => {
			if (fieldValue[prop]) {
				const value = fieldValue[prop];

				// chk if value is empty array or object -> would return "" otherwise
				if (typeof value === 'object') {
					if (Array.isArray(value) && value.length === 0) exists.push(`"${prop}": []`); else if (Object.keys(value).length === 0) exists.push(`"${prop}": {}`); else exists.push(`"${prop}": "${value}"`);
				} else {
					exists.push(`"${prop}": "${value}"`);
				}
			} else {
				let isRequired = false;
				if (param.schema.required) isRequired = param.schema.required.find(reqParam => reqParam === prop);

				if (isRequired) {
					required.push(`"${prop}": "${param.schema.properties[prop].type} - required"`);
				} else {
					notRequired.push(`"${prop}": "${param.schema.properties[prop].type}"`);
				}
			}
		});

		let result = required.concat(exists);
		if (option === 'default') result = result.concat(notRequired);
		result = '{' + result.join(', ') + '}';

		// jQuery because setting node.parameters[index].value does not work
		window.$('#node-input-' + param.id).typedInput('value', result);
	};

	let hideJsonKeys = true;
	const click_handler = () => $$invalidate(1, hideJsonKeys = !hideJsonKeys);
	const click_handler_1 = () => setJsonKeys(param, "default");
	const click_handler_2 = () => setJsonKeys(param, "required");
	const func = (propKey, reqParam) => reqParam === propKey;

	$$self.$$set = $$props => {
		if ('param' in $$props) $$invalidate(0, param = $$props.param);
	};

	return [
		param,
		hideJsonKeys,
		setJsonKeys,
		click_handler,
		click_handler_1,
		click_handler_2,
		func
	];
}

class JsonParamHelper extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { param: 0 }, add_css$2);
	}
}

/* src/components/Parameters.svelte generated by Svelte v3.44.2 */

function add_css$1(target) {
	append_styles(target, "svelte-1801t9r", ".header.svelte-1801t9r{min-width:70%;display:inline-flex;justify-content:flex-end}#openApi-red-svelte-container .shortParameterLabel{width:250px;min-width:250px}#openApi-red-svelte-container #openApiDescriptionButton button{width:100px}");
}

// (31:0) {#if node.api && node.operation}
function create_if_block$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0].parameters.length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (64:2) {:else}
function create_else_block(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};

			if (dirty & /*$$scope*/ 512) {
				callout_changes.$$scope = { dirty, ctx };
			}

			callout.$set(callout_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (32:2) {#if node.parameters.length > 0}
function create_if_block_1$1(ctx) {
	let editablelist;
	let updating_elements;
	let current;

	function editablelist_elements_binding(value) {
		/*editablelist_elements_binding*/ ctx[6](value);
	}

	let editablelist_props = {
		label: "Parameters",
		maxHeight: "1000",
		$$slots: {
			tableHeader: [
				create_tableHeader_slot,
				({ element: param, index }) => ({ 7: param, 8: index }),
				({ element: param, index }) => (param ? 128 : 0) | (index ? 256 : 0)
			],
			header: [
				create_header_slot$1,
				({ element: param, index }) => ({ 7: param, 8: index }),
				({ element: param, index }) => (param ? 128 : 0) | (index ? 256 : 0)
			],
			default: [
				create_default_slot_1$1,
				({ element: param, index }) => ({ 7: param, 8: index }),
				({ element: param, index }) => (param ? 128 : 0) | (index ? 256 : 0)
			]
		},
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0].parameters !== void 0) {
		editablelist_props.elements = /*node*/ ctx[0].parameters;
	}

	editablelist = new EditableList({ props: editablelist_props });
	binding_callbacks.push(() => bind(editablelist, 'elements', editablelist_elements_binding));

	return {
		c() {
			create_component(editablelist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(editablelist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const editablelist_changes = {};

			if (dirty & /*$$scope, showAllDescriptions, param, node, index*/ 899) {
				editablelist_changes.$$scope = { dirty, ctx };
			}

			if (!updating_elements && dirty & /*node*/ 1) {
				updating_elements = true;
				editablelist_changes.elements = /*node*/ ctx[0].parameters;
				add_flush_callback(() => updating_elements = false);
			}

			editablelist.$set(editablelist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(editablelist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(editablelist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(editablelist, detaching);
		}
	};
}

// (65:4) <Callout type="info">
function create_default_slot_4$1(ctx) {
	let t;

	return {
		c() {
			t = text("No parameters found!");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (43:6) <Row>
function create_default_slot_3$1(ctx) {
	let input;
	let t0;
	let typedinput;
	let t1;
	let button;
	let current;

	function change_handler(...args) {
		return /*change_handler*/ ctx[3](/*index*/ ctx[8], ...args);
	}

	input = new Input({
			props: {
				inline: true,
				type: "checkbox",
				label: /*param*/ ctx[7].required
				? /*param*/ ctx[7].name + '*'
				: /*param*/ ctx[7].name,
				value: /*param*/ ctx[7].isActive,
				disabled: /*param*/ ctx[7].required,
				clazz: /*param*/ ctx[7].required
				? "shortParameterLabel required"
				: "shortParameterLabel"
			}
		});

	input.$on("change", change_handler);

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[4](/*index*/ ctx[8], ...args);
	}

	typedinput = new TypedInput({
			props: {
				inline: true,
				types: /*param*/ ctx[7].allowedTypes,
				type: /*param*/ ctx[7].type,
				value: /*param*/ ctx[7].value,
				id: /*param*/ ctx[7].id,
				disabled: !/*param*/ ctx[7].isActive
			}
		});

	typedinput.$on("change", change_handler_1);

	function click_handler() {
		return /*click_handler*/ ctx[5](/*index*/ ctx[8]);
	}

	button = new Button({
			props: {
				inline: true,
				small: true,
				icon: /*node*/ ctx[0].parameters[/*index*/ ctx[8]].showDescription
				? "eye-slash"
				: "eye"
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			create_component(input.$$.fragment);
			t0 = space();
			create_component(typedinput.$$.fragment);
			t1 = space();
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			insert(target, t0, anchor);
			mount_component(typedinput, target, anchor);
			insert(target, t1, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};

			if (dirty & /*param*/ 128) input_changes.label = /*param*/ ctx[7].required
			? /*param*/ ctx[7].name + '*'
			: /*param*/ ctx[7].name;

			if (dirty & /*param*/ 128) input_changes.value = /*param*/ ctx[7].isActive;
			if (dirty & /*param*/ 128) input_changes.disabled = /*param*/ ctx[7].required;

			if (dirty & /*param*/ 128) input_changes.clazz = /*param*/ ctx[7].required
			? "shortParameterLabel required"
			: "shortParameterLabel";

			input.$set(input_changes);
			const typedinput_changes = {};
			if (dirty & /*param*/ 128) typedinput_changes.types = /*param*/ ctx[7].allowedTypes;
			if (dirty & /*param*/ 128) typedinput_changes.type = /*param*/ ctx[7].type;
			if (dirty & /*param*/ 128) typedinput_changes.value = /*param*/ ctx[7].value;
			if (dirty & /*param*/ 128) typedinput_changes.id = /*param*/ ctx[7].id;
			if (dirty & /*param*/ 128) typedinput_changes.disabled = !/*param*/ ctx[7].isActive;
			typedinput.$set(typedinput_changes);
			const button_changes = {};

			if (dirty & /*node, index*/ 257) button_changes.icon = /*node*/ ctx[0].parameters[/*index*/ ctx[8]].showDescription
			? "eye-slash"
			: "eye";

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(typedinput.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(typedinput.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
			if (detaching) detach(t0);
			destroy_component(typedinput, detaching);
			if (detaching) detach(t1);
			destroy_component(button, detaching);
		}
	};
}

// (55:6) {#if param.showDescription}
function create_if_block_3$1(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				small: true,
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};

			if (dirty & /*$$scope, param*/ 640) {
				callout_changes.$$scope = { dirty, ctx };
			}

			callout.$set(callout_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (56:8) <Callout type="info" small>
function create_default_slot_2$1(ctx) {
	let t_value = /*param*/ ctx[7].description + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 128 && t_value !== (t_value = /*param*/ ctx[7].description + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (60:6) {#if param?.schema?.type === "object"}
function create_if_block_2$1(ctx) {
	let jsonparamhelper;
	let current;
	jsonparamhelper = new JsonParamHelper({ props: { param: /*param*/ ctx[7] } });

	return {
		c() {
			create_component(jsonparamhelper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(jsonparamhelper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const jsonparamhelper_changes = {};
			if (dirty & /*param*/ 128) jsonparamhelper_changes.param = /*param*/ ctx[7];
			jsonparamhelper.$set(jsonparamhelper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(jsonparamhelper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(jsonparamhelper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(jsonparamhelper, detaching);
		}
	};
}

// (33:4) <EditableList label="Parameters" bind:elements={node.parameters} let:element={param} let:index maxHeight="1000" >
function create_default_slot_1$1(ctx) {
	let row;
	let t0;
	let t1;
	let if_block1_anchor;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	let if_block0 = /*param*/ ctx[7].showDescription && create_if_block_3$1(ctx);
	let if_block1 = /*param*/ ctx[7]?.schema?.type === "object" && create_if_block_2$1(ctx);

	return {
		c() {
			create_component(row.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			insert(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope, node, index, param*/ 897) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (/*param*/ ctx[7].showDescription) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*param*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*param*/ ctx[7]?.schema?.type === "object") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*param*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (34:6) 
function create_header_slot$1(ctx) {
	let span;
	let button;
	let current;

	button = new Button({
			props: {
				inline: true,
				small: true,
				id: "openApiDescriptionButton",
				icon: /*showAllDescriptions*/ ctx[1] ? "eye-slash" : "eye",
				label: /*showAllDescriptions*/ ctx[1]
				? "hide description"
				: "show description"
			}
		});

	button.$on("click", /*toggleAllShowDescription*/ ctx[2]);

	return {
		c() {
			span = element("span");
			create_component(button.$$.fragment);
			attr(span, "slot", "header");
			attr(span, "class", "header svelte-1801t9r");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*showAllDescriptions*/ 2) button_changes.icon = /*showAllDescriptions*/ ctx[1] ? "eye-slash" : "eye";

			if (dirty & /*showAllDescriptions*/ 2) button_changes.label = /*showAllDescriptions*/ ctx[1]
			? "hide description"
			: "show description";

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button);
		}
	};
}

// (38:8) <Row>
function create_default_slot$1(ctx) {
	let span0;
	let t2;
	let span1;

	return {
		c() {
			span0 = element("span");
			span0.innerHTML = `Name <b>(*=required)</b>`;
			t2 = space();
			span1 = element("span");
			span1.textContent = "Value";
			set_style(span0, "width", "255px");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			insert(target, t2, anchor);
			insert(target, span1, anchor);
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(t2);
			if (detaching) detach(span1);
		}
	};
}

// (37:6) 
function create_tableHeader_slot(ctx) {
	let span;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			span = element("span");
			create_component(row.$$.fragment);
			attr(span, "slot", "tableHeader");
			attr(span, "class", "tableHeader");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(row, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 512) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(row);
		}
	};
}

function create_fragment$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*node*/ ctx[0].api && /*node*/ ctx[0].operation && create_if_block$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*node*/ ctx[0].api && /*node*/ ctx[0].operation) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*node*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { node } = $$props;
	node.parameters.forEach(param => param.showDescription = false);
	let showAllDescriptions = false;

	const toggleAllShowDescription = () => {
		$$invalidate(1, showAllDescriptions = !showAllDescriptions);
		node.parameters.forEach(param => param.showDescription = showAllDescriptions);
		$$invalidate(0, node);
	};

	const change_handler = (index, e) => $$invalidate(0, node.parameters[index].isActive = e.detail.value, node);

	const change_handler_1 = (index, e) => {
		$$invalidate(0, node.parameters[index].value = e.detail.value, node);
		$$invalidate(0, node.parameters[index].type = e.detail.type, node);
	};

	const click_handler = index => $$invalidate(0, node.parameters[index].showDescription = !node.parameters[index].showDescription, node);

	function editablelist_elements_binding(value) {
		if ($$self.$$.not_equal(node.parameters, value)) {
			node.parameters = value;
			$$invalidate(0, node);
		}
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
	};

	return [
		node,
		showAllDescriptions,
		toggleAllShowDescription,
		change_handler,
		change_handler_1,
		click_handler,
		editablelist_elements_binding
	];
}

class Parameters extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { node: 0 }, add_css$1);
	}
}

// for node (client) and config (server)
const createBackwardCompatible = (obj) => {
  if (typeof obj.requestContentType === 'undefined') obj.requestContentType = obj.contentType;
  if (typeof obj.responseContentType === 'undefined') obj.responseContentType = '';
  if (typeof obj.alternServer === 'undefined') obj.alternServer = false;
  if (typeof obj.keepAuth === 'undefined') obj.keepAuth = false;
  if (typeof obj.showDescription === 'undefined') obj.showDescription = true;
  if (typeof obj.internalErrors === 'undefined') obj.internalErrors = {};
};

var utils = {
  createBackwardCompatible
};

/* src/openApi-red.svelte generated by Svelte v3.44.2 */

function add_css(target) {
	append_styles(target, "svelte-5rrhdd", "#openApi-red-svelte-container :is(.required, .required label){font-weight:bold !important}#openApi-red-svelte-container .sir-Row label{min-width:150px}#openApi-red-svelte-container .sir-Row label i{min-width:14px}.sir-Group.paddingBottom > .sir-Group-container{padding-bottom:12px}.success .fa-check-square{color:var(--red-ui-text-color-success)}");
}

// (145:0) {#if data.error}
function create_if_block_3(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "error",
				$$slots: {
					header: [create_header_slot_1],
					default: [create_default_slot_5]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const callout_changes = {};

			if (dirty & /*$$scope, data*/ 4098) {
				callout_changes.$$scope = { dirty, ctx };
			}

			callout.$set(callout_changes);
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (146:2) <Callout type="error">
function create_default_slot_5(ctx) {
	let t_value = /*data*/ ctx[1].error + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 2 && t_value !== (t_value = /*data*/ ctx[1].error + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (147:4) 
function create_header_slot_1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (156:4) {#if !data.error }
function create_if_block_2(ctx) {
	let parameters;
	let updating_node;
	let current;

	function parameters_node_binding(value) {
		/*parameters_node_binding*/ ctx[7](value);
	}

	let parameters_props = {};

	if (/*node*/ ctx[0] !== void 0) {
		parameters_props.node = /*node*/ ctx[0];
	}

	parameters = new Parameters({ props: parameters_props });
	binding_callbacks.push(() => bind(parameters, 'node', parameters_node_binding));

	return {
		c() {
			create_component(parameters.$$.fragment);
		},
		m(target, anchor) {
			mount_component(parameters, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const parameters_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				parameters_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			parameters.$set(parameters_changes);
		},
		i(local) {
			if (current) return;
			transition_in(parameters.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(parameters.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(parameters, detaching);
		}
	};
}

// (153:1) <TabContent tab="general">
function create_default_slot_4(ctx) {
	let generaloptions;
	let updating_node;
	let updating_data;
	let t0;
	let apioptions;
	let updating_node_1;
	let updating_data_1;
	let t1;
	let if_block_anchor;
	let current;

	function generaloptions_node_binding(value) {
		/*generaloptions_node_binding*/ ctx[3](value);
	}

	function generaloptions_data_binding(value) {
		/*generaloptions_data_binding*/ ctx[4](value);
	}

	let generaloptions_props = {};

	if (/*node*/ ctx[0] !== void 0) {
		generaloptions_props.node = /*node*/ ctx[0];
	}

	if (/*data*/ ctx[1] !== void 0) {
		generaloptions_props.data = /*data*/ ctx[1];
	}

	generaloptions = new GeneralOptions({ props: generaloptions_props });
	binding_callbacks.push(() => bind(generaloptions, 'node', generaloptions_node_binding));
	binding_callbacks.push(() => bind(generaloptions, 'data', generaloptions_data_binding));

	function apioptions_node_binding(value) {
		/*apioptions_node_binding*/ ctx[5](value);
	}

	function apioptions_data_binding(value) {
		/*apioptions_data_binding*/ ctx[6](value);
	}

	let apioptions_props = {};

	if (/*node*/ ctx[0] !== void 0) {
		apioptions_props.node = /*node*/ ctx[0];
	}

	if (/*data*/ ctx[1] !== void 0) {
		apioptions_props.data = /*data*/ ctx[1];
	}

	apioptions = new ApiOptions({ props: apioptions_props });
	binding_callbacks.push(() => bind(apioptions, 'node', apioptions_node_binding));
	binding_callbacks.push(() => bind(apioptions, 'data', apioptions_data_binding));
	let if_block = !/*data*/ ctx[1].error && create_if_block_2(ctx);

	return {
		c() {
			create_component(generaloptions.$$.fragment);
			t0 = space();
			create_component(apioptions.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(generaloptions, target, anchor);
			insert(target, t0, anchor);
			mount_component(apioptions, target, anchor);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const generaloptions_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				generaloptions_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_data && dirty & /*data*/ 2) {
				updating_data = true;
				generaloptions_changes.data = /*data*/ ctx[1];
				add_flush_callback(() => updating_data = false);
			}

			generaloptions.$set(generaloptions_changes);
			const apioptions_changes = {};

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				apioptions_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			if (!updating_data_1 && dirty & /*data*/ 2) {
				updating_data_1 = true;
				apioptions_changes.data = /*data*/ ctx[1];
				add_flush_callback(() => updating_data_1 = false);
			}

			apioptions.$set(apioptions_changes);

			if (!/*data*/ ctx[1].error) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(generaloptions.$$.fragment, local);
			transition_in(apioptions.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(generaloptions.$$.fragment, local);
			transition_out(apioptions.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(generaloptions, detaching);
			if (detaching) detach(t0);
			destroy_component(apioptions, detaching);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (162:4) {#if node.keepAuth}
function create_if_block_1(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "info",
				small: true,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (163:6) <Callout type="info" small>
function create_default_slot_3(ctx) {
	let t;

	return {
		c() {
			t = text("msg.openApiToken and msg.headers will not be deleted and can be seen by other nodes in the flow.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (168:4) {#if node.devMode}
function create_if_block(ctx) {
	let callout;
	let current;

	callout = new Callout({
			props: {
				type: "warning",
				$$slots: {
					header: [create_header_slot],
					default: [create_default_slot_2]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(callout.$$.fragment);
		},
		m(target, anchor) {
			mount_component(callout, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(callout.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(callout.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(callout, detaching);
		}
	};
}

// (169:6) <Callout type="warning">
function create_default_slot_2(ctx) {
	let p0;
	let t1;
	let p1;

	return {
		c() {
			p0 = element("p");
			p0.textContent = "Dev mode is experimental!";
			t1 = space();
			p1 = element("p");
			p1.textContent = "Allows to make otherwise rejected calls like when using self signed or expired certificates.";
		},
		m(target, anchor) {
			insert(target, p0, anchor);
			insert(target, t1, anchor);
			insert(target, p1, anchor);
		},
		d(detaching) {
			if (detaching) detach(p0);
			if (detaching) detach(t1);
			if (detaching) detach(p1);
		}
	};
}

// (170:8) 
function create_header_slot(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Warning!";
			attr(span, "slot", "header");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (160:2) <TabContent tab="advanced">
function create_default_slot_1(ctx) {
	let input0;
	let updating_node;
	let t0;
	let t1;
	let input1;
	let updating_node_1;
	let t2;
	let if_block1_anchor;
	let current;

	function input0_node_binding(value) {
		/*input0_node_binding*/ ctx[8](value);
	}

	let input0_props = {
		prop: "keepAuth",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input0_props.node = /*node*/ ctx[0];
	}

	input0 = new Input({ props: input0_props });
	binding_callbacks.push(() => bind(input0, 'node', input0_node_binding));
	let if_block0 = /*node*/ ctx[0].keepAuth && create_if_block_1(ctx);

	function input1_node_binding(value) {
		/*input1_node_binding*/ ctx[9](value);
	}

	let input1_props = {
		prop: "devMode",
		labelBeforeCheckbox: true
	};

	if (/*node*/ ctx[0] !== void 0) {
		input1_props.node = /*node*/ ctx[0];
	}

	input1 = new Input({ props: input1_props });
	binding_callbacks.push(() => bind(input1, 'node', input1_node_binding));
	let if_block1 = /*node*/ ctx[0].devMode && create_if_block(ctx);

	return {
		c() {
			create_component(input0.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			create_component(input1.$$.fragment);
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			mount_component(input0, target, anchor);
			insert(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t1, anchor);
			mount_component(input1, target, anchor);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input0_changes = {};

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				input0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input0.$set(input0_changes);

			if (/*node*/ ctx[0].keepAuth) {
				if (if_block0) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const input1_changes = {};

			if (!updating_node_1 && dirty & /*node*/ 1) {
				updating_node_1 = true;
				input1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input1.$set(input1_changes);

			if (/*node*/ ctx[0].devMode) {
				if (if_block1) {
					if (dirty & /*node*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(input1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(input1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			destroy_component(input0, detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			destroy_component(input1, detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (152:0) <TabbedPane bind:tabs>
function create_default_slot(ctx) {
	let tabcontent0;
	let t;
	let tabcontent1;
	let current;

	tabcontent0 = new TabContent({
			props: {
				tab: "general",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	tabcontent1 = new TabContent({
			props: {
				tab: "advanced",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(tabcontent0.$$.fragment);
			t = space();
			create_component(tabcontent1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tabcontent0, target, anchor);
			insert(target, t, anchor);
			mount_component(tabcontent1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tabcontent0_changes = {};

			if (dirty & /*$$scope, node, data*/ 4099) {
				tabcontent0_changes.$$scope = { dirty, ctx };
			}

			tabcontent0.$set(tabcontent0_changes);
			const tabcontent1_changes = {};

			if (dirty & /*$$scope, node*/ 4097) {
				tabcontent1_changes.$$scope = { dirty, ctx };
			}

			tabcontent1.$set(tabcontent1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tabcontent0.$$.fragment, local);
			transition_in(tabcontent1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tabcontent0.$$.fragment, local);
			transition_out(tabcontent1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tabcontent0, detaching);
			if (detaching) detach(t);
			destroy_component(tabcontent1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let t;
	let tabbedpane;
	let updating_tabs;
	let current;
	let if_block = /*data*/ ctx[1].error && create_if_block_3(ctx);

	function tabbedpane_tabs_binding(value) {
		/*tabbedpane_tabs_binding*/ ctx[10](value);
	}

	let tabbedpane_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*tabs*/ ctx[2] !== void 0) {
		tabbedpane_props.tabs = /*tabs*/ ctx[2];
	}

	tabbedpane = new TabbedPane({ props: tabbedpane_props });
	binding_callbacks.push(() => bind(tabbedpane, 'tabs', tabbedpane_tabs_binding));

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			create_component(tabbedpane.$$.fragment);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			mount_component(tabbedpane, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*data*/ ctx[1].error) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*data*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const tabbedpane_changes = {};

			if (dirty & /*$$scope, node, data*/ 4099) {
				tabbedpane_changes.$$scope = { dirty, ctx };
			}

			if (!updating_tabs && dirty & /*tabs*/ 4) {
				updating_tabs = true;
				tabbedpane_changes.tabs = /*tabs*/ ctx[2];
				add_flush_callback(() => updating_tabs = false);
			}

			tabbedpane.$set(tabbedpane_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(tabbedpane.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(tabbedpane.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			destroy_component(tabbedpane, detaching);
		}
	};
}

RED.nodes.registerType('openApi-red', {
	category: 'network',
	color: '#b197ff',
	defaults: {
		name: {
			value: '',
			label: 'Name',
			placeholder: 'openApi-red',
			icon: 'tag'
		},
		openApiUrl: {
			value: '',
			label: 'URL',
			icon: 'globe',
			validate(v) {
				return v && !this?.internalErrors?.readUrl;
			}
		},
		api: { value: '', label: 'API tag' },
		server: { value: '' },
		keepAuth: {
			value: false,
			label: 'Keep authentification',
			icon: 'lock'
		},
		alternServer: { value: false, label: 'Use server option' },
		operation: { value: '', label: 'Operation' },
		operationData: { value: {} },
		errorHandling: {
			value: 'Standard',
			label: 'Error handling'
		},
		internalErrors: { value: {} },
		parameters: {
			value: [],
			label: 'Parameters',
			validate(parameters) {
				if (!parameters || !Array.isArray(parameters) || parameters.length === 0) {
					return true;
				} else {
					let isValid = true;

					parameters.forEach(p => {
						if (isValid && p.isActive) {
							if (p.required && p.value.trim() === '') isValid = false;

							// validation of typedinput only if element exists!
							if (isValid && window.$('#node-input-' + p.id).length) isValid = window.$('#node-input-' + p.id).typedInput('validate');
						}
					});

					return isValid;
				}
			}
		},
		requestContentType: { value: '', label: 'Request Content Type' },
		responseContentType: {
			value: '',
			label: 'Response Content Type'
		},
		showDescription: { value: true },
		devMode: {
			value: false,
			label: 'Development Mode',
			icon: 'at'
		},
		outputs: { value: 1 }
	},
	inputs: 1,
	outputs: 1,
	icon: 'white-globe.png',
	label() {
		if (this.name) return this.name; else if (this.operation) return this.operation; else return 'openApi client';
	},
	oneditprepare() {
		render(this, { minWidth: '600px' });
	},
	oneditsave() {
		update(this);
		this.outputs = 'other output' === this.errorHandling ? 2 : 1;
	},
	oneditcancel() {
		revert(this);
	}
});

function instance($$self, $$props, $$invalidate) {
	let { node } = $$props;

	let data = {
		openApiSpec: { apiList: {}, servers: [] },
		error: '',
		operationDescription: '',
		prevOperation: node.operation ? node.operation.toString() : '',
		contentTypes: { request: [], response: [] },
		oldParameters: {},
		init: true
	};

	utils.createBackwardCompatible(node);
	node.internalErrors.readUrl = true;

	// let init = true
	if (node.openApiUrl.toString().trim()) {
		htmlFunctions.createApi(node, data).then(() => {
			($$invalidate(0, node), $$invalidate(1, data));
			($$invalidate(1, data), $$invalidate(0, node));
		});
	}

	let tabs = {
		"general": "General",
		"advanced": "Advanced"
	};

	const initContentType = type => {
		if (!data.contentTypes[type].length) {
			$$invalidate(0, node[type + 'ContentType'] = '', node);
		} else if (!data.contentTypes[type].includes(node[type + 'ContentType'])) {
			$$invalidate(0, node[type + 'ContentType'] = data.contentTypes[type][0], node);
		}
	};

	function generaloptions_node_binding(value) {
		node = value;
		($$invalidate(0, node), $$invalidate(1, data));
	}

	function generaloptions_data_binding(value) {
		data = value;
		($$invalidate(1, data), $$invalidate(0, node));
	}

	function apioptions_node_binding(value) {
		node = value;
		($$invalidate(0, node), $$invalidate(1, data));
	}

	function apioptions_data_binding(value) {
		data = value;
		($$invalidate(1, data), $$invalidate(0, node));
	}

	function parameters_node_binding(value) {
		node = value;
		($$invalidate(0, node), $$invalidate(1, data));
	}

	function input0_node_binding(value) {
		node = value;
		($$invalidate(0, node), $$invalidate(1, data));
	}

	function input1_node_binding(value) {
		node = value;
		($$invalidate(0, node), $$invalidate(1, data));
	}

	function tabbedpane_tabs_binding(value) {
		tabs = value;
		$$invalidate(2, tabs);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data, node*/ 3) {
			// create content type selection and parameter list
			if (Object.keys(data.openApiSpec.apiList || {}).length && node.operation) {
				$$invalidate(1, data.operationDescription = htmlFunctions.createOperationDescription(data.openApiSpec.apiList, node), data);

				// set valid content Types if operation is set
				const operationSchema = data.openApiSpec.apiList?.[node.api]?.[node.operation];

				$$invalidate(1, data.contentTypes.request = htmlFunctions.getRequestContentTypes(operationSchema), data);
				initContentType('request');
				$$invalidate(1, data.contentTypes.response = htmlFunctions.getResponseContentTypes(operationSchema), data);
				initContentType('response');

				// clear parameters if operation has changed
				if (data.prevOperation !== node.operation) {
					node.parameters.splice(0, node.parameters.length);
					$$invalidate(1, data.prevOperation = node.operation, data);
					$$invalidate(0, node.operationData = data.openApiSpec.apiList?.[node.api]?.[node.operation] || {}, node);
					htmlFunctions.createParameters(node, data.oldParameters);
				}
			}
		}
	};

	return [
		node,
		data,
		tabs,
		generaloptions_node_binding,
		generaloptions_data_binding,
		apioptions_node_binding,
		apioptions_data_binding,
		parameters_node_binding,
		input0_node_binding,
		input1_node_binding,
		tabbedpane_tabs_binding
	];
}

class OpenApi_red extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { node: 0 }, add_css);
	}
}



              }
            </script>
            <script type="text/x-red" data-template-name="openApi-red">
              <div id='openApi-red-svelte-container'></div>
            </script>
            <script type="text/x-red" data-help-name="openApi-red">
                <p>Use OpenAPI / Swagger with Node-Red.</p>
<h3>Inputs</h3>
    <dl class="message-properties">
        <dt>Name
            <span class="property-type">string</span>
        </dt>
        <dd> set a manuell name for the node. If no name is set, the node sets the selected operation name.</dd>
        <dt>URL
            <span class="property-type">string</span>
        </dt>
        <dd> set the full url domain name (incl. http:// / https://) for the OpenAPI document. By clicking on 'read' it will build the API and operation Selectors.</dd>
        <dt>API tag
            <span class="property-type">enum</span>
        </dt>
        <dd> Preselector for the operation. Grouped by the 'tags' in each operation. </dd>
        <dt>Operation
            <span class="property-type">enum</span>
        </dt>
        <dd> Selector for the OpenAPI operation. The selection name is set by the 'summary'. Behind the selector field is the (unique) operation id. By mouse-over it will show the full operation Description.</dd>
        <dt class="optional">Parameters <span class="property-type">depending</span></dt>
        <dd> If the selected operation has parameters, they will be listed here. The description can be found by mouse-over the parameter name. If the parameter is required, it will be marked with a red star behind the name.
            For Json Objects with defined keys there will be 3 Buttons: 'set required' and 'set default' will build a json-object with the correct key names and the necessary type info as the value. 'show keys' show all possible key parameters with additional info by mouse-over the key name.
        </dd>
        <dt>Request / Response content type
          <span class="property-type">selection</span>
      </dt>
      <dd> If available select the content type in which you will send / receive the data. For the most cases 'application/json' will be a good choice.</dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
    <dt>Payload <span class="property-type">object</span>
        <dd> Returns the complete OpenAPI object.</dd>
    </dt>
    </dl>

<h3>Authentification</h3>
    For authentification you can use the Node-Red to get your token. This token has to be set into msg.openApiToken.

<h3>Dynamic fields</h3>
For using dynamic OpenApi URL, operation or parameter put those into msg.openApiUrl (string), msg.operation (operationId as string) and msg.parameters (object with key as parameter name). 

<h3>Error handling</h3>
This handles how to react if the server returns a http status of 4xx or 5xx. You can find the last server response in msg.response.
<dl class="message-properties">
    <dt>Standard  <span class="property-type">string</span> </dt>
    <dd> The flow will move on normally so you can choose how to handle this within your flow.</dd>
    <dt> Other output <span class="property-type">string</span></dt>
    <dd> The flow will move on in a second output.</dd>
    <dt> Throw exception <span class="property-type">string</span></dt>
    <dd> The flow will throw an exception. This exception can be catched by the 'catch' node.</dd>
</dl>

<h3>References</h3>
    <ul>
        <li><a href="https://www.npmjs.com/package/swagger-client">Based on npm swagger-client</a> - which does almost all the magic here</li>
        <li><a href="https://gitlab.com/2WeltenChris/svelte-integration-red">SIR</a> - Node designed with svelte</li>
        <li><a href="https://gitlab.com/2WeltenChris/openapi-red">GitHub</a> - the nodes github repository</li>
    </ul>

            </script>
        